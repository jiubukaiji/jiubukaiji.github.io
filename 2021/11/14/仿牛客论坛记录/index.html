<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="仿牛客论坛记录"><meta name="keywords" content=""><meta name="author" content="pb"><meta name="copyright" content="pb"><title>仿牛客论坛记录 | pb</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="pb" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">请简要介绍一下你的项目？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.</span> <span class="toc-text">数据库表设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%A1%A8-user"><span class="toc-number">1.1.1.</span> <span class="toc-text">用户表 user</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%87%AD%E8%AF%81%E8%A1%A8-login-ticket"><span class="toc-number">1.1.2.</span> <span class="toc-text">用户登录凭证表 login_ticket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%96%E5%AD%90%E8%A1%A8-discuss-post"><span class="toc-number">1.1.3.</span> <span class="toc-text">帖子表 discuss_post</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E8%AE%BA%E8%A1%A8-comment"><span class="toc-number">1.1.4.</span> <span class="toc-text">评论表 comment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%A1%A8-message"><span class="toc-number">1.1.5.</span> <span class="toc-text">消息表 message</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C"><span class="toc-number">1.2.</span> <span class="toc-text">注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E5%92%8C%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95"><span class="toc-number">1.3.</span> <span class="toc-text">登录和退出登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E4%BC%98%E5%8C%96%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97"><span class="toc-number">1.4.</span> <span class="toc-text">使用Redis优化登录模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%EF%BC%88%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">检查登录状态（拦截器的使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%96%E3%80%81%E8%AF%84%E8%AE%BA%E3%80%81%E7%A7%81%E4%BF%A1"><span class="toc-number">1.6.</span> <span class="toc-text">发帖、评论、私信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-number">1.7.</span> <span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E5%92%8C%E7%B2%89%E4%B8%9D"><span class="toc-number">1.8.</span> <span class="toc-text">关注和粉丝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka"><span class="toc-number">1.9.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elasticsearch"><span class="toc-number">1.10.</span> <span class="toc-text">Elasticsearch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是Spring框架？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9Spring-IoC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">对Spring IoC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDAO"><span class="toc-number">4.</span> <span class="toc-text">什么是DAO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E5%85%B3%E4%BA%8EBean%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">Spring中关于Bean的注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">Spring MVC是什么，是怎样的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DispatcherServlet%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">DispatcherServlet处理流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">拦截器的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSSM%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">什么是SSM框架？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E7%9A%84%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">怎么实现注册功能的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFInterceptor%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%E5%88%B0%E4%BA%86Interceptor"><span class="toc-number">11.</span> <span class="toc-text">什么是Interceptor，在项目的哪里使用到了Interceptor?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">12.</span> <span class="toc-text">使用什么技术生成验证码?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E7%99%BB%E9%99%86%E7%8A%B6%E6%80%81"><span class="toc-number">13.</span> <span class="toc-text">如何检查登陆状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4"><span class="toc-number">14.</span> <span class="toc-text">如何实现敏感词过滤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAjax%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">什么是Ajax，应用在项目哪些地方？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%8C%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%82"><span class="toc-number">16.</span> <span class="toc-text">什么是事务，事务的四大特性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8Spring%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">17.</span> <span class="toc-text">怎么利用Spring实现事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E7%9A%84%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">是怎样实现统一捕获异常的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E7%9A%84%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">是怎样实现统一记录日志的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BE%80Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%85%8D%E7%BD%AERedis%EF%BC%8C%E4%BB%8B%E7%BB%8D%E5%B8%B8%E8%A7%81%E7%9A%84Redis%E6%93%8D%E4%BD%9C"><span class="toc-number">20.</span> <span class="toc-text">怎么往Spring框架中配置Redis，介绍常见的Redis操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%ADRedis%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">21.</span> <span class="toc-text">项目中Redis的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">22.</span> <span class="toc-text">什么是消息队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFKafka%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">什么是Kafka，有哪些功能和应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">24.</span> <span class="toc-text">Kafka的基础架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86Kafka%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">在项目哪里用到了Kafka？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFElasticSearch%EF%BC%8C%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8A%9F%E8%83%BD%EF%BC%8C%E7%89%B9%E7%82%B9"><span class="toc-number">26.</span> <span class="toc-text">什么是ElasticSearch，存储原理，功能，特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">27.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/111.jpg"></div><div class="author-info__name text-center">pb</div><div class="author-info__description text-center">This is my site</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">97</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pb</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">仿牛客论坛记录</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-14</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">12k</span><span class="post-meta__separator">|</span><span>阅读时长: 38 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>记录仿牛客论坛记录一些不懂的地方</p>
</blockquote>
<a id="more"></a>

<p>运行项目之前的准备：</p>
<p>1.右键pom.xml,设置为maven项目</p>
<p>2.修改compile为jdk1.8</p>
<p>3.在properties中修改端口号、数据库账号密码等等。。</p>
<p>mybatis中有哪些标签？</p>
<p>select、update、insert、sql、if、include</p>
<p>什么是动态sql</p>
<p>分布式架构中存在session共享的问题：</p>
<p>因为要保证负载均衡，所以所以。。</p>
<p>解决方案：粘性session、同步session、将数据存到redis中</p>
<p>@bean和</p>
<p><strong>spring事务管理：  事务的传播机制？</strong></p>
<p>@Transactional，  保证事务是个整体</p>
<p>springboot整合redis</p>
<p>先在pom.xml中导入包，写一个配置类，</p>
<p>再使用redisTemplate来操作</p>
<p>kafka的消息持久化是怎样的？</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48610702/article/details/115859656?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-12.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-12.no_search_link">https://blog.csdn.net/weixin_48610702/article/details/115859656?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-12.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-12.no_search_link</a></p>
<p>使用之前要开启redis、zookeeper、kafka、elasticsearch服务器。</p>
<ul>
<li><p>打开<strong>redis</strong>：切换到redis目录下，输入：<code>redis-server.exe redis.windows.conf</code></p>
</li>
<li><p>打开<strong>Zookeeper</strong>：切换到kafka_2.12-2.3.0，输入：<code>bin\windows\zookeeper-server-start.bat config\zookeeper.properties</code></p>
</li>
<li><p>打开<strong>kafka</strong>：切换到kafka_2.12-2.3.0，输入：<code>bin\windows\kafka-server-start.bat config\server.properties</code></p>
</li>
<li><p>打开<strong>elasticsearch</strong>：切换到elasticsearch目录下，输入：<code>bin\elasticsearch.bat</code></p>
</li>
</ul>
<p>在index页面上做了一点修改，隐藏了最热功能。</p>
<h2 id="请简要介绍一下你的项目？"><a href="#请简要介绍一下你的项目？" class="headerlink" title="请简要介绍一下你的项目？"></a>请简要介绍一下你的项目？</h2><p>这个项目的整体结构来源于牛客网，实现了论坛讨论区，主要使用了Springboot、Mybatis、MySQL、Redis、Kafka等工具。实现了用户的注册、登录、发帖、点赞、系统通知、搜索等功能。另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。使用Elasticsearch实现按关键词搜索帖子的功能。</p>
<p>利用 ThreadLocal 保存用户状态，通过拦截器拦截请求，根据自定义注解判断用户登录状态。<br>使用 Ajax 异步发帖、发送私信、评论，通过字典树过滤敏感词。<br>使用 Redis 实现点赞、关注功能，优化登录模块——存储登录凭证、缓存用户信息、存储 kaptcha 生成的验证码。</p>
<h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a><strong>数据库表设计</strong></h3><h4 id="用户表-user"><a href="#用户表-user" class="headerlink" title="用户表 user"></a><strong>用户表 user</strong></h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>username</td>
<td>varchar</td>
<td>用户名，创建索引</td>
</tr>
<tr>
<td>password</td>
<td>varchar</td>
<td>用户密码</td>
</tr>
<tr>
<td>salt</td>
<td>varchar</td>
<td>加密盐值</td>
</tr>
<tr>
<td>email</td>
<td>varchar</td>
<td>用户邮箱，创建索引</td>
</tr>
<tr>
<td>type</td>
<td>int</td>
<td>用户类型：0 普通、1 管理员、2 版主</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>用户状态：0 未激活、1 已激活</td>
</tr>
<tr>
<td>activation_code</td>
<td>varchar</td>
<td>激活码</td>
</tr>
<tr>
<td>header_url</td>
<td>varchar</td>
<td>用户头像地址</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>注册时间</td>
</tr>
</tbody></table>
<h4 id="用户登录凭证表-login-ticket"><a href="#用户登录凭证表-login-ticket" class="headerlink" title="用户登录凭证表 login_ticket"></a>用户登录凭证表 login_ticket</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>user_id</td>
<td>int</td>
<td>登录用户 id</td>
</tr>
<tr>
<td>ticket</td>
<td>varchar</td>
<td>登录凭证，随机字符串</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>登录状态：0 有效、1 无效</td>
</tr>
<tr>
<td>expired</td>
<td>timestamp</td>
<td>过期时间</td>
</tr>
</tbody></table>
<h4 id="帖子表-discuss-post"><a href="#帖子表-discuss-post" class="headerlink" title="帖子表 discuss_post"></a>帖子表 discuss_post</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>user_id</td>
<td>int</td>
<td>发帖的用户 id，创建索引</td>
</tr>
<tr>
<td>title</td>
<td>varchar</td>
<td>帖子标题</td>
</tr>
<tr>
<td>content</td>
<td>text</td>
<td>帖子内容</td>
</tr>
<tr>
<td>type</td>
<td>int</td>
<td>帖子类型：0 普通、1 置顶</td>
</tr>
<tr>
<td>comment_count</td>
<td>int</td>
<td>评论数量</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>帖子状态：0 普通、1 精华、2 拉黑</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>帖子发表时间</td>
</tr>
</tbody></table>
<h4 id="评论表-comment"><a href="#评论表-comment" class="headerlink" title="评论表 comment"></a>评论表 comment</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>user_id</td>
<td>int</td>
<td>评论的用户 id，创建索引</td>
</tr>
<tr>
<td>entity_id</td>
<td>int</td>
<td>评论实体 id（给哪个帖子或哪个评论发表评论），创建索引</td>
</tr>
<tr>
<td>entity_type</td>
<td>int</td>
<td>评论实体类型：1 对帖子评论、2 对评论回复</td>
</tr>
<tr>
<td>target_id</td>
<td>int</td>
<td>评论目标（具体给哪个人评论） id</td>
</tr>
<tr>
<td>content</td>
<td>text</td>
<td>评论内容</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>评论状态：0 有效、1 无效</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>评论发表时间</td>
</tr>
</tbody></table>
<h4 id="消息表-message"><a href="#消息表-message" class="headerlink" title="消息表 message"></a>消息表 message</h4><table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>int</td>
<td>主键、自增</td>
</tr>
<tr>
<td>from_id</td>
<td>int</td>
<td>发消息的 id，创建索引</td>
</tr>
<tr>
<td>to_id</td>
<td>int</td>
<td>收消息的 id，创建索引</td>
</tr>
<tr>
<td>conversation_id</td>
<td>varchar</td>
<td>会话 id，由通信双方 id 拼接，创建索引</td>
</tr>
<tr>
<td>content</td>
<td>text</td>
<td>消息内容</td>
</tr>
<tr>
<td>status</td>
<td>int</td>
<td>消息状态：0 未读、1 已读、2 删除</td>
</tr>
<tr>
<td>create_time</td>
<td>timestamp</td>
<td>消息发送时间</td>
</tr>
</tbody></table>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ul>
<li>访问注册页面，</li>
<li><ul>
<li>填写好注册账号、密码、邮箱</li>
</ul>
</li>
<li>提交注册数据</li>
<li><ul>
<li>通过表单提交数据。</li>
<li>服务端验证账号是否已存在、邮箱是否已注册。</li>
<li>服务端发送激活邮件。</li>
</ul>
</li>
<li>激活注册账号</li>
<li><ul>
<li>点击邮件中的链接，即可完成注册</li>
</ul>
</li>
</ul>
<p><strong>配置邮箱功能</strong>：</p>
<ul>
<li>在新浪邮箱配置 SMTP 服务，引入 <code>spring-boot-starter-mail</code> 依赖。</li>
<li>在配置文件配置主机（smtp.sina.com）、端口（465）、邮箱、授权码、协议（smtps），设置 smtp.ssl.enable = true。</li>
<li>调用 springboot内置的 <strong>JavaMailSender</strong> 的 API 发送邮件（只需要填写目标邮箱、邮件主题、邮件内容即可发送），激活 url 由用户 id 和用户的激活码拼接而成。点击激活 url 后由 controller 中的方法进行处理（成功/重复/失败），调用 Model 对象的 <code>addAttribute</code> 方法将结果返回前端。</li>
</ul>
<p><strong>注册流程</strong>如下：<br>1，打开注册网页</p>
<p>2，把注册的表单信息发送给服务器（点注册）</p>
<p>3、逻辑判断和发送邮件</p>
<ul>
<li>判断账号、密码、邮箱<strong>是否为空</strong></li>
<li>判断账号和邮箱<strong>是否已经存在</strong>（从数据库查）</li>
<li>如果以上条件都满足的话会在数据库中<strong>初始化用户的信息</strong>，会给密码加随机盐，并用md5对密码加密保存在数据库中，并发送一封注册邮件给用户邮箱（此时status=0，表示未激活）。</li>
<li>用户点击邮箱中的确认链接后（status置为1）即可完成注册。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//激活链接：http://localhost:8080/community/activation/101/code    #101-用户id，#code-激活码 </span></span><br><span class="line">String url = domain+contextPath+<span class="string">&quot;/activation/&quot;</span>+user.getId()+<span class="string">&quot;/&quot;</span>+user.getActivationCode();</span><br><span class="line">激活连接是由用户的id唯一标识的，当点击链接后，status设为<span class="number">1</span>，再点击就失败显示已经激活。</span><br></pre></td></tr></table></figure>



<h3 id="登录和退出登录"><a href="#登录和退出登录" class="headerlink" title="登录和退出登录"></a>登录和退出登录</h3><ul>
<li>访问登录页面</li>
<li><ul>
<li>点击顶部区域内的链接，打开登录页面。</li>
</ul>
</li>
<li>登录</li>
<li><ul>
<li>验证账号、密码、验证码。</li>
<li>成功时，生成登录凭证，发放给客户端cookie。</li>
<li>失败时，跳转回登录页。</li>
</ul>
</li>
<li>退出</li>
<li><ul>
<li>将登录凭证修改为失效状态。</li>
<li>跳转至网站首页</li>
</ul>
</li>
</ul>
<p><strong>生成验证码</strong></p>
<ul>
<li>引入第三方依赖 kaptcha，主要是生成随机的字符串，以及将字符串图片进行模糊化处理，我们可以通过配置文件配置随机的字符串组成、验证码图片尺寸颜色等等。</li>
<li>在登录的 controller 处理验证码，设置页面的响应类型为 png，通过 ImageIO 的 <code>write</code> 方法将图片输出到浏览器。</li>
</ul>
<p>由于访问同一个生成验证码路径，需要在 url 参数加上一个随机数字，保证点击会重新请求获取新图片。</p>
<p><strong>判断验证码正确后，调用业务层处理登录逻辑</strong></p>
<p>首先会判断验证码是否正确，是在控制层中判断的，业务层主要进行账号密码的判断。</p>
<ul>
<li> 在业务层中首先判断账号、密码是否非空，之后判断账号是否存在、用户是否激活、密码是否正确，将错误信息存到 map 集合。</li>
<li>如果全部合法，为用户生成一个包含过期时间的<strong>登录凭证</strong>，将凭证存入 redis 和 map 集合。</li>
</ul>
<blockquote>
<p><strong>登录凭证</strong>：四个字段，登录<strong>用户id</strong>，一个随机字符串唯一标识登录凭证，<strong>登录状态</strong>（0有效和1无效，当我们没有登陆的时候通常不会删掉该用户的凭证，而是判断登录状态），<strong>过期时间</strong>（勾选上记住我时间就长，否则设为30min失效    ， 放入redis中）</p>
</blockquote>
<p><strong>根据返回的 map 是否包含登陆凭证判断登陆状态</strong></p>
<ul>
<li>如果登录成功，<strong>将凭证存入 cookie</strong> ，设置为同样的过期时间，并重定向至首页。</li>
<li>如果登陆失败，将 map 中的错误信息添加到 Model 对象，返回登录页。</li>
</ul>
<p><strong>退出登录只需要将登录凭证的状态设为1，表示登录处于失效状态</strong></p>
<p><strong>分布式系统session一致性问题</strong></p>
<p>由于Http是无状态的，每次的http请求之间信息不共享，为了保证用户每次请求不用重新输入账号密码，保存用户的登录状态，就会有session和cookie这样的机制，去保存用户登录信息，但是在分布式部署的时候就会存在session共享的一个问题。</p>
<p>由于现在网站基本是多台服务器分布式部署的，如果将用户信息存到session中，而session是存到服务器上，在分布式环境下，由于各个服务器主机之间的信息并不共享，将用户信息存到服务器1上，同一个用户的下一个请求过来的时候，由于nginx的负载均衡策略，去请求了服务器2，就找不到之前的session了。下面介绍几种分布式Session问题的解决策略。<img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211118224450584.png" alt="image-20211118224450584"></p>
<p>粘性session：同一个ip分给同一个服务器，很难做负载均衡</p>
<p>同步Session：当一个服务器创建了session之后，会将该Session同步给其他<br>服务器。服务器之间耦合，加大服务器之间的同步开销</p>
<p>Session服务器：专门一个服务器管理Session，这台服务器是单体的，万一挂掉，有安全隐患</p>
<p>将客户端会话数据不存到Session中而是存到数据库中：<br>关系型数据库性能较慢<br>存到redis中（项目中采用的方式）<img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211118224506990.png" alt="image-20211118224506990"></p>
<hr>
<p>第一版： <strong>将用户登录凭证ticket存到mysql的login_ticket表中</strong><br>登陆成功的时候生成登录凭证，生成Loginticket往数据库login_ticket存，并且被设置为cookie，下次用户登录的时候会带上这个ticket，ticket是个随机的UUID字符串，有过期的时间expired和有效的状态status。</p>
<p>用login_ticket存储用户的登录信息，每次请求会随着cookie带到服务端，服务端只要与数据库比对携带的ticket，就可以通过表中的used_id字段查到用户的信息。<br>用户退出时将status更改为0即可。</p>
<p>第二版：<strong>使用Redis优化登录模块</strong></p>
<h3 id="使用Redis优化登录模块"><a href="#使用Redis优化登录模块" class="headerlink" title="使用Redis优化登录模块"></a>使用Redis优化登录模块</h3><ul>
<li>使用Redis存储验证码</li>
<li><ul>
<li>验证码需要频繁的访问与刷新，对性能要求较高。</li>
<li>验证码不需永久保存，通常在很短的时间后就会失效。</li>
<li>分布式部署时，存在Session共享的问题。</li>
</ul>
</li>
<li>使用Redis存储登录凭证</li>
<li><ul>
<li>处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。</li>
</ul>
</li>
<li>使用Redis缓存用户信息</li>
<li><ul>
<li>处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。</li>
</ul>
</li>
</ul>
<p><strong>使用Redis存储验证码</strong></p>
<p>开始我们是把验证码存入session中，每次用户在登录界面上输入验证码时，从session中取验证码，然后再进行比对。</p>
<p>为什么用Redis存储验证码呢？</p>
<p>因为验证码需要频繁的访问与刷新，<strong>对性能要求较高</strong>。验证码不需永久保存，通常<strong>在很短的时间后就会失效。</strong></p>
<p>我们用Redis存储验证码，之后直接从Redis缓存中取，效率更高。</p>
<p>具体：</p>
<p>生成验证码的时候用户还未登录，此时随机生成一个kpatchowner字段标明当前用户，并存到cookie中，同时将kaptchowner字符串最为redis的key，具体的验证码的值作为redis的value。</p>
<p>用户进行登录验证的时候，先从cookie中取出kpatchowner字段，得到唯一标明属于此用户验证码的rediskey，再从redis中取出验证码真正的文本，然后与用户的输入进行比对，判断你验证码是否正确。</p>
<p><strong>使用Redis存储登录凭证</strong>（判断用户是否登陆，有的功能只有用户登录了才能使用）</p>
<p>当我们登录的时候，会生成一个登录凭证存入mysql中，登录凭证中包含用户的id，以及当前用户的登录状态（0代表登录了，1代表没有登录），并且把登录凭证存入客户端的cookie中。当我们每次发起请求的时候，都要从请求的cookie中取出登录凭证，并与从mysql中查询用户的登录凭证作比对，确认用户的登录状态，登录凭证的访问的频率非常高（原来登录凭证ticket是存到mysql里面，ticket如果用redis存，mysql就可以不用存了，login_ticket可以作废）于是我们选择使用Redis存储登录凭证。</p>
<p><strong>使用Redis缓存用户信息</strong></p>
<p>查询User的时候，先尝试从缓存中取值，缓存中没有的话先从数据库中取然后存到redis中，有些地方会改变用户数据，需要更新缓存，可以直接把该用户的缓存删除，下一次请求的时候发现没有用户的信息，就会重新查一次再放到缓存中</p>
<h3 id="检查登录状态（拦截器的使用）"><a href="#检查登录状态（拦截器的使用）" class="headerlink" title="检查登录状态（拦截器的使用）"></a>检查登录状态（拦截器的使用）</h3><p>如果用户知道我们账号设置的url，那么不用登录也可以直接访问账号其他页面，显然这是不合理的，利用拦截器，<strong>防止用户在未登录情况下通过 url 访问没有权限的页面。</strong></p>
<p>所以我们需要检查用户登录状态。</p>
<p>利用 ThreadLocal 创建 HostHolder 类，包括 <code>set</code>、<code>get</code>、<code>remove</code> 方法，模拟 session 存储用户信息。</p>
<p>通过实现 HandlerInterceptor 接口创建一个拦截器，在 <code>preHandle</code> 方法中通过查询是否有登录凭证的 cookie，如果有则通过登录凭证查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中，在本次请求中持有用户信息。</p>
<p>声明拦截器（实现HandleInterceptor）并在spring @Configuration中配置拦截信息</p>
<ul>
<li>在请求开始时查询登录用户</li>
<li>在本次请求中持有用户数据<br>使用拦截器Interceptor来拦截所有的用户请求，判断请求中的cookie是否存在有效的ticket，如果有的话就将查询用户信息并将用户的信息写入ThreadLocal在本次请求中持有用户，将每个线程的threadLocal都存到一个叫做hostHolder的实例中，根据这个实例就可以在本次请求中全局任意的位置获取用户信息。</li>
</ul>
<p>redis是存储用户登录的状态，是在用户登录之后，跨不同的请求的，而使用ThreadLocal具体针对的是一次请求，在这次请求中去存储用户信息，方便程序的开发，比如说我请求了帖子详情页面，去做评论或者回复，就可以直接从threadLocal中取到用户的信息，进行编码。</p>
<h3 id="发帖、评论、私信"><a href="#发帖、评论、私信" class="headerlink" title="发帖、评论、私信"></a>发帖、评论、私信</h3><p>发帖功能利用了<strong>Ajax技术</strong>，异步加载</p>
<p>ajax指异步的javascript和xml技术。最大的特点是：<strong>不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。</strong></p>
<p>项目中：帖子发布成功/失败的提示(点击发表帖子后弹出的消息提示框)，使用到Ajax</p>
<p><strong>发表帖子</strong>：就是向discuss_post表中插入数据，记录了发帖用户id，标题、内容、类型（置顶或者是精华）、评论数量、发帖时间这些字段</p>
<p><strong>展示帖子</strong>：点击首页的帖子，帖子标题绑定了详情页的链接，跳转到详情页。就是首先查询controller层，接着调用service层中的findDiscussPostById方法查询到这个帖子，再调用Dao层中Mapper方法，到数据库中查找discuss_post这个数据表，里面记录了帖子的详细情况，因为帖子里面还记录了userId，我们便可以得到发帖者的相关信息。</p>
<p><strong>添加评论</strong>：评论的是每一个帖子都评论，并且支持对评论进行评论，也就是评论的回复，<br>能够显示评论的数量，具体的内容，以及评论人回复人等等。</p>
<p>添加评论就是给comment表填充数据，记录了评论的用户、给哪个实体发表了评论（给帖子评论，或者回复帖子），实体类型，给哪个人发表了评论，内容，发表时间。</p>
<p>添加评论时：(将添加评论和更新评论数量放在一个事务中)使用spring声明式事务管理@Transactional实现</p>
<p><strong>私信功能</strong>：</p>
<p><strong>敏感词过滤</strong></p>
<ul>
<li>创建静态内部类 TrieNode ，通过 boolean 结束符判断是否匹配到关键字尾部。</li>
<li>利用 <code>@PostConstruct</code> 注解，在构造方法执行后初始化字典树。</li>
<li>添加 <code>filter</code> 方法，利用双指针进行匹配，过滤敏感词。</li>
</ul>
<hr>
<h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>如何实现点赞功能？</p>
<p>对帖子和评论点赞，第一次点赞，第二次取消点赞，统计帖子和评论的赞总数。</p>
<p>使用redis中的set实现点赞的功能。</p>
<p>点赞操作：（使用了Redis中set这个数据类型，key代表被点赞的实体，value代表谁给我点了赞）</p>
<p>key：<code>like:entity:entityType:entityId  </code> 表示被点赞的实体（给帖子还是评论点赞），帖子或评论的id</p>
<p>value：存的是用户id，为了统计谁给我点了赞</p>
<p><strong>点赞和取消点赞</strong>：先判断是否点过赞，也就是在redis中查找是否存有点赞的记录（也就是set中是否有这个键值对），如果已经有就是取消点赞（把set中对应的值给删掉），否则就是第一次点赞（添加进set中）</p>
<p><strong>统计帖子或评论的点赞数量</strong>：只需要统计redis中这个实体所代表的的set中的value的数量，也就是set的尺寸就可以</p>
<p>被点赞的用户总赞数：</p>
<p>key：<code>like:user:userId</code>表示被点赞的用户</p>
<p>value：自增或自减</p>
<p><strong>在我的主页中统计我收到的赞</strong>：使用redis的事务，在点赞操作后，接着给用户的收到的总赞数加一，反之则减一。</p>
<p><strong>具体实现</strong>：</p>
<p>创建 RedisKeyUtil 工具类，通过实体类型和实体 id 生成对应实体获得赞的 key。</p>
<p>点赞/取消点赞：</p>
<ul>
<li>通过 RedisKeyUtil 获得实体点赞的 key，然后通过 RedisTemplate 的 API 操作，调用集合的 <code>isMember</code> 方法查询 userId 是否存在于对应集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</li>
<li>通过 RedisTemplate 的 <code>execute</code> 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 <code>isMember</code> 方法查询用户的点赞状态，之后通过 <code>mutli</code> 方法开启事务，用 <code>exec </code>方法执行事务。</li>
</ul>
<p>点赞数量：通过调用 set 集合的 <code>size</code> 方法查询元素个数。</p>
<p>点赞状态：通过 set 集合的 <code>isMember</code> 方法实现。</p>
<h3 id="关注和粉丝"><a href="#关注和粉丝" class="headerlink" title="关注和粉丝"></a>关注和粉丝</h3><p><strong>关注和取消关注：</strong></p>
<p>类似于点赞功能，使用redis的zset实现每一个用户的粉丝列表，以及每一个用户的关注列表。</p>
<p>可以用两个sorted set 实现粉丝列表和关注列表。key表示某个用户，value中代表粉丝或者关注者，zset的score存储的是关注时间，可以按照时间展示关注的结果。</p>
<p>同样要实现共同关注功能，只需要对两个用户的关注列表取交集即可。使用 sinter 方法取交集</p>
<p><strong>具体做法</strong>：</p>
<p>在 RedisUnitl 工具类增加两个方法</p>
<ul>
<li>通过用户 id 和实体类型获得用户关注的实体集合的 key。</li>
<li>通过实体类型和实体 id 获得实体拥有的粉丝集合的 key。</li>
</ul>
<p>当用户关注某实体时，</p>
<ul>
<li>将实体 id 和时间作为 value 和 score 加入用户的关注集合。</li>
<li>将用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</li>
</ul>
<p>当用户取消关注某实体时，将实体从用户的关注集合移除，用户从实体的粉丝集合移除。</p>
<p><strong>关注列表和粉丝列表</strong></p>
<ul>
<li>用户的关注列表，通过 zset 的 <code>reverseRange</code> 获取 value 即关注用户的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li>
<li>用户的粉丝列表，通过 zset 的 <code>reverseRange</code> 获取 value 即粉丝的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li>
<li>列表信息封装在 list 集合中，再将 list 添加到 Model 对象里。</li>
</ul>
<hr>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p><strong>为什么要用kafka？</strong></p>
<p>评论，点赞，关注等事件是非常频繁的操作，我们使用kafka消息队列来实现。</p>
<p><strong>哪个地方用到了kafka？</strong></p>
<p>当我们进行点赞，评论，关注请求时，会发送系统通知，告诉用户谁进行了点赞，评论，关注操作。</p>
<p>在处理这些系统通知信息时，使用到了Kafka消息队列。</p>
<p><strong>具体做法</strong>：定义了三类不同的主题，点赞一个主题、评论一个主题、关注一个主题。一旦事件触发了就包装成一个消息放入消息队列对应的主题中，而生产者就可以处理后序的业务，不用管消息是如何被消费的，接着消费者从消息队列中读取消息并存入mysql的message表中。</p>
<p>生产者主动发消息，消费者被动接收消息</p>
<p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211119215925683.png" alt="image-20211119215925683"></p>
<p>具体分为三步：</p>
<ul>
<li><p>封装一个事件，这个事件包括事件的主题（评论、点赞、关注）、事件发起者、事件接受者。</p>
</li>
<li><p>开发生产者</p>
</li>
<li><p>开发消费者</p>
</li>
</ul>
<p><strong>首先会封装一个事件对象，</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String topic;  <span class="comment">//事件主题（评论、点赞、关注）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> userId;   <span class="comment">// 事件发起者（谁评论了，谁点赞了）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> entityType;  <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> entityUserId;  <span class="comment">//事件接受者 （评论了谁，点赞了谁）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,object&gt; data;   <span class="comment">// map用于后序功能的拓展</span></span><br></pre></td></tr></table></figure>



<p><strong>开发事件的生产者</strong><br>向特定的主题（评论，点赞，关注）发送事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//处理事件(发送事件)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">(Event event)</span></span>&#123;</span><br><span class="line">   <span class="comment">//将事件发布到指定的主题</span></span><br><span class="line">   kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p><strong>开发事件的消费者</strong><br>使用@KafkaListener注解监听事件，如果监听成功并进行相应的处理，最后调用messageService添加到数据库中，下次用户显示消息列表的时候就可以看到系统消息了。</p>
<p>我们用的同样是message这个数据表，只不过与发私信中的数据有差别</p>
<img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211119221120618.png" alt="image-20211119221120618" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCommentMessage</span><span class="params">(ConsumerRecord record)</span> </span>&#123;</span><br><span class="line">    Event event = JSONObject.parseObject(record.value().toString(), Event.class);   </span><br><span class="line">   <span class="comment">//发送站内的通知</span></span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">    message.setToId(event.getEntityUserId());</span><br><span class="line">    message.setConversationId(event.getTopic());<span class="comment">//comment like follow</span></span><br><span class="line">    message.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">          </span><br><span class="line">    message.setContent(JSONObject.toJSONString(content));</span><br><span class="line"></span><br><span class="line">    System.out.println(content);</span><br><span class="line">    <span class="comment">//调用messageService添加到数据库中</span></span><br><span class="line">    messageService.addMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>触发事件</strong></p>
<p>创建 EventProducer 事件生产者，新增 <code>fireEvent(Event event)</code> 方法，通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</p>
<p>在 CommentController、LikeControler、FollowController 中注入 EventProducer 实例，分别重构 <code>addComment</code> 方法、<code>like</code> 方法、<code>follow</code> 方法，封装 Event 对象，然后调用 EventProducer 的<code>fireEvent</code> 方法发布通知。。</p>
<p>而消费事件是被动触发的，只要消费者订阅了这三个主题，就会进行相应的操作并计入数据库中。</p>
<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p><strong>es介绍：</strong></p>
<p>Elasticsearch是一个<strong>实时的分布式的搜索引擎</strong>。</p>
<p>Elasticsearch是<strong>面向文档型数据库</strong>，一条数据就是一个文档，和数据结构mongoDB类似，文档序列化之后是JSON格式，例如一条用户数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;tino&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>:<span class="string">&quot;25&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;department&quot;</span>:<span class="string">&quot;DC&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hobies&quot;</span>:[</span><br><span class="line">        <span class="string">&quot;sports&quot;</span>,</span><br><span class="line">        <span class="string">&quot;music&quot;</span>,</span><br><span class="line">        <span class="string">&quot;movie&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于oracle/mysql数据库中的一张user表中的一条记录，这user表有name、age、department、hobies字段，而在Elasticsearch中，这是一个文档，而user则是整个文档的一个类型，Elasticsearch和关系型数据库术语的对照基本上是：</p>
<ul>
<li> Index：Elasticsearch的Index相当于数据库的Table</li>
<li> 类型（Type）类型是索引内部的逻辑分区(category/partition)，一个索引内部可定义一个或多个类型(type)。类比传统的关系型数据库领域来说，类型相当于“表”。</li>
<li> Document：Document相当于数据库的一行记录</li>
<li>Field：相当于数据库的Column的概念</li>
</ul>
<p>Elasticsearch 使用的是标准的 RESTful API 和 JSON，它的交互可以通过HTTP请求，也可以通过java API，如果插入一条记录，可以发送一个HTTP请求来实现：</p>
<p>更新和查询也是类似的操作。</p>
<p><strong>基本特征</strong>：</p>
<ol>
<li>实现了用于全文检索的<strong>倒排索引</strong>，实现了用于存储数值数据和位置数据的 BKD 树， 以及用于分析的列存储。</li>
<li>将每个字段编入索引，使其可搜索，提高搜索速度。</li>
<li>实时分析的分布式引擎，确保故障时仍安全可用。</li>
<li>可以在承载了 PB （2的50次方个字节，约为1000个TB）级数据的成百上千台服务器上运行。</li>
<li>可处理多种数据类型，数字、文本、地理位置、结构化、非结构化。</li>
</ol>
<p>相比mysql优势：在<strong>模糊查询</strong>和<strong>分词查询</strong>上更有优势，在海量数据的查询下用es更有优势</p>
<p>mysql也可以模糊查询，但是要明白的是：<code>name like %Java3y%</code>这类的查询是不走<strong>索引</strong>的，不走索引意味着：只要你的数据库的量很大（1亿条），你的查询肯定会是<strong>秒</strong>级别的。</p>
<p><strong>es倒排索引：</strong></p>
<ul>
<li><strong>正排索引</strong>：是以文档对象的唯一 ID 作为索引，以文档内容作为记录的结构。</li>
<li><strong>倒排索引</strong>：指的是将文档内容中的单词作为索引，将包含该词的文档 ID 作为记录的结构。</li>
</ul>
<p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTYwNjIz,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p><strong>倒排索引的生成过程：</strong></p>
<p>举个例子，假设目前有以下两个文档内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">苏州街维亚大厦 </span><br><span class="line">桔子酒店苏州街店</span><br></pre></td></tr></table></figure>

<p>其处理步骤如下：</p>
<blockquote>
<p>1、正排索引给每个文档进行编号，作为其唯一的标识。</p>
</blockquote>
<table>
<thead>
<tr>
<th>文档 id</th>
<th>content</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>苏州街维亚大厦</td>
</tr>
<tr>
<td>2</td>
<td>桔子酒店苏州街店</td>
</tr>
</tbody></table>
<blockquote>
<p>2、生成倒排索引：</p>
</blockquote>
<ul>
<li>首先要对字段的内容进行分词，分词就是将一段连续的文本按照语义拆分为多个单词，这里两个文档包含的关键词有：苏州街、维亚大厦…</li>
<li>然后按照单词来作为索引，对应的文档 id 建立一个链表，就能构成上述的倒排索引结构。</li>
</ul>
<table>
<thead>
<tr>
<th>Word（term）</th>
<th>文档 id（posting list）出现过这个单词的文档id</th>
</tr>
</thead>
<tbody><tr>
<td>苏州街</td>
<td>1,2</td>
</tr>
<tr>
<td>维亚大厦</td>
<td>1</td>
</tr>
<tr>
<td>维亚</td>
<td>1</td>
</tr>
<tr>
<td>桔子</td>
<td>2</td>
</tr>
<tr>
<td>酒店</td>
<td>2</td>
</tr>
<tr>
<td>大赛</td>
<td>1</td>
</tr>
</tbody></table>
<p>有了倒排索引，能快速、灵活地实现各类搜索需求。整个搜索过程中我们不需要做任何文本的模糊匹配。</p>
<p>例如，如果需要在上述两个文档中查询 <strong>苏州街桔子</strong> ，可以通过分词后 <strong>苏州街</strong> 查到 1、2，通过 <strong>桔子</strong> 查到 2，然后再进行<strong>取交取并</strong>等操作得到最终结果。</p>
<p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211122215841822.png" alt="image-20211122215841822"></p>
<p>搜索服务<br>将帖子保存到Elasticsearch服务器<br>从 Elasticsearch 服务器中删除帖子<br>从 Elasticsearch 服务器搜索帖子<br>发布事件（将发帖或者更改帖子的事件存到kafka中，消费事件并将帖子存到es服务器中）<br>发布帖子时，将帖子异步的提交到Elasticsearch服务器<br>增加评论的时候，将帖子异步的提交到Elasticsearch服务<br>在kafka消费组件中增加一个方法，消费帖子发布事件<br>显示结果<br>在控制器中处理搜索请求，在HTML高亮显示搜索结果</p>
<ul>
<li><p>搜索服务</p>
<ul>
<li>将帖子保存到Elasticsearch服务器</li>
<li>从 Elasticsearch 服务器中删除帖子</li>
<li>从 Elasticsearch 服务器搜索帖子</li>
</ul>
</li>
<li><p>发布事件（将发帖或者更改帖子的事件存到kafka中，消费事件并将帖子存到es服务器中）</p>
<ul>
<li>发布帖子时，将帖子异步的提交到Elasticsearch服务器</li>
<li>增加评论的时候，将帖子异步的提交到Elasticsearch服务</li>
<li>在kafka消费组件中增加一个方法，消费帖子发布事件</li>
</ul>
</li>
<li><p>显示结果</p>
<ul>
<li>在控制器中处理搜索请求，在HTML高亮显示搜索结果</li>
</ul>
</li>
</ul>
<p><strong>哪里用到了es？</strong></p>
<p>在进行帖子搜索时，使用到了ES。可用Repository和Template两种方式，由于Repository搜索到的结果（直接返回的post类，方便）没有高亮标签（why），所以使用了template方式重写了mapResults函数，获得了带有高亮标签的post。<br>使用消息队列（kafka）的方式，实现发帖/删帖后ES数据库的自动更新。<br>搜索：定义SearchQuery，确定搜素内容，排序方式，高亮等。接着使用elasticTemplate.queryForPage方法，需要重写mapResults函数，得到高亮数据。</p>
<h2 id="什么是Spring框架？"><a href="#什么是Spring框架？" class="headerlink" title="什么是Spring框架？"></a>什么是Spring框架？</h2><p>有很多模块组成，利用这些模块可以方便开发工作。这些模块是：核心容器（spring core)/数据访问和集成(Spring JDBC)/Web(Spring Web/MVC)/AOP(Spring Aop)/消息模块/测试模块(Spring Test)等。</p>
<h2 id="对Spring-IoC的理解"><a href="#对Spring-IoC的理解" class="headerlink" title="对Spring IoC的理解"></a>对Spring IoC的理解</h2><p>IoC的意思是控制反转，是一种设计思想，把需要在程序中手动创建对象的控制权交给了Spring框架。IoC的载体是IoC容器，本质是一个工厂，数据结构上来看是一个Map，用来存放着各种对象。当我们创建一个对象时，只需要配置好配置文件/注解，而不用担心对象是怎么被创建出来的。</p>
<p>IoC的优点：降低耦合，对象被容器管理需要两份数据：你的对象定义 + 配置文件，对象间的关系体现在配置文件，不会直接产生耦合。</p>
<h2 id="什么是DAO"><a href="#什么是DAO" class="headerlink" title="什么是DAO"></a>什么是DAO</h2><p>data access object，存放数据库访问对象。</p>
<h2 id="Spring中关于Bean的注解"><a href="#Spring中关于Bean的注解" class="headerlink" title="Spring中关于Bean的注解"></a>Spring中关于Bean的注解</h2><p>四种常见Bean<br>@Controller @Repository @Service @Component一般来说Bean只会被容器初始化一次，@PostConstruct：初始化前调用 @PreDestroy：销毁之前<br>如何使用Bean<br>bean通过容器管理，不需要我们实例化，如果要使用某个bean，使用依赖注入 @Autowired</p>
<h2 id="Spring-MVC是什么，是怎样的工作流程"><a href="#Spring-MVC是什么，是怎样的工作流程" class="headerlink" title="Spring MVC是什么，是怎样的工作流程"></a>Spring MVC是什么，是怎样的工作流程</h2><p>服务器分为表现层/业务层/数据层，其中Spring MVC是工作在表现层，作用是接收/解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。</p>
<p>客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)；<br>DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler；<br>查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理；<br>HandlerAdapter根据Handler来调用真正的Controller；<br>Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View；<br>ViewResolver根据逻辑view找到实际view；<br>DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者。<br>C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。<br>M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。<br>V - View：视图。返回给客户看的结果。</p>
<h2 id="DispatcherServlet处理流程？"><a href="#DispatcherServlet处理流程？" class="headerlink" title="DispatcherServlet处理流程？"></a>DispatcherServlet处理流程？</h2><p>DispatcherServlet 处理流程：<br>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 DispatcherServlet时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：</p>
<p>Tomcat 启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；<br>客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；<br>DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；<br>DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；<br>执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用<br>HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的<br>postHandler() 方法；<br>利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面；<br>最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。</p>
<h2 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h2><p>目的：让未登录用户不能访问某些页面<br>原理：在方法前标注自定义注解，拦截所有的请求，只处理带有该注解的方法。</p>
<h2 id="什么是SSM框架？"><a href="#什么是SSM框架？" class="headerlink" title="什么是SSM框架？"></a>什么是SSM框架？</h2><p>包括Spring + Spring MVC(和Spring天生集成) + MyBatis（帮你和数据库打交道的框架，简单的设置，你就可以像Java一样，操作数据库了）</p>
<h2 id="怎么实现注册功能的？"><a href="#怎么实现注册功能的？" class="headerlink" title="怎么实现注册功能的？"></a>怎么实现注册功能的？</h2><p>根据请求来拆解功能<br>1，打开注册网页<br>2，把注册的信息发送给服务器（点注册）<br>3，把激活邮件发送给邮箱<br>4，利用激活链接打开网页</p>
<p>每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层</p>
<h2 id="什么是Interceptor，在项目的哪里使用到了Interceptor"><a href="#什么是Interceptor，在项目的哪里使用到了Interceptor" class="headerlink" title="什么是Interceptor，在项目的哪里使用到了Interceptor?"></a>什么是Interceptor，在项目的哪里使用到了Interceptor?</h2><p>Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。本项目中，每次请求都会检查request中的login_ticket，把找到的user信息存放在协程中，并在完成处理后，自动释放。（方便的进行用户信息取用）</p>
<h2 id="使用什么技术生成验证码"><a href="#使用什么技术生成验证码" class="headerlink" title="使用什么技术生成验证码?"></a>使用什么技术生成验证码?</h2><p>使用Kaptcha包，可随机生成字符和图片。</p>
<h2 id="如何检查登陆状态"><a href="#如何检查登陆状态" class="headerlink" title="如何检查登陆状态"></a>如何检查登陆状态</h2><p>加拦截器注解。</p>
<h2 id="如何实现敏感词过滤"><a href="#如何实现敏感词过滤" class="headerlink" title="如何实现敏感词过滤"></a>如何实现敏感词过滤</h2><p>使用前缀树（字典树）存储敏感词，对text中的敏感词实现替换。</p>
<h2 id="什么是Ajax，应用在项目哪些地方？"><a href="#什么是Ajax，应用在项目哪些地方？" class="headerlink" title="什么是Ajax，应用在项目哪些地方？"></a>什么是Ajax，应用在项目哪些地方？</h2><p>ajax指异步的json和xml技术，不是一门新的语言，而是使用现有技术的新方法。最大的特点是：不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。<br>项目中：帖子发布成功/失败的提示，使用到ajax</p>
<h2 id="什么是事务，事务的四大特性。"><a href="#什么是事务，事务的四大特性。" class="headerlink" title="什么是事务，事务的四大特性。"></a>什么是事务，事务的四大特性。</h2><p>定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>事物的四大特性-ACID：<br>A：原子性，事务是最小的执行单位，不允许被分割，事务的全部操作要么全部提交成功，要么全部失败回滚。<br>C：一致性，数据库在事务执行前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果相同。<br>I ：隔离性，一个事务所作的修改在最终提交前，对其他事务是不可见的。避免多个事物交叉执行所导致的数据不一致问题。<br>D（Duability）：持久性，一旦事务提交，所做的修改将被永远保存到数据库中。即使系统发生崩溃，事务执行的结构也不能丢失。</p>
<h2 id="怎么利用Spring实现事务管理"><a href="#怎么利用Spring实现事务管理" class="headerlink" title="怎么利用Spring实现事务管理"></a>怎么利用Spring实现事务管理</h2><p>Spring管理事务忽略了底层数据库的结构，非常方便。有两种方式：注解（类型，传播方式）/编程式事务（override)。</p>
<h2 id="是怎样实现统一捕获异常的？"><a href="#是怎样实现统一捕获异常的？" class="headerlink" title="是怎样实现统一捕获异常的？"></a>是怎样实现统一捕获异常的？</h2><p>在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层（controller)统一处理错误即可。<br>方法：在controller中加上advice包，并通过注解@ControllerAdvice和@ExceptionHandler，统一捕获异常。</p>
<h2 id="是怎样实现统一记录日志的？"><a href="#是怎样实现统一记录日志的？" class="headerlink" title="是怎样实现统一记录日志的？"></a>是怎样实现统一记录日志的？</h2><p>如果我们不统一记录日志时，就需要在每个业务执行方法中加上处理日志的功能，那么业务功能就与记录日志功能耦合了，并且要重复很多代码，为了复用代码，我们将每个业务组件中记录日志的功能抽取出来，作为一个aspect，</p>
<p>使用了AOP技术（面向切面编程），这里使用到的是SpringAOP。 AOP技术能够将哪些与业务，但是为业务模块共同调用的逻辑或责任（比如事务处理，日志记录，权限控制等），封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和维护性。 SpringAOP本质上基于动态代理，当要代理的对象实现了某接口，会使用JDK动态代理，在运行时通过创建接口的代理实例，织入代码。当要代理的对象没有实现接口，则使用Cglib技术（编译时增强），通过子类代理织入代码。</p>
<p>前置通知</p>
<p>@Aspect 标记ServiceLogAspect为切面类，切面类中的方法就是业务模块中共同的切入模块。<br>@Pointcut标记service的所有方法，表示将代码<br>@Before表示在所有业务层方法直接执之前记录日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.wsc.community.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用户[1.2.3.4],在[xxx],访问了[com.nowcoder.community.service.xxx()].</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">       <span class="keyword">if</span>(attributes==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        String ip = request.getRemoteHost();</span><br><span class="line">        String now = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        String target = joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;用户[%s],在[%s],访问了[%s].&quot;</span>, ip, now, target));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211119195313765.png" alt="image-20211119195313765" style="zoom:67%;" />



<h2 id="怎么往Spring框架中配置Redis，介绍常见的Redis操作"><a href="#怎么往Spring框架中配置Redis，介绍常见的Redis操作" class="headerlink" title="怎么往Spring框架中配置Redis，介绍常见的Redis操作"></a>怎么往Spring框架中配置Redis，介绍常见的Redis操作</h2><p>我们使用redisTemplate来操作redis。</p>
<p>常见操作<br>string类型：redisTemplate.opsForValue().set(redisKey, 1)，redisTemplate.opsForValue().get(redisKey)， redisTemplate.opsForValue().increment(redisKey)，<br>Hash类型：redisTemplate.opsForHash().put(redisKey, “id”, 1)， 还有get等操作<br>List类型：redisTemplate.opsForList().leftPush(redisKey, 101)， 还有size, index, range， leftPop等操作<br>Set类型：add, size, pop, members等操作<br>Zset类型：redisTemplate.opsForZSet().add(redisKey, “Linda”, 92), 有socre，rank，reverseRank， range等操作<br>操作key：可以delete，以及设置过期时间<br>同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）</p>
<h2 id="项目中Redis的作用"><a href="#项目中Redis的作用" class="headerlink" title="项目中Redis的作用"></a>项目中Redis的作用</h2><p>1、事务操作：redisTemplate直接调用opsfor…来操作redis数据库，每执行一条命令是要重新拿一个连接，因此很耗资源，让一个连接直接执行多条语句的方法就是使用SessionCallback，同样作用的还有RedisCallback，但不常用。<br>2、使用redis存储验证码：</p>
<p>因为验证码需要频繁的进行访问与刷新，因此对性能的要求较高；<br>验证码不需要永久保存，通常在很短的时间后就会失效；<br>分布式部署的时候，存在session共享的问题。<br>3、使用redis存储登录凭证：<br>因为后台在每次处理请求的时候都要查询用户的登录凭证，访问的频率非常高，因此需要使用redis存储。<br>4、使用redis缓存用户信息：<br>因为后台在每次处理请求的时候都要根据用户的凭证用户信息，访问的频率非常高。<br>5、Redis可以使用zset对需要排序的数据进行自定义的排序。</p>
<p>怎样存储的点赞/关注/缓存用户数据<br>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score<br>缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）</p>
<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。消息队列的主要功能（优点）在于：</p>
<p>解耦：生产者只负责把消息放在队列中，而不用关心谁去使用它。<br>异步：生产者把消息放在队列中后即可返回，而不用一个个的通知消费者去执行，消费者是异步的获取消息的。<br>限流：生产者一次性产生大量的数据时，不会给消费者造成压力，消费者可以根据自身的能力，去消息队列中取数据。<br>消息队列作为信息传递的中间件，需要注意哪些问题？<br>1、高可用：因为消息队列如果宕机，会导致整个系统不可用。（分布式/集群的现成支持）<br>2、数据持久化：防止数据丢失<br>3、如何取数据：消息队列主动通知或者消费者轮询。</p>
<p>Java中的blockingqueue，可以提供线程间的消息队列<br>BQ也是生产者与消费者模式，属于点对点式消息队列？（一个消息只会被消费一次）Blocking Queue构建了一个桥梁，能够解决生产速度/消费速度不匹配问题。阻塞的时候只是在那里等着，但是不会占用CPU资源，对性能不会有影响。</p>
<h2 id="什么是Kafka，有哪些功能和应用场景？"><a href="#什么是Kafka，有哪些功能和应用场景？" class="headerlink" title="什么是Kafka，有哪些功能和应用场景？"></a>什么是Kafka，有哪些功能和应用场景？</h2><p>Kafka为分布式流处理平台。流处理是指对不断产生的动态数据流实时处理，基于分布式内存，具有数据处理快速，高效，低延迟的特性。</p>
<p>Kafka简介：Kafka是一种消息队列，主要用来处理大量数据状态下的消息队列，一般用来做日志的处理，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景<br>特点：</p>
<p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。<br>可扩展性：kafka集群支持热扩展<br>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失<br>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）<br>高并发：支持数千个客户端同时读写<br>Kafka主要提供的功能包括：消息系统，日志收集，用户行为跟踪，流式数据处理。</p>
<h2 id="Kafka的基础架构"><a href="#Kafka的基础架构" class="headerlink" title="Kafka的基础架构"></a>Kafka的基础架构</h2><p>Producer：消息生产者，向Kafka中发布消息的角色。<br>Consumer：消息消费者，即从Kafka中拉取消息消费的客户端。<br>Consumer Group：消费者组，消费者组则是一组中存在多个消费者，消费者消费Broker中当前Topic的不同分区中的消息，消费者组之间互不影响，所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。某一个分区中的消息只能够一个消费者组中的一个消费者所消费<br>Broker：经纪人，一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。<br>Topic：主题，可以理解为一个队列，生产者和消费者都是面向一个Topic<br>Partition：分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列(分区有序，不能保证全局有序)<br>Replica：副本Replication，为保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka可以正常的工作，Kafka提供了副本机制，一个Topic的每个分区有若干个副本，一个Leader和多个Follower<br>Leader：每个分区多个副本的主角色，生产者发送数据的对象，以及消费者消费数据的对象都是Leader。<br>Follower：每个分区多个副本的从角色，实时的从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。</p>
<p>Kafka的消息模型，以及常见术语<br>消息模型：发布-订阅模型，消费者订阅了某一主题（topic）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。<br>Topic：主题，类似于文件夹，用来存放不同的数据。<br>Partition：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。<br>Offset：消息在Partition中的存放位置。<br>Broker：可以理解为kafka集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着topic1的leader， topic2的follower等等。</p>
<h2 id="在项目哪里用到了Kafka？"><a href="#在项目哪里用到了Kafka？" class="headerlink" title="在项目哪里用到了Kafka？"></a>在项目哪里用到了Kafka？</h2><p>当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞/评论/关注功能对应的Controller使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。</p>
<h2 id="什么是ElasticSearch，存储原理，功能，特点"><a href="#什么是ElasticSearch，存储原理，功能，特点" class="headerlink" title="什么是ElasticSearch，存储原理，功能，特点"></a>什么是ElasticSearch，存储原理，功能，特点</h2><p>概念：ES是一个基于lucene构建的，分布式的，RESTful的开源全文搜索引擎。<br>存储原理：数据按照Index – Type – Document – 字段四级存储，其中Index对应数据库，Type对应表，Document为搜索的原子单位，包含一个或多个容器，基于JSON表示。字段是指JSON中的每一项组成，类似于数据库中的行/列。Mapping是文档分析过滤后的结果，根据用户自定义，将某些文字过滤掉，类似于表结构定义DDL？？。同时ES也和分布式数据库一样，支持shard的replication。<br>功能：<br>1、分布式的搜索引擎和数据分析引擎<br>2、全文检索，结构化检索，数据分析。<br>3、对海量数据进行近实时的处理<br>特点：<br>1、可以作为分布式集群处理PB级别的数据，也可单机使用。<br>2、不是特有技术，而是将分布式+全文搜索（lucene) + 数据分析合并在一起。<br>3、操作简单，作为传统数据库的补充，提供了数据库所不具备的很多功能。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>records = load ‘/home/stu2018210945/anime.csv’ as (id:int, name:chararray, genre:chararray, type:chararray, episodes:int, rating:float, members:int);</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">pb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/11/14/仿牛客论坛记录/">http://example.com/2021/11/14/仿牛客论坛记录/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">pb</a>！</span></div></div><div class="post-meta__tag-list"></div><div class="social-share pull-right" data-disabled="google,twitter,facebook,douban,instagram,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/02/07/%E5%AE%9E%E4%B9%A0%E6%84%9F%E5%8F%97and%E6%98%A5%E8%8A%82%E8%A7%81%E9%97%BB/"><i class="fa fa-chevron-left">  </i><span>实习感受and春节见闻</span></a></div><div class="next-post pull-right"><a href="/2021/11/07/kafka%E7%9B%B8%E5%85%B3/"><span>kafka相关</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '52a38b388c08f769c0fe',
  clientSecret: '5428c9a58faaa3488201c1791496427b41deb385',
  repo: 'jiubukaiji.github.io',
  owner: 'jiubukaiji',
  admin: 'jiubukaiji',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By pb</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>