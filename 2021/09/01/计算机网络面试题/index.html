<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="计算机网络面试题"><meta name="keywords" content="计算机网络"><meta name="author" content="pb"><meta name="copyright" content="pb"><title>计算机网络面试题 | pb</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="pb" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是网络协议，为什么要对网络协议分层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">计算机网络体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">URI和URL的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">在浏览器中输入url到显示页面的过程中发生了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%EF%BC%88DNS%EF%BC%89-Domain-Name-System"><span class="toc-number">5.</span> <span class="toc-text">域名系统（DNS）  Domain Name System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E6%98%AF%E9%9B%86%E7%BE%A4%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E8%BF%98%E6%98%AF%E5%8D%95%E7%82%B9%E5%BC%8F%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">DNS是集群式的工作方式还是单点式的，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">DNS解析流程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%8A%AB%E6%8C%81%EF%BC%9A"><span class="toc-number">5.3.</span> <span class="toc-text">DNS劫持：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E4%BD%BF%E7%94%A8%E4%BA%86TCP%E8%BF%98%E6%98%AFUDP%E5%91%A2%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">DNS使用了TCP还是UDP呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bping%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">说一下ping的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E3%80%81UDP%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.</span> <span class="toc-text">TCP、UDP介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%886%E4%B8%AA%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">TCP和UDP的区别（6个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%886%E4%B8%AA%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">TCP如何保证传输可靠性（6个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B%E5%92%8C%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">10.1.</span> <span class="toc-text">慢开始和拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="toc-number">10.2.</span> <span class="toc-text">快重传和快恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">11.</span> <span class="toc-text">TCP三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">为什么要有第三次握手呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%A4%B1%E8%B4%A5%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">第三次握手失败了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%BB%91%E5%AE%A2%E5%88%A9%E7%94%A8%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%98%B2%E8%8C%83%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">怎么防范这种攻击？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">12.</span> <span class="toc-text">TCP四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">13.</span> <span class="toc-text">HTTP请求报文和响应报文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%885%E4%B8%AA%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">HTTP和HTTPS的区别（5个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.</span> <span class="toc-text">HTTPS介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">15.1.</span> <span class="toc-text">对称加密和非对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E7%9A%84%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B%EF%BC%88%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">HTTPS的加密过程（对称加密+非对称加密）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">16.</span> <span class="toc-text">常用HTTP状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81HTTP%E6%96%B9%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">常见HTTP方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">GET和POST区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-HTTP-%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3Http%E5%8D%8F%E8%AE%AE%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">19.</span> <span class="toc-text">什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session%EF%BC%8CCookie%E5%92%8CToken%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">Session，Cookie和Token的主要区别</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/111.jpg"></div><div class="author-info__name text-center">pb</div><div class="author-info__description text-center">This is my site</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">96</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pb</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">计算机网络面试题</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/">面试学习系列</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">9.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 28 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>计算机网络之应用层</p>
</blockquote>
<a id="more"></a>

<h2 id="什么是网络协议，为什么要对网络协议分层？"><a href="#什么是网络协议，为什么要对网络协议分层？" class="headerlink" title="什么是网络协议，为什么要对网络协议分层？"></a>什么是网络协议，为什么要对网络协议分层？</h2><p>网络协议是计算机在通信过程中要遵循的一些约定好的规则</p>
<p>计网里面对各种网络协议是分层的。分层的话便于实现和维护，让每层做好自己的任务即可，层与层之间的耦合性低</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>网络体系有三种划分方式：</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20210919161518894.png" alt="计算机网络体系结构"></p>
<p><strong>三个体系的简要介绍：</strong></p>
<p>OSI由于体系比较复杂，而且设<strong>计先于实现</strong>，有许多设计过于理想，<strong>不太方便计算机软件实现</strong>，因而完全实现OSI参考模型的系统不多，应用的范围有限。</p>
<p>TCP/IP协议最早在计算机系统中实现，在Linux、Windows平台中都<strong>有稳定的实现</strong>，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP/IP协议已成为目前互联网事实上的国际标准和工业标准。</p>
<p>五层协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：<strong>物理层、数据链路层、网络层、运输层、应用层。</strong>（最底下两层可以称为网络接口层）</p>
<p>五层协议的体系结构只是为<strong>介绍网络原理而设计</strong>的，实际应用还是TCP/IP四层体系结构。</p>
<p>在互联网使用的各种协中最重要和最著名的就是 <strong>TCP/IP</strong> 两个协议。现在人们经常提到的TCP/IP 并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整<strong>个TCP/IP协议族。</strong></p>
<p><strong>数据在各层之间的传递过程</strong>：</p>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有<strong>下面三层协议（物理层、数据链路层、网络层），</strong>因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<p><strong>每层的大概作用</strong>：</p>
<ul>
<li><strong>应用层</strong>：<strong>应用层直接为用户的应用进程程序提供服务</strong>。这里的进程就是指正在运行的程序。如支持万维网应用的http协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等。</li>
<li><strong>运输层</strong>：<strong>运输层的任务就是负责向两个主机进程之间的通信提供数据传输服务</strong>。由于一个主机可以同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是运输层把收到的信息分别交付给上面应用层中的相应进程。<br>运输层主要使用下面两个协议：<br><strong>传输控制协议TCP</strong>（Transmission Control Protocol）：面向连接的，数据传输的基本单位是报文段，能够提供可靠的交付<br><strong>用户数据报协议UDP</strong>（User Datagram Protocol）：无连接的，数据传输的基本单位是用户数据报，不能保证提供可靠的交付，只能提供尽最大努力交付。</li>
<li><strong>网络层</strong>： <strong>网络层的主要作用是选择合适的网间路由和交换结点，确保数据及时送达。常见的协议有IP协议。</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。</li>
<li><strong>数据链路层</strong>：两个主机之间的数据传输，总是在一段一段的链路上传送的。在两个相邻结点之间传送数据时，<strong>数据链路层将网络层交下来的IP数据报组装成帧</strong>，在两个相邻结点间的链路上<strong>透明地传送帧中的数据</strong>，每一帧包括数据和必要的控制信息。</li>
<li><strong>物理层</strong>：<strong>物理层的主要作用是实现相邻计算机结点之间比特流的透明传输</strong>，并尽量屏蔽掉具体传输介质和物理设备的差异。</li>
</ul>
<p><strong>每层的常用协议：</strong>　</p>
<p>物理层：</p>
<p>数据链路层：ppp协议、CSMA/CD 协议</p>
<p>网络层：IP、ARP（IP-》MAC地址）、ICMP、IGMP、OSPF、RIP、BGP</p>
<p>传输层：TCP（传输控制协议）、UDP（用户数据报协议）</p>
<p>应用层：FTP（文件传输）、SMTP（发送邮件）、HTTP（超文本传输协议）、DNS（域名系统）、Telnet（远程登录）、SNMP（管理与监视网络设备）、POP3（接收邮件）、WWW</p>
<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><ul>
<li>URI（Uniform Resource ldentifier）：中文全称为<strong>统一资源标识符</strong>，主要作用是<strong>唯一标识一个资源</strong>。</li>
<li>URL（Uniform Resource Location）：中文全称为<strong>统一资源定位符</strong>，主要作用是<strong>提供资源的路径。</strong></li>
</ul>
<p>有个经典的比喻是URI像是身份证，可以唯一标识一个人，而URL更像一个住址，可以通过URL找到这个</p>
<h2 id="在浏览器中输入url到显示页面的过程中发生了什么？"><a href="#在浏览器中输入url到显示页面的过程中发生了什么？" class="headerlink" title="在浏览器中输入url到显示页面的过程中发生了什么？"></a>在浏览器中输入url到显示页面的过程中发生了什么？</h2><p>1、通过DNS解析<strong>将域名解析为对应的IP地址</strong> ，寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。  （DNS解析过程）</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;（三次握手具体过程） </p>
<p>3、由浏览器发送一个HTTP请求 ，经过路由器的转发，到达了服务器 </p>
<p>4、服务器处理该HTTP请求，返回一个HTML文件 </p>
<p>5、浏览器解析该HTML文件，并且显示在浏览器端</p>
<h2 id="域名系统（DNS）-Domain-Name-System"><a href="#域名系统（DNS）-Domain-Name-System" class="headerlink" title="域名系统（DNS）  Domain Name System"></a>域名系统（DNS）  Domain Name System</h2><p>DNS的全称是domain name system，即<strong>域名系统</strong>。DNS是一个<strong>存储域名和IP地址映射的分布式数据库</strong>，主要作用是将域名解析成ip地址。人们去访问互联网时，不用去记难记的ip地址，而是只需要记住域名即可。比如大家访问百度，更多地肯定是访问<a target="_blank" rel="noopener" href="http://www.baidu.com,而不是直接输入它的ip地址进行访问,因为ip地址实在太难记了.dns要做的就是将www.baidu.com解析成112.80.248.74/">www.baidu.com，而不是直接输入它的ip地址进行访问，因为IP地址实在太难记了。DNS要做的就是将www.baidu.com解析成112.80.248.74</a>.</p>
<p>DNS 可以使用 <strong>UDP 或者 TCP</strong> 进行传输，使用的<strong>端口号都为 53。</strong>大多数情况下 DNS 使用 <strong>UDP 进行传输</strong>，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 <strong>TCP 进行传输：</strong></p>
<p>一篇很详细DNS文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/yipiankongbai/article/details/25031461">https://blog.csdn.net/yipiankongbai/article/details/25031461</a></p>
<h3 id="DNS是集群式的工作方式还是单点式的，为什么？"><a href="#DNS是集群式的工作方式还是单点式的，为什么？" class="headerlink" title="DNS是集群式的工作方式还是单点式的，为什么？"></a><strong>DNS是集群式的工作方式还是单点式的，为什么？</strong></h3><p>答案是<strong>集群式的</strong>，如果只用一个DNS服务器，包含了所有域名和IP地址的映射。这种设计方式很简单，但是缺点显而易见，如果这个唯一的DNS服务器出了故障，那么就全完了，因特网就几乎崩了。为了避免这种情况出现，<strong>DNS系统采用的是分布式的层次数据数据库模式</strong>，还有缓存的机制也能解决这种问题。</p>
<p><strong>单点模式</strong>：所有的请求，都由这一台机器处理，问题很大。</p>
<p>缺点：并发处理能力低；容错率低，一旦服务器故障，项目无法正常运行；</p>
<p><strong>集群模式</strong>：多台服务器集中，实现相同的项目。多台服务器存在可缓解高并发，如果一台服务器发生故障，可以转移到其他服务器。</p>
<p>优点：1.高可用性：单点模式出现错误会导致服务无法访问。高可用性集群使服务中出现错误，会由其他节点代替故障节点，系统环境并没有改变。<br>2.伸缩性：一组服务器，各自分担处理任务，我们只需要将新的服务器加入集群即可，对于客户来讲，服务并没有发生变化。<br>3.负载均衡：程序处理负载在计算机集群中均衡分担处理，并且可以动态分配负载。</p>
<p><strong>服务器集群</strong>就是指将很多服务器集中起来一起进行同一种服务，在客户端看来就像是只有一个服务器。集群可以利用多个计算机进行并行计算从而获得很高的计算速度，当一个机器坏了整个系统还是能正常运行。</p>
<h3 id="DNS解析流程："><a href="#DNS解析流程：" class="headerlink" title="DNS解析流程："></a>DNS解析流程：</h3><p>浏览器缓存 -》操作系统host文件 -》 本地DNS服务器缓存 -》 本地DNS向根域名服务器请求 -》本地DNS向顶级域名服务器请求 -》 本地DNS向权限名服务器请求，权限域名服务器会告知域名对应的IP地址 -》 本地DNS告诉主机IP地址</p>
<p>1、在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com域名,浏览器会检查缓存中有没有这个域名对应的解析过的ip地址,如果缓存中有,就完成解析./">www.baidu.com域名，浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，就完成解析。</a></p>
<p>2、操作系统会先检查自己本地的hosts文件是否有这个域名的映射关系，如果有完成域名解析。</p>
<p>3、如果hosts文件中没有，则查询本地DNS服务器缓存，如果有，则完成地址解析。</p>
<p>4、如果没有，则本地服务器会向根域名服务器发起查询请求。根域名服务器会告诉本地域名服务器去查询哪个顶级域名服务器。<br>5、本地域名服务器向顶级域名服务器发起查询请求，顶级域名服务器会告诉本地域名服务器去查找哪个权限域名服务器，<br>6、本地域名服务器向权限域名服务器发起查询请求，权限域名服务器告诉本地域名服务器<a target="_blank" rel="noopener" href="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。</a><br>7·本地域名服务器告诉主机<a target="_blank" rel="noopener" href="http://www.baidu.com所对应的ip地址./">www.baidu.com所对应的IP地址。</a></p>
<p>注意：第6步中本地DNS获得ip地址后，会记入缓存中，但注意缓存也是有存活时长的，需要定时更新。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20211021115701354.png" alt="image-20211021115701354"></p>
<h3 id="DNS劫持："><a href="#DNS劫持：" class="headerlink" title="DNS劫持："></a><strong>DNS劫持：</strong></h3><p>指通过某些手段取得域名的解析控制权，将此域名指向一个错误的IP地址，相当于访问到的并不是原来的网页。</p>
<p>有的黑客可以入侵电脑修改host文件中的域名解析映射，实现DNS劫持</p>
<h3 id="DNS使用了TCP还是UDP呢？"><a href="#DNS使用了TCP还是UDP呢？" class="headerlink" title="DNS使用了TCP还是UDP呢？"></a>DNS使用了TCP还是UDP呢？</h3><p>在域名解析的时候是使用UDP，在区域传输的时候使用TCP。</p>
<p>DNS的规范规定了2种类型的DNS服务器，一个叫<strong>主DNS服务器</strong>，一个叫<strong>辅助DNS服务器</strong>。而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 </p>
<p>辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。<strong>区域传送将使用TCP而不是UDP</strong></p>
<h2 id="说一下ping的过程"><a href="#说一下ping的过程" class="headerlink" title="说一下ping的过程"></a>说一下ping的过程</h2><p>ping是ICMP（网际控制报文协议）中的一个重要应用，ICMP是<strong>网络层的协议</strong>。ping的作用是<strong>测试两个主机的连通性。</strong><br>ping的工作过程：<br>1、向目的主机发送多个ICMP请求报文<br>2、根据 <strong>目的主机返回回送报文的时间</strong> 和 <strong>成功响应的次数 **估算出 **数据包往返时间 **及 **丢包率</strong>。</p>
<h2 id="TCP、UDP介绍"><a href="#TCP、UDP介绍" class="headerlink" title="TCP、UDP介绍"></a>TCP、UDP介绍</h2><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是<strong>无连接的</strong>，<strong>尽最大可能交付</strong>，<strong>不能保证可靠性</strong>，<strong>没有拥塞控制，面向报文</strong>（对于应用程序传下来的报文不合并也不拆分，<strong>只是添加 UDP 首部</strong>），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是<strong>面向连接的</strong>，<strong>提供可靠交付</strong>，<strong>有流量控制，拥塞控制</strong>，<strong>提供全双工通信</strong>，<strong>面向字节流</strong>（把应用层传下来的报文看成字节流，把一个数据包拆分成若干组进行发送），每一条 TCP 连接只能是<strong>点对点的</strong>（一对一）。</li>
</ul>
<p>对某些<strong>实时性要求比较高</strong>的情况使用UDP，比如即时通信（QQ聊天），实时直播，视频会议，即使出现传输错误也可以容忍；</p>
<p>对<strong>数据准确性要求高，速度可以相对较慢</strong>的情况用TCP。比如: 文件传输、邮件的发送与接收等。</p>
<p>TCP报文分为<strong>TCP首部</strong>和<strong>TCP数据部分</strong>。</p>
<p>TCP首部前20个字节是固定的，后面是可变的选项和填充部分（最长40个字节）</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20211021122647524.png" alt="TCP报文结构"></p>
<p>TCP的头部有：源端口、目的端口、32位的序列号、32位的确认号等等</p>
<h2 id="TCP和UDP的区别（6个）"><a href="#TCP和UDP的区别（6个）" class="headerlink" title="TCP和UDP的区别（6个）"></a>TCP和UDP的区别（6个）</h2><ul>
<li>TCP是面向连接的，UDP是无连接的； </li>
<li>TCP是可靠的，UDP是不可靠的；</li>
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式； </li>
<li>TCP是面向字节流的，UDP是面向报文的； </li>
<li>TCP有流量控制、拥塞控制机制;UDP没有拥塞控制机制。</li>
<li>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>是否面向连接</th>
<th>可靠性</th>
<th>是否点对点</th>
<th>传输形式</th>
<th>应用场景</th>
<th>首部字节</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>面向连接</td>
<td>可靠</td>
<td>点对点</td>
<td>字节流</td>
<td>文件/邮件传输</td>
<td>20~60</td>
</tr>
<tr>
<td>UDP</td>
<td>无连接</td>
<td>不可靠</td>
<td>多种</td>
<td>报文</td>
<td>视频/语音传输</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="TCP如何保证传输可靠性（6个）"><a href="#TCP如何保证传输可靠性（6个）" class="headerlink" title="TCP如何保证传输可靠性（6个）"></a>TCP如何保证传输可靠性（6个）</h2><ul>
<li><p><strong>数据包校验</strong>：在发送算和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丟弃和不确认此报文段。</p>
</li>
<li><p><strong>对失序数据包重排序</strong>：传输层接收网络层传上来的IP数据报，而IP数据报的到达<strong>可能会失序</strong>，<strong>TCP将对失序数据进行重新排序，然后才交给应用层；</strong> </p>
</li>
<li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据； </p>
</li>
<li><p><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能 及时收到一个确认，将重发这个报文段； </p>
</li>
<li><p><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓 冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使 用的流量控制协议是可变大小的滑动窗口协议</p>
</li>
<li><p><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。（详细讲讲拥塞控制）</p>
</li>
</ul>
<h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p>慢开始、拥塞避免、快重传、快恢复</p>
<p>若对网络中某<strong>资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏。这种现象称为<strong>拥塞</strong> (congestion)</p>
<p>出现拥塞的<strong>原因</strong>：∑对资源需求 &gt; 可用资源</p>
<p>拥塞往往会趋于恶化：如果网络出现拥塞，分组将会丢失，此时发送方会继续<strong>重传</strong>，从而导致网络拥塞程度更高。</p>
<p>TCP 主要通过<strong>四个算法</strong>来进行拥塞控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong>。</p>
<p>为了问题简单化，我们假定：</p>
<ul>
<li>数据是<strong>单方向传送</strong>，而另外一个方向只传送确认</li>
<li>接收方总是<strong>有足够大的接收缓存空间</strong>，因此不会发生流量控制；</li>
</ul>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方需要维护一个叫做<strong>拥塞窗口（cwnd）</strong>的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p>
<p>注意<strong>拥塞窗口与发送方窗口的区别</strong>：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口，考虑到接收方的接受能力，发送窗口可能小于拥塞窗口。<strong>发送窗口的上限=Min[rwnd,cwnd].</strong></p>
<p><strong>慢开始：</strong></p>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个<strong>报文段</strong>；当收到确认后，将 cwnd <strong>加倍</strong>，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个<strong>慢开始门限 ssthresh</strong>，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了<strong>网络拥塞</strong>（其根据就是<strong>接收端没有收到确认</strong>），令 ssthresh = cwnd / 2，cwnd = 1，然后重新执行慢开始。</p>
<blockquote>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
</blockquote>
<p><strong>拥塞避免：</strong></p>
<p>拥塞避免算法思路：让拥塞窗口缓慢增长，即每经过一个往返时间就把发送方的<strong>拥塞窗口cwnd加1</strong>，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901155452218.png"></p>
<h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传和快恢复（FRR）能快速恢复丢失的数据包</p>
<p><strong>快重传</strong>：</p>
<p>快重传要求接收方在收到一个<strong>失序</strong>的报文段后就立即发出<strong>重复确认</strong>，发送方只要一连收到<strong>三个重复确认</strong>就应当立即重传对方尚未收到的报文段，不用<strong>重传计时器时间</strong>到期再重传（比如设置60s，如果60s发送端没有收到确认，则重传该数据）。</p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901161422815.png" alt="image-20210901161422815" style="zoom:80%;" />

<p><strong>快恢复</strong>：</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时<strong>直接进入拥塞避免</strong>（cwnd每次加一而不是翻倍）。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901161722077.png" alt="快恢复"></p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。<strong>慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</strong></p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>在介绍三次握手和四次挥手之前，先介绍一下TCP头部的一些常用字段。</p>
<ul>
<li><strong>序列号</strong>：seq，占32位，用来标识从发送端到接收端发送的字节流。</li>
<li><strong>确认号</strong>：ack，占32位，只有ACK标志位为1时，确认序列号字段才有效，ack = seq + 1</li>
<li><strong>标志位</strong>：<ul>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
<li>ACK：确认序号有效。</li>
</ul>
</li>
</ul>
<p>发送端有CLOSED，SYN-SENT，ESTABLISHED三种状态，接收端有CLOSED，LISTEN，SYN-RCVD，ESTABLISHED四种状态。</p>
<p><strong>具体过程：</strong></p>
<ul>
<li>第一次握手，客户端向服务端发起建立连接请求，客户端会随机生成一个起始序列号x，并且客户端向服务端发送的字段中包含还标志位SYN = 1。第一次握手前客户端的状态为CLOSE，第一次握手后客户端的状态为SYN-SENT，此时服务端的状态为LISTEN。</li>
<li>第二次握手，服务端在收到客户端发来的报文后，会随机生成一个服务端的起始序列号y，然后给客户端回复一段报文，其中包括标志位SYN=1，标志位ACK=1，序列号seq=y，确认号ack=x+1。第二次握手前服务端的状态为LISTEN，第二次握手后服务端的状态为SYN-RCVD，此时客户端的状态为SYN-SENT.（其中SYN=1表示要和客户端建立一个连接，ACK=1表示确认序号有效）</li>
<li>第三次握手，客户端收到服务端发来的报文后，还会再向服务端发送报文，其中包含标志位ACK=1，序列号seq=x+1，确认号ack=y+1，第三次握手前客户端的状态为SYN-SENT，第三次握手后客户端和服务端的状态都为ESTABLISHED。建立完毕开始传输数据。</li>
</ul>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20211021150950681.png" alt="三次握手流程"  />

<p>第一次握手序列号是x；</p>
<p>第二次握手序列号y，确认号x+1；</p>
<p>第三次握手序列号x+1，确认号y+1。</p>
<p><strong>待解决</strong>：</p>
<p>序列号、确认号、标志位的作用</p>
<p>ACK=1是怎么来的，为什么，一直都是1吗？</p>
<p>为什么是三次握手不是两次握手？</p>
<h3 id="为什么要有第三次握手呢？"><a href="#为什么要有第三次握手呢？" class="headerlink" title="为什么要有第三次握手呢？"></a><strong>为什么要有第三次握手呢？</strong></h3><blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，从而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，在第二次握手时客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/scuzoutao/article/details/81774100">https://blog.csdn.net/scuzoutao/article/details/81774100</a></p>
<h3 id="第三次握手失败了怎么办？"><a href="#第三次握手失败了怎么办？" class="headerlink" title="第三次握手失败了怎么办？"></a><strong>第三次握手失败了怎么办？</strong></h3><p>当client与server的第三次握手失败了之后，即client发送至server的确认建立连接报文段未能到达server，server在等待client回复ACK的过程中超时了（超过了SYN timeout），<strong>那么server会向client发送一个RTS报文段并进入关闭状态</strong>，即：并不等待client第三次握手的ACK包重传，直接关闭连接请求，这主要是为了<strong>防止SYN泛洪攻击</strong>。</p>
<h3 id="三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？"><a href="#三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？" class="headerlink" title="三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？"></a>三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？</h3><p><strong>SYN泛洪攻击</strong></p>
<p><strong>黑客仿造IP大量的向服务器发送TCP连接请求报文包，而当服务器返回ACK后，该攻击者就不对其进行再确认从而将server的半连接队列占满</strong>（上文所说的未连接队列，即server收到连接请求SYN之后将client加入半连接队列中），<strong>从而使得server拒绝其他正常的连接请求</strong>。即拒绝服务攻击</p>
<p>可不可以这样理解：理解为创造大量的假流量让服务器无法工作，使得真流量无法访问？</p>
<p><strong>DDoS攻击</strong>是Distributed Denial of Service的缩写，即不法黑客组织通过控制服务器等资源，发动对包括国家骨干网络、重要网络设施、政企或个人网站在内的互联网上任一目标的攻击，致使目标服务器断网，最终停止提供服务。</p>
<p>打个比方，两家相互竞争的商铺，一家为了抢生意，雇佣大批人挤在对方商铺，赖着不走，让真正的顾客无法进入，或者和店员东拉西扯，妨碍正常工作，让对手错过真正的顾客，造成损失。DDoS攻击利用的就是这种思路。</p>
<p><strong>SYN泛洪攻击</strong>也是DDos攻击的一种</p>
<h3 id="怎么防范这种攻击？"><a href="#怎么防范这种攻击？" class="headerlink" title="怎么防范这种攻击？"></a>怎么防范这种攻击？</h3><p>对于SYN泛洪攻击的防范，优化主机系统设置是常用的手段。</p>
<ul>
<li><p>如<strong>降低SYN timeout时间</strong>，使得主机尽快释放半连接的占用；</p>
</li>
<li><p>又比如采用SYN cookie设置，如果<strong>短时间内连续收到</strong>某个IP的重复SYN请求，则认为受到了该IP的攻击，<strong>丢弃来自该IP的后续请求报文。</strong></p>
</li>
<li><p>此外合理地采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击。</p>
</li>
</ul>
<blockquote>
<p>SYN timeout时间</p>
<p>客户端程序因为莫名崩溃等原因，收到SYN+ACK报文后不再回以ACK，服务端将如何处置呢？这时服务端会“优雅地”再等等，会不会是发送的包丢失了呢？于是重新发送一遍SYN+ACK，再收不到来自客户端的ACK响应的话，就把这次连接请求丢弃掉。这个过程大约会“优雅地”持续分钟级，这个持续时间被称作SYN timeout时间。</p>
</blockquote>
<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>客户端在四次挥手过程中有ESTABLISHED，FIN-WAIT-1，FIN-WAIT-2，TIME-WAIT，CLOSED等五个状态</p>
<p>服务端有ESTABLISHED，CLOSE-WAIT，LAST-ACK，CLOSED等四种状态。</p>
<p>我们假设客户端首先发起断开连接请求</p>
<ul>
<li>第一次挥手：客户端向服务端发送的数据完成后，向服务端发起释放连接报文，报文包含标志位FIN-1，序列号seq=u。此时客户端只能接收数据，不能向服务端发送数据。</li>
<li>第二次挥手：服务端收到客户端的释放连接报文后，向客户端发送确认报文，包含标志位ACK=1，序列号seq=v，确认号ack=u+1，此时客户端到服务端的连接已经释放掉，客户端不能向服务端发送数据，服务端也不能向客户端发送数据。但服务端到客户端的单向连接还能正常传输数据。？？</li>
<li>第三次挥手：服务端发送完数据后向客户端发出连接释放报文，报文包含标志位FIN=1，标志位ACK=1，序列号seq=w，确认号ack=u+1。</li>
<li>第四次挥手：客户端收到服务端发送的释放连接请求，向服务端发送确认报文，包含标志位ACK=1，序列号seq=u+1，确认号ack=w+1。</li>
</ul>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20211021153013262.png" alt="TCP四次挥手"></p>
<h2 id="HTTP请求报文和响应报文"><a href="#HTTP请求报文和响应报文" class="headerlink" title="HTTP请求报文和响应报文"></a>HTTP请求报文和响应报文</h2><p>请求报文包含三部分：请求行、请求首部字段、请求内容实体</p>
<ul>
<li><strong>请求行</strong>：包含请求方法、URI、HTTP版本信息</li>
<li><strong>请求首部字段</strong></li>
<li><strong>请求内容实体</strong></li>
</ul>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210901204224623.png" alt="请求报文结构"></p>
<p>响应报文包含三部分：状态行、响应首部字段、响应内容实体</p>
<ul>
<li><strong>状态行</strong>：包含HTTP版本、状态码、状态码的原因短语</li>
<li><strong>响应首部字段</strong></li>
<li><strong>响应内容实体</strong></li>
</ul>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210901204401019.png" alt="响应报文结构"></p>
<h2 id="HTTP和HTTPS的区别（5个）"><a href="#HTTP和HTTPS的区别（5个）" class="headerlink" title="HTTP和HTTPS的区别（5个）"></a>HTTP和HTTPS的区别（5个）</h2><p><strong>超文本传输协议</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），属于应用层，端口号80。</p>
<p>HTTP协议主要定义了客户端和服务端之间如何请求和响应。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20211021153816138.png" alt="HTTP和HTTPS的区别"></p>
<h2 id="HTTPS介绍"><a href="#HTTPS介绍" class="headerlink" title="HTTPS介绍"></a>HTTPS介绍</h2><h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>因为<strong>HTTP是明文传输</strong>的，信息在各个节点传输可能会被篡改。所以我们需要加密，有两种加密方式：对称加密和非对称加密。</p>
<p><strong>对称加密</strong>：指加密和解密使用同一把密钥。这种方式运算速度快，但并不安全。常见的对称加密算法有DES（Data Encryption Standard）、AES</p>
<p><strong>如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</strong>然而最大的问题就是<strong>这个密钥怎么让传输的双方知道，同时不让别人知道</strong>。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥可能会被别人劫持到手，就不能保证通信安全了。</p>
<p>所以这时我们就需要非对称加密了。</p>
<p><strong>非对称加密</strong>：指加密和解密使用不同的密钥，一把叫做公钥，一把叫做私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。优点解决了对称加密中存在的问题。缺点是运算速度较慢。常见的非对称加密算法有RSA、DSA。</p>
<h3 id="HTTPS的加密过程（对称加密-非对称加密）"><a href="#HTTPS的加密过程（对称加密-非对称加密）" class="headerlink" title="HTTPS的加密过程（对称加密+非对称加密）"></a>HTTPS的加密过程（对称加密+非对称加密）</h3><p>HTTPS的加密过程是<strong>对称加密和非对称加密相结合。</strong></p>
<p>对称加密虽然快但并不安全，通过非对称加密的公钥对对称加密的密钥加密。。</p>
<p>简单来说：服务端发公钥给客户端，客户端用公钥加密对称密钥发给服务端，服务端用私钥解密得到对称密钥。</p>
<p>这样通信双方都有一把对称密钥了，再进行通信。</p>
<p><strong>主要流程</strong>：</p>
<ul>
<li>服务端生成一对非对称密钥即公钥和私钥，将公钥发给客户端。</li>
<li>客户端生成一对对称密钥，用服务端刚发来的公钥对这个对称密钥加密，加密后发给服务端。</li>
<li>服务端收到后用私钥进行解密，得到客户端发送的对称密钥。</li>
<li>这样，通信双方就都拿到了对称密钥，可以进行通信了。</li>
</ul>
<p><strong>存在问题</strong>：<strong>就是客户端最开始如何判断收到的这个公钥就是来自服务端而不是其他人冒充的</strong>？在服务端发送公钥给客户端的过程中，可能有中间人将这个公钥A替换为自己的公钥B，接着客户端其实是用中间人的公钥B进行加密的，而不是服务端的公钥A，在客户端传送自己的对称密钥给服务端的过程中，中间人便可以获取这个对称密钥，再重新替换为正常的公钥A，服务器端也不会有任何察觉。</p>
<p>这样在双方都不会发现异常的情况下，中间人掉包了服务器传来的公钥，进而得到了对称密钥。</p>
<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTg0Njc3,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><strong>解决方案</strong>：<strong>核心在于确保客户端接收的公钥是属于服务器的，而不是其他人伪造的</strong>，解决这个问题方法是使用<strong>数字证书</strong>(这时候就需要证书上场了，服务端会向一个权威机构（我们称为CA）申请一个证书来证明自己的身份，证书中包含了公钥，到时候将证书发给客户端就可以了，客户端收到证书后既证明了服务端的身份又拿到了公钥，就可以进行下一步操作了。</p>
<p><strong>引申</strong>：<strong>中间人能否修改证书呢？</strong>（证书的工作流程）</p>
<p>证书=明文信息+数字签名   明文信息=服务器个人信息+服务器公钥   明文信息-哈希算法-CA的公钥加密=数字签名</p>
<p>证书包括明文信息和数字签名，明文信息中就是服务器的个人信息和服务器的公钥，数字签名是服务器的明文信息通过Hash算法后再通过权威机构CA的私钥加密而成。</p>
<p>当客户端接收到证书后，会用权威机构提供的公钥对数字签名解密，解密得到的信息再和明文信息比对，看是否一致。若两部分是一样的说明公钥就是来自服务器端的，而没有被中间人篡改。</p>
<p>上述流程存在的一个问题是客户端哪里来的权威机构的公钥，其实，<strong>在很多浏览器开发时，会内置常用权威认证机构的公钥。</strong></p>
<img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-2021102115381576.png" alt="img"  />

<p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20211021153815758.png" alt="img"></p>
<p><strong>完整步骤总结</strong>：</p>
<p>1、服务端将自己的公钥发给认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。<br>2、服务端将证书发给客户端。<br>3、客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。<br>4、客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。<br>5、服务端收到后利用私钥解密信息，获得客户端发来的对称密钥。<br>6、通信双方可用对称密钥来加密解密信息。</p>
<p>1、服务器将携带的公钥向数字证书机构申请证书。</p>
<p>2、数字证书机构用自己的私钥对公钥签名颁发证书，并返回给服务器。</p>
<p>3、服务器将申请携带公钥的证书分发给客服端。</p>
<p>4、客户端验证证书，证书机构通过验证，或者用户接受不受信任的证书(非权威机构颁发的证书)。获取到公钥。<strong>到这一步，在证书保证下服务器拥有私钥，客户端拥有公钥，可进行非对称性加密。</strong></p>
<p>5、使用公钥加密报文发送给服务器，其中携带随机串。<strong>其中的随机串用户传输数据时进行对称加密</strong></p>
<p>6、服务器使用私钥解密。获取报文信息及随机串。</p>
<p>7、解密后服务器发送握手消息给客户端。</p>
<p>8、客户端接受握手消息，握手结束，双方确定加密算法(使用随机串确定的对称性加密)，开始传输。</p>
<p>关键是如何加密的</p>
<p>对称加密、非对称加密、公钥、私钥、证书</p>
<p>为什么不直接用对称加密呢？=》非对称加密=》只非对称加密不行=》证书</p>
<h2 id="常用HTTP状态码"><a href="#常用HTTP状态码" class="headerlink" title="常用HTTP状态码"></a>常用HTTP状态码</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20211021172834805.png" alt="HTTP状态码"></p>
<p>一些常见状态码的含义：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>继续</td>
<td>初始的请求已经接受，请客户端继续发送剩余部分</td>
</tr>
<tr>
<td>200</td>
<td>成功</td>
<td>服务器已成功处理了请求</td>
</tr>
<tr>
<td>301</td>
<td>永久移动</td>
<td>请求的页面已永久跳转到新的url</td>
</tr>
<tr>
<td>302</td>
<td>临时移动</td>
<td>请求的页面已临时跳转到新的url</td>
</tr>
<tr>
<td>401</td>
<td>未授权</td>
<td>请求要求用户进行身份演验证</td>
</tr>
<tr>
<td>403</td>
<td>禁止</td>
<td>服务器拒绝请求</td>
</tr>
<tr>
<td>404</td>
<td>未找到</td>
<td>服务器找不到请求的资源</td>
</tr>
<tr>
<td>405</td>
<td></td>
<td>客户端请求方法不允许</td>
</tr>
<tr>
<td>502</td>
<td>错误网关</td>
<td>服务器作为网关或代理出现错误</td>
</tr>
<tr>
<td>503</td>
<td>服务不可用</td>
<td>服务器目前无法使用</td>
</tr>
</tbody></table>
<h2 id="常见HTTP方法"><a href="#常见HTTP方法" class="headerlink" title="常见HTTP方法"></a>常见HTTP方法</h2><p>为了方便记忆，可以将PUT，DELETE，POST，GET理解为客户端对服务端的增删改查。</p>
<ul>
<li><p>PUT：上传文件，向服务器添加数据，可以看作增</p>
</li>
<li><p>DELETE：删除文件</p>
</li>
<li><p>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</p>
</li>
<li><p>GET：获取资源，查询服务器资源</p>
</li>
</ul>
<h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><ul>
<li><strong>作用</strong><br>GET用于获取资源，POST用于传输实体主体</li>
<li><strong>参数位置</strong><br>GET的参数放在URL中，POST的参数存储在实体主体中，并且GET方法提交的请求的URL中的数据做多是2048字节，POST请求没有大小限制。</li>
<li><strong>安全性</strong><br>GET方法因为参数放在URL中，安全性相对于POST较差一些</li>
<li><strong>幂等性</strong><br>GET方法是具有幂等性的，而POST方法不具有幂等性。这里幂等性指客户端连续发出多次请求，收到的结果都是一样的</li>
</ul>
<h2 id="什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h2><p><strong>概念</strong>：是指每一次的请求都是独立的，并不会记住之前的处理信息。比如客户端第一次向服务器发送请求完成之后，再一次向服务器发送请求，服务器并不知道该客户端是刚才那个。</p>
<p><strong>解决方法</strong>：</p>
<p>使用Cookie和Session技术（引出这两个知识点）</p>
<h2 id="Session，Cookie和Token的主要区别"><a href="#Session，Cookie和Token的主要区别" class="headerlink" title="Session，Cookie和Token的主要区别"></a>Session，Cookie和Token的主要区别</h2><p>为什么要使用Cookie、session技术？</p>
<p>我们知道http链接是无状态链接，每次客户端访问服务端，服务端都不会知道访问者是谁，每次关闭浏览器后又要重新登录。</p>
<p><strong>Cookie</strong> </p>
<p>Cookie是保存在客户端一个小数据块，其中包含了用户信息。当客户端向服务端发起请求，服务端会向客户端浏览器发送一个Cookie，客户端会把Cookie保存起来，当下次客户端再次请求服务端时，会携带上这个Cookie，服务端会通过这个Cookie来确定身份。</p>
<p><strong>Session</strong> </p>
<p>Session是通过Cookie实现的，和Cookie不同的是，Session是存在服务端的。当客户端浏览器第一次访问服务器时，服务器会为浏览器创建一个sessionid，将sessionid放到Cookie中，存在客户端浏览器。当浏览器再次访问服务器时，服务器会取出Cookie中的sessionid，并根据sessionid获取session。</p>
<p>总之：</p>
<ul>
<li>sessionid存在cookie中，放在客户端，用来标识session。</li>
<li>如果Cooike被禁用了，可以通过在URL中传递sessionid。</li>
<li>token类似于sessionid，服务端就不用保存session了，只需要产生token发送给客户端，验证传过来的token即可。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">pb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/01/计算机网络面试题/">http://example.com/2021/09/01/计算机网络面试题/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">pb</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="social-share pull-right" data-disabled="google,twitter,facebook,douban,instagram,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"><i class="fa fa-chevron-left">  </i><span>http相关内容</span></a></div><div class="next-post pull-right"><a href="/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"><span>二叉树的前中后序遍历模板</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '52a38b388c08f769c0fe',
  clientSecret: '5428c9a58faaa3488201c1791496427b41deb385',
  repo: 'jiubukaiji.github.io',
  owner: 'jiubukaiji',
  admin: 'jiubukaiji',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By pb</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>