<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="mysql相关"><meta name="keywords" content="mysql"><meta name="author" content="pb"><meta name="copyright" content="pb"><title>mysql相关 | pb</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="pb" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%885%E4%B8%AA%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E9%87%8C%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">mysql里面的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql-%E9%87%8C%E9%9D%A2%E6%97%B6%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">mysql 里面时间是怎么存储的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%80%8C%E7%94%A8B%E6%A0%91%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">为什么不用平衡二叉树而用B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">为什么使用B+树而不是B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%AB%98%E4%B8%89%E5%B1%82%E8%83%BD%E7%B4%A2%E5%BC%95%E5%8D%83%E4%B8%87%E7%BA%A7%E5%88%AB%EF%BC%8C%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">树高三层能索引千万级别，是怎么计算的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%885%E7%A7%8D%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">索引类型（5种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">7.</span> <span class="toc-text">聚簇索引非聚簇索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="toc-number">8.</span> <span class="toc-text">回表查询和索引覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">9.</span> <span class="toc-text">如何创建索引&#x2F;删除索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">10.</span> <span class="toc-text">什么是最左匹配原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">为什么建议使用自增ID作为主键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F%EF%BC%88%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E4%B8%8D%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%9F%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">什么情况下索引会失效？（什么情况下用不了索引？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F%EF%BC%88%E5%BE%85%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">建索引有哪些注意点？（待解决）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">14.</span> <span class="toc-text">索引的设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%9F%EF%BC%88%E5%BE%85%E8%A7%A3%E5%86%B3%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">如何对索引优化？（待解决）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">什么是数据库的事务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88ACID%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">事务的四大特性是什么？（ACID四大特性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%884%E4%B8%AA%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">数据库的并发一致性问题（4个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%884%E4%B8%AA%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">数据库的隔离级别（4个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">数据库的隔离级别是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">什么是MVCC？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">21.1.</span> <span class="toc-text">MVCC有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">21.2.</span> <span class="toc-text">MVCC实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">数据库的锁与隔离级别的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">23.</span> <span class="toc-text">数据库锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">23.1.</span> <span class="toc-text">表级锁和行级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">23.2.</span> <span class="toc-text">共享锁和排它锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%84%8F%E5%90%91%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">23.3.</span> <span class="toc-text">意向共享锁和意向排它锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A1%8C%E9%94%81"><span class="toc-number">24.</span> <span class="toc-text">InnoDB的三种行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">24.1.</span> <span class="toc-text">什么是幻读？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%A1%8C%E9%94%81%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84"><span class="toc-number">24.2.</span> <span class="toc-text">关于行锁我们要知道的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="toc-number">24.3.</span> <span class="toc-text">记录锁（Record Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-number">24.4.</span> <span class="toc-text">间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="toc-number">24.5.</span> <span class="toc-text">临键锁（Next-Key Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">24.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">什么是数据库的乐观锁和悲观锁，如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">什么是死锁？如何避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">27.</span> <span class="toc-text">大表如何优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%E3%80%81%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93%E3%80%81%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%E3%80%81%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">什么是垂直分表、垂直分库、水平分表、水平分库？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%EF%BC%9F"><span class="toc-number">28.1.</span> <span class="toc-text">为什么要分表分库？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8"><span class="toc-number">28.2.</span> <span class="toc-text">垂直分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="toc-number">28.3.</span> <span class="toc-text">垂直分库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8"><span class="toc-number">28.4.</span> <span class="toc-text">水平分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="toc-number">28.5.</span> <span class="toc-text">水平分库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">29.</span> <span class="toc-text">数据库主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">29.1.</span> <span class="toc-text">什么是主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%89"><span class="toc-number">29.2.</span> <span class="toc-text">为什么要主从复制（主从复制的好处）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">29.3.</span> <span class="toc-text">主从复制的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8Dlog%E6%80%BB%E7%BB%93"><span class="toc-number">30.</span> <span class="toc-text">mysql常见的三种log总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-redo-log"><span class="toc-number">30.0.1.</span> <span class="toc-text">1. redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-undo-log"><span class="toc-number">30.0.2.</span> <span class="toc-text">2. undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-binlog"><span class="toc-number">30.0.3.</span> <span class="toc-text">3. binlog</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/111.jpg"></div><div class="author-info__name text-center">pb</div><div class="author-info__description text-center">This is my site</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">89</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pb</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">mysql相关</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/">面试学习系列</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">11.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 34 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>MySQL是一种开源的关系型数据库，默认端口号是3306</p>
</blockquote>
<a id="more"></a>

<p>未掌握的知识</p>
<p>limit分页  <strong>间隙锁</strong>和MVCC？行级锁和表级锁</p>
<p>索引调优相关。</p>
<p>慢查询</p>
<p>基本语法的使用，写几道代码题</p>
<p><strong>Mysql的默认端口号是3306</strong></p>
<h2 id="MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）"><a href="#MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）" class="headerlink" title="MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）"></a>MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）</h2><p><strong>InnoDB</strong>和<strong>MyISAM</strong>  ，还有一个Memory，但是用到的比较少</p>
<p>从事务、主键、外键、锁、聚簇索引</p>
<p>1、InnoDB支持事务，MyISAM不支持 </p>
<p>2、InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键？），而MyIsam可以没有（没说清楚）</p>
<p>3、InnoDB支持外键，而MyISAM不支持</p>
<p>4、InnoDB支持表级锁、行级锁(默认)，而MyISAM只支持表级锁</p>
<p>5、InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。（修改一下措辞）</p>
<blockquote>
<p><strong>主键：</strong>是唯一标识一条记录，不能有重复的，不允许为空</p>
<p><strong>外键：</strong>是另一表的主键, 外键可以有重复的, 可以是空值，用来和其他表建立联系用的。所以说，如果谈到了外键，一定是至少涉及到两张表。例如下面这两张表：</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018122822629.png" alt="主键和外键" style="zoom:67%;" />
</blockquote>
<p><strong>如何选择（适用场景）：</strong></p>
<p>1、是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p>
<p>2、如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</p>
<p>3、系统奔溃后，MyISAM恢复起来更困难，能否接受；</p>
<p>4、MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</p>
<h2 id="mysql里面的数据类型"><a href="#mysql里面的数据类型" class="headerlink" title="mysql里面的数据类型"></a>mysql里面的数据类型</h2><p>主要分为四种：<strong>整数型、小数、字符串、时间</strong></p>
<p>整数型分别占：1、2、3、4、8个字节</p>
<img src="/images/mysql/image-20210903171114888.png" alt="数据类型"  />

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50891083">https://zhuanlan.zhihu.com/p/50891083</a></p>
<p>decimal 和 float、Double区别？</p>
<p>decimal 定点型、float单精度、double双精度</p>
<p>结论：decimal型比浮点型计算精度要高，推荐使用这个。</p>
<h2 id="mysql-里面时间是怎么存储的"><a href="#mysql-里面时间是怎么存储的" class="headerlink" title="mysql 里面时间是怎么存储的"></a>mysql 里面时间是怎么存储的</h2><p>存储时间的类型：year、date、time、datetime、timestamp</p>
<p><strong>DATE</strong> - 以YYYY-MM-DD格式的日期，在1000-01-01和9999-12-31之间。 例如，1973年12月30日将被存储为1973-12-30。</p>
<p><strong>DATETIME</strong> - 日期和时间组合以YYYY-MM-DD HH:MM:SS格式，在1000-01-01 00:00:00 到9999-12-31 23:59:59之间。例如，1973年12月30日下午3:30，会被存储为1973-12-30 15:30:00。</p>
<p><strong>TIMESTAMP</strong> - 1970年1月1日午夜之间的时间戳，到2037的某个时候。这看起来像前面的DATETIME格式，无需只是数字之间的连字符; 1973年12月30日下午3点30分将被存储为19731230153000(YYYYMMDDHHMMSS)。</p>
<p><strong>TIME</strong> - 存储时间在HH:MM:SS格式。</p>
<p><strong>YEAR(M)</strong> - 以2位或4位数字格式来存储年份。如果长度指定为2(例如YEAR(2))，年份就可以为1970至2069(70〜69)。如果长度指定为4，年份范围是1901-2155，默认长度为4。</p>
<p><img src="/images/mysql/v2-63be71052bbe166d1d1bfdf63a0dc83a_1440w.jpg"></p>
<h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种数据结构,可以帮助我们<strong>快速的进行数据的查找.</strong></p>
<p><strong>优点</strong>：大大加快数据检索的速度。</p>
<p><strong>缺点</strong>：从空间角度考虑，建立索引需要占用磁盘物理空间<br>            从时间角度考虑，创建和维护索引都需要花费时间，例如对数据进行增删改的时候都需要维护索引。</p>
<p>拿字典作比方，字典目录的作用是快速定位某一个汉字，而索引的作用是快速定位所需数据</p>
<p>提出问题：为什么不用二叉搜索树？</p>
<p>创建索引需要两个条件，这就是：我要给谁–以什么实现方式–创建什么类型的索引</p>
<ol>
<li>给谁：就是给那个字段，这里可以是一个字段，也可以是多个字段；</li>
<li>实现方式：就是索引的数据结构，可以是BTREE、HASH；</li>
<li>类型：就是索引的类型，innoDB中一共支持四种索引类型，分别是普通索引、唯一索引、主键索引、全文索引。</li>
</ol>
<p>创建索引的字段：可以是一个字段，也可以是多个字段，在多个字段上使用时需要满足最左匹配原则。</p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>我们可以按这样一个思考方式：</p>
<p>二叉查找树 -》平衡二叉树 -》B树 -》B+树 这样的顺序来讲解。层层介绍为什么最后使用B+树</p>
<p>平衡二叉树是对二叉查找树的优化，使整棵树更加平衡；</p>
<hr>
<p>索引的数据结构主要有B+树和哈希表，默认的InnoDB引擎的索引类型有<strong>B+树索引</strong>和<strong>哈希索引</strong>，默认的索引类型为B+树索引。</p>
<h3 id="为什么不用平衡二叉树而用B树？"><a href="#为什么不用平衡二叉树而用B树？" class="headerlink" title="为什么不用平衡二叉树而用B树？"></a><strong>为什么不用平衡二叉树而用B树？</strong></h3><p>我们先来看一下B树数据结构，每个节点对应磁盘块中的一部分，我们称为页。每个节点包含多条记录，每个记录由一个二元组【key，data】组成，key代表主键值，data代表除主键以外的数据，除此之外，还包含着指向其他节点的指针。</p>
<ul>
<li>非叶子节点：每条记录由主键值key、数据data、指针构成</li>
<li>叶子结点：每条记录由主键值key、数据data构成，没有指针</li>
</ul>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018194626790.png" alt="B树的数据结构"></p>
<p>考虑内存的易失性。我们都会数据库的数据和索引存储在磁盘这种外围设备中。</p>
<p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取次数。</p>
<p>另外，从磁盘中读取数据时，并不是一条条数据来读取的，而是按照磁盘块来读取的，<strong>每个磁盘块对应着B树中的一个节点</strong>，也称为一个页，InnoDB 中页的默认大小是 16KB。每个节点拥有很多的子节点，一般我们称子节点的个数为阶，每个节点存储了很多键值（key）和数据（data）。基于以上特性，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p>
<h3 id="为什么使用B-树而不是B树？"><a href="#为什么使用B-树而不是B树？" class="headerlink" title="为什么使用B+树而不是B树？"></a><strong>为什么使用B+树而不是B树？</strong></h3><p>B+树相当于对B树的进一步优化。B+树的高度一般为2<del>4层，也就是说查找某个键值的行记录时最多需要1</del>3次IO，若树深度为3，只需两次IO，因为根节点的话在内存中读取</p>
<p>1、B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。</p>
<p>之所以这么做是因为在数据库中页的大小是固定的，InnoDB 中页的默认大小是 16KB。</p>
<p>如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。</p>
<p>2、B+树的叶子节点都是连接在一起的，所以范围查找，顺序查找更加方便</p>
<p>3、B+树的性能更加稳定，因为在B+树中，每次查询都是从根节点到叶子节点，而在B树中，要查询的值可能不在叶子节点，在内部节点就已经找到。</p>
<p>那在什么情况适合使用B树呢，因为B树的内部节点也可以存储值，所以可以把一些频繁访问的值放在距离根节点比较近的地方，这样就可以提高查询效率。综上所述，B+树的性能更加适合作为数据库的索引</p>
<h3 id="树高三层能索引千万级别，是怎么计算的？"><a href="#树高三层能索引千万级别，是怎么计算的？" class="headerlink" title="树高三层能索引千万级别，是怎么计算的？"></a>树高三层能索引千万级别，是怎么计算的？</h3><p><img src="/images/mysql%E7%9B%B8%E5%85%B3/1fc0a50ad54a41458a3aa643aef3b46d.png" alt="B+树"></p>
<p>B+树中，每个节点对应磁盘块中的一部分，我们称为页。在InnoDB中，每页大小默认为16KB；并且每个节点含有多个索引。</p>
<p>非叶子节点和叶子结点构成不同：</p>
<ul>
<li><p>非叶子节点：每条记录由索引（也就是主键）和指针构成</p>
</li>
<li><p>叶子结点：每条记录由索引和数据构成</p>
</li>
</ul>
<p>假如：B+Tree的表都存满了。索引的节点的<strong>类型为BigInt，大小为8B，指针为6B</strong>。</p>
<p>最后一层的叶子结点中， <strong>存放的数据data为1k</strong> 大小，那么</p>
<ol>
<li>第一层只有一个根节点，含有的记录条数： <strong>16k / (8B + 6B) = 1170 (条)；</strong>每条记录对应一个节点。</li>
<li>第二层 <strong>最大节点数 = 第一层记录数</strong> 也应为：<strong>1170个；</strong></li>
<li>第三层中每个节点含有的记录数：**16k / 1k = 16 (个)**。</li>
</ol>
<p>则，一张B+Tree的表最多存放 <strong>1170 * 1170 * 16 ≈ 2千万。</strong></p>
<p>所以，通过分析，我们可以得出，B+Tree结构的表可以容纳千万数据量的查询。</p>
<p>而且一般来说，MySQL会把 B+Tree <strong>根节点放在内存中</strong>，那只需要<strong>两次磁盘IO</strong>就行。</p>
<h2 id="索引类型（5种）"><a href="#索引类型（5种）" class="headerlink" title="索引类型（5种）"></a>索引类型（5种）</h2><ul>
<li>主键索引：不能为NULL，一个表只能有一个主键索引，会在建表时自动创建</li>
<li>普通（单值）索引：即一个索引只包含单个列，一个表可以有多个单值索引，可以为NULL</li>
<li>唯一索引：可以为NULL，索引列的值必须唯一的，如果是组合索引，则列值的组合必须唯一。</li>
<li>复合索引：即一个索引包含多个列</li>
<li>全文索引：对文本的内容进行搜索。</li>
</ul>
<h2 id="聚簇索引非聚簇索引"><a href="#聚簇索引非聚簇索引" class="headerlink" title="聚簇索引非聚簇索引"></a>聚簇索引非聚簇索引</h2><p>聚簇索引和非聚簇索引最主要的区别是<strong>数据和索引是否分开存储。</strong></p>
<ul>
<li>聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。</li>
<li>非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。</li>
</ul>
<p><strong>在InnoDB存储引擎中</strong>，默认的索引为B+树索引，利用主键创建的索引为是聚簇索引，在主索引之上创建的索引为辅助索引，也是非聚簇索引。为什么说辅助索引是在主索引之上创建的呢，因为辅助索引中的叶子节点存储的是主键的值。先通过辅助索引查找主键值，再通过主键索引的聚簇方式找到行数据。</p>
<p>举个例子，id是主键，name是非主键。我们查找id时，直接通过主键索引即可查找到所在数据行；当我们查找name时，先通过附注索引查找到对应的主键id，再根据id主键通过聚簇的方式查找得到数据行。（这个步骤叫回表查询）</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211017210606347.png" alt="InnoDB索引过程" style="zoom:67%;" />



<p><strong>在MyISAM存储引擎中</strong>，默认的索引也是B+树索引，但主键索引和辅助索引都是非聚簇索引，只是说主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键，而主键索引和辅助索引的B+树的叶子节点存储的都是一个指向数据行的地址。与InnoDB不同的是辅助索引检索并不是建立在主键索引之上的。</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211017210704977.png" alt="MyISAM索引过程" style="zoom:67%;" />





<p>辅助索引的叶子结点记录的的是主键的值，而不是这条数据的地址信息。</p>
<p>因为增删改会导致地址发生变化</p>
<h2 id="回表查询和索引覆盖"><a href="#回表查询和索引覆盖" class="headerlink" title="回表查询和索引覆盖"></a>回表查询和索引覆盖</h2><p>可以参考一下这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghoster/p/12510691.html">https://www.cnblogs.com/ghoster/p/12510691.html</a></p>
<p><strong>什么是回表查询？</strong></p>
<p>回表查询：就是mysql内部两次查询的过程，即先通过非聚簇索引找到主键值，再通过聚簇索引找到主键值所对应的数据行</p>
<p>回表查询需要两次查询，性能相对于只查询一次聚簇索引的性能要低，我们可以用索引覆盖来解决这个问题</p>
<p>使用explain 查看查询语句的执行情况分析</p>
<p><strong>什么是索引覆盖？</strong></p>
<p>只需要通过索引就可以返回查询所需要的数据，而不需要通过主键再去查询数据。</p>
<p>总之一句话：只需要在一棵索引树上就能获取所需的数据，无需回表，速度更快。</p>
<p>具体的做法就是将要查询的数据作为索引列建立普通索引(可以是单列索引，也可以一个索引语句定义所有要查询的列，即联合索引)，这样的话就可以直接返回索引中的的数据，不需要再通过聚集索引去定位行记录，避免了回表的情况发生。</p>
<p>举个例子。例如有一张表存储着个人信息包括id，name，age等字段。假设聚簇索引是以ID为键值构建的索引，非聚簇索引是以name为键值构建的素引，<code>select id，name from user where name = &#39;zhangsan&#39;</code>；这个查询便不需要进行回表查询。因为通过非聚簇索引已经能全部检索出数据，这就是索引覆盖的情况。</p>
<p><strong>如何实现覆盖索引？</strong></p>
<p><strong>办法：将被查询的字段建立到联合索引中</strong></p>
<p>如果查询语句是这样，<code>select id，name，age from user where name=&quot;zhangsan</code>；则需要进行回表查询，因为通过非聚簇索引不能检索出age的值。</p>
<p>那应该如何解决那呢？只需要将索引覆盖即可，<strong>建立age和name的联合索引</strong>再使用<code>select id，name，age from user where name=&#39;zhangsan&#39;</code>；进行查询即可。</p>
<p>同时通过explain 该语句，可以看到 Extra 字段中有 using index 。</p>
<h2 id="如何创建索引-删除索引"><a href="#如何创建索引-删除索引" class="headerlink" title="如何创建索引/删除索引"></a>如何创建索引/删除索引</h2><p><strong>创建索引：</strong></p>
<ul>
<li>在创建表的时候创建索引，但是这样不能指定索引的名字</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span></span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">CHAR</span>,</span><br><span class="line">	<span class="keyword">KEY</span> (<span class="keyword">name</span>)     //为<span class="keyword">name</span>字段创建一个普通索引，当然主键索引仍然存在</span><br><span class="line">    <span class="keyword">UNIQUE</span> (<span class="keyword">name</span>)  //为<span class="keyword">name</span>字段创建一个唯一索引</span><br><span class="line">    <span class="keyword">KEY</span> (<span class="keyword">id</span>,<span class="keyword">name</span>)  //创建复合索引</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以单独用<strong>CREATE INDEX</strong>或<strong>ALTER TABLE</strong>来为表增加索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name(column_name,column_name)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_name);</span><br></pre></td></tr></table></figure>

<p><strong>删除索引：</strong></p>
<p>可利用<strong>ALTER TABLE</strong>或<strong>DROP INDEX</strong>语句来删除索引。只有一个主键不用指明名字</p>
<ul>
<li><p>删除主键索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除其他索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name</span><br><span class="line">或</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>查看索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>



<h2 id="什么是最左匹配原则"><a href="#什么是最左匹配原则" class="headerlink" title="什么是最左匹配原则"></a>什么是最左匹配原则</h2><p>最左匹配原则：索引从最左边为起点开始连续匹配，遇到范围查询（&lt;，&gt;、between，like）会停止匹配。并且mysql的优化器会自动优化查询顺序。</p>
<p><strong>举一些例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#比方说我们建立了一个联合索引（a,b,c）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span> <span class="keyword">and</span> c =<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c）,用上a,b,c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c）,用上a,b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> b=<span class="number">1</span> <span class="keyword">and</span> a=<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c）,用上a,b（mysql有查询优化器）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span>;     <span class="comment">#这样也可以利用到定义的索引（a,b,c）,用上a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> b=<span class="number">1</span> <span class="keyword">and</span> c=<span class="number">1</span>;     <span class="comment">#这样不可以利用到定义的索引（a,b,c）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> c=<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b&gt;<span class="number">1</span> <span class="keyword">and</span> c =<span class="number">1</span>; <span class="comment">#这样只能用上a、b索引，c索引用不到 （遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。）</span></span><br><span class="line"></span><br><span class="line">若索引是（a,c,b）</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b&gt;<span class="number">1</span> <span class="keyword">and</span> c =<span class="number">1</span>;<span class="comment">#那么a,c,b都能匹配上，mysql优化器会改写顺序</span></span><br></pre></td></tr></table></figure>











<h2 id="为什么建议使用自增ID作为主键？"><a href="#为什么建议使用自增ID作为主键？" class="headerlink" title="为什么建议使用自增ID作为主键？"></a>为什么建议使用自增ID作为主键？</h2><p><strong>InnoDB中是如何将主键作为聚簇索引的？</strong></p>
<p>如果我们定义了主键(PRIMARY KEY)，那么主键就是聚簇索引；</p>
<p>如果没有定义主键，那么第一个不含有NULL值的唯一索引就是聚簇索引；</p>
<p>如果也没有的话，那么InnoDB 会创建一个隐藏的 ROWID 作为聚集索引。ROWID随着行记录的写入而主动递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的。</p>
<p><strong>自增的好处？</strong></p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p>
<p>如果使用非自增主键（如果学号等），由于每次插入主键的值近似于随机，因此每条新数据都要被插到索引页的中间某个位置，因为我们知道B+树的叶子结点近似于链表，这时就不得不移动数据，调整分页，增加了很多开销。</p>
<h2 id="什么情况下索引会失效？（什么情况下用不了索引？）"><a href="#什么情况下索引会失效？（什么情况下用不了索引？）" class="headerlink" title="什么情况下索引会失效？（什么情况下用不了索引？）"></a>什么情况下索引会失效？（什么情况下用不了索引？）</h2><p>如果索引失效了，将会采用全表扫描。有以下几种情况会导致索引失效：</p>
<ul>
<li><p>不符合最左匹配原则</p>
</li>
<li><p>当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效</p>
</li>
<li><p>使用like查询并且以%开头，比如like ‘%abc’会失效</p>
</li>
<li><p>在索引上进行计算会导致索引失效，例如 <code>select*from table_name where a+1=2</code></p>
</li>
<li><p>在索引中使用函数会导致索引失效，例如 <code>select*from table_name where abs(a)=1</code></p>
</li>
<li><p>索引上使用！、-、&lt;&gt;进行判断时会导致索引失效，例如 <code>select*from table_name where a！=1</code></p>
</li>
<li><p>索引上使用is null 判断时会导致索引失效，例如 <code>select*from table_name where a is nul1</code></p>
</li>
</ul>
<h2 id="建索引有哪些注意点？（待解决）"><a href="#建索引有哪些注意点？（待解决）" class="headerlink" title="建索引有哪些注意点？（待解决）"></a>建索引有哪些注意点？（待解决）</h2><h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><ul>
<li><p>尽量满足最左匹配原则</p>
</li>
<li><p>为经常需要排序、分组操作的字段建立索引</p>
<blockquote>
<p>经常需要ORDER BY、GROUP BY、DISTINCT等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p>
</blockquote>
</li>
<li><p>为哪些常作为查询条件的字段建立索引</p>
<blockquote>
<p>比如说Where 子句 中经常使用的字段应该创建索引</p>
</blockquote>
</li>
<li><p>扩展索引</p>
<blockquote>
<p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>
</blockquote>
</li>
<li><p>不要过度索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。</p>
</li>
</ul>
<h2 id="如何对索引优化？（待解决）"><a href="#如何对索引优化？（待解决）" class="headerlink" title="如何对索引优化？（待解决）"></a>如何对索引优化？（待解决）</h2><h2 id="什么是数据库的事务？"><a href="#什么是数据库的事务？" class="headerlink" title="什么是数据库的事务？"></a>什么是数据库的事务？</h2><p>百度百科的解释：数据库事务（transaction）是访问并可能操作各种数据项的一个数据库擦操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务的全部数据库操作组成。</p>
<p><strong>开启事务</strong> start transaction，<strong>提交语句</strong>是commit，<strong>回滚语句</strong>是rollback。</p>
<h2 id="事务的四大特性是什么？（ACID四大特性）"><a href="#事务的四大特性是什么？（ACID四大特性）" class="headerlink" title="事务的四大特性是什么？（ACID四大特性）"></a>事务的四大特性是什么？（ACID四大特性）</h2><ul>
<li>原子性 (atomicity）：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。</li>
<li>一致性 (consistency)：一致性指事务在执行前后状态是一致的。</li>
<li>隔离性 (isolation)：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。</li>
<li>持久性 (durability)：数据一旦提交，其所作的修改将永久地保存到数据库中。</li>
</ul>
<h2 id="数据库的并发一致性问题（4个）"><a href="#数据库的并发一致性问题（4个）" class="headerlink" title="数据库的并发一致性问题（4个）"></a>数据库的并发一致性问题（4个）</h2><p>当多个事务并发执行时，可能会出现以下问题：</p>
<ul>
<li><p><strong>脏读</strong>：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。（A更新未提交-》B读取-》A回滚-》B读取了脏数据）</p>
</li>
<li><p><strong>不可重复读</strong>：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。（A多次读取的过程中B进行了修改，导致前后读取<strong>数据内容</strong>不一致）</p>
</li>
<li><p><strong>幻读</strong>：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。（A多次读取的过程中B进行了添加，导致前后读取的<strong>数据数目</strong>不一致）</p>
</li>
<li><p><strong>丢失修改</strong>：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。（AB对同一个数据修改，B的修改覆盖了A的修改）</p>
</li>
</ul>
<p>不可重复读和幻读看起来比较像，都是读取了另一条已经提交的事务，它们主要的区别是：在不可重复读中，发现数据不一致主要是数据被更新了（内容不一样）。在幻读中，发现数据不一致主要是数据增多或者减少了（数量不一样）。</p>
<h2 id="数据库的隔离级别（4个）"><a href="#数据库的隔离级别（4个）" class="headerlink" title="数据库的隔离级别（4个）"></a>数据库的隔离级别（4个）</h2><p>数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读等问题。</p>
<ul>
<li>读未提交（READ UNCOMMITTED）：一个事务在提交前，它的修改对其他事务也是可见的。</li>
<li>读已提交（READ COMMITTED）：一个事务提交之后，它的修改才能被其他事务看到。可避免 <strong><em>脏读</em></strong> 的发生</li>
<li>可重复读（REPEATABLE READ）：在同一个事务中多次读取到的数据是一致的。可避免 <strong><em>脏读</em></strong> 、**<em>不可重复读**</em> 的发生。</li>
<li>串行化（SERIALIZABLE）：需要加锁实现，会强制事务串行执行。可避免 <strong><em>脏读、不可重复读、幻读</em></strong> 的发生。</li>
</ul>
<p>以上四种隔离级别最高的是 <strong>Serializable</strong> 级别，最低的是 <strong>Read uncommitted</strong> 级别，当然级别越高，执行效率就越低。</p>
<p><strong>MySQL的默认隔离级别是可重复读。</strong></p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211017224521900.png" alt="隔离级别"></p>
<h2 id="数据库的隔离级别是如何实现的？"><a href="#数据库的隔离级别是如何实现的？" class="headerlink" title="数据库的隔离级别是如何实现的？"></a>数据库的隔离级别是如何实现的？</h2><p>事务的隔离机制主要是依靠锁机制和MVCC（多版本并发控制）实现的，提交读和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。</p>
<h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><h3 id="MVCC有什么作用？"><a href="#MVCC有什么作用？" class="headerlink" title="MVCC有什么作用？"></a>MVCC有什么作用？</h3><p>MVCC（multiple version concurrent control）是一种控制并发的方法，主要用来提高数据库的并发性能。</p>
<p>在了解MVCC时应该先了解当前读和快照读。</p>
<ul>
<li>当前读：读取的是数据库的最新版本，并且在读取时要保证其他事务不会修该当前记录，所以会对读取的记录加锁。</li>
<li>快照读：不加铁读取操作即为快照读，使用MVCC来读取快照中的数据，避免加锁带来的性能损耗。</li>
</ul>
<p>可以看到MVCC的作用就是在不加锁的情况下，解决数据库读写冲突问题，并且解决脏读、幻读、不可重复读等问题，但是不能解决丢失修改问题。</p>
<h3 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h3><h2 id="数据库的锁与隔离级别的关系？"><a href="#数据库的锁与隔离级别的关系？" class="headerlink" title="数据库的锁与隔离级别的关系？"></a>数据库的锁与隔离级别的关系？</h2><p>为了解决数据库并发的问题采用了锁机制</p>
<p>加锁实现不同的隔离级别，如下图所示：</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018114214135.png" alt="加锁实现不同的隔离级别"></p>
<h2 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h2><h3 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h3><p><strong>按照锁的粒度可以将MySQL锁分为三种：</strong>表级锁、行级锁、页面锁</p>
<p>InnoDB默认采用行级锁，MyISAM默认采用表级锁。</p>
<ul>
<li><strong>表级锁</strong></li>
</ul>
<p>Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p>
<ul>
<li><strong>行级锁</strong></li>
</ul>
<p>Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>
<p> InnoDB支持的行级锁，包括如下几种。</p>
<ul>
<li>Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</li>
<li>Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</li>
<li>Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</li>
</ul>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018114344753.png" alt="image-20211018114344753"></p>
<p><strong>虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的</strong>：</p>
<ul>
<li>事务更新大表中的大部分数据直接使用表级锁效率更高；</li>
<li>事务比较复杂，使用行级索很可能引起死锁导致回滚。</li>
</ul>
<hr>
<h3 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h3><p><strong>按照是否可读写分为两种</strong>：共享锁和排他锁</p>
<ul>
<li><strong>共享锁</strong>：共享锁又称<strong>读锁</strong>，简写为S锁，一个事务对一个数据对象加了S锁，可以读数据，不能改数据。加锁期间，其他事务只能对这个数据对象加S锁，不能加X锁。</li>
<li><strong>排他锁</strong>：排他锁又称为<strong>写锁</strong>，简写为X锁，一个事务对一个数据对象加了X锁，可以读数据也可以改数据。加锁期间，其他事务不能对这个数据对象加S锁或X锁。</li>
</ul>
<p>兼容情况如下：</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018120648931.png" alt="image-20211018120648931" style="zoom:67%;" />

<hr>
<h3 id="意向共享锁和意向排它锁"><a href="#意向共享锁和意向排它锁" class="headerlink" title="意向共享锁和意向排它锁"></a>意向共享锁和意向排它锁</h3><p><strong>意向共享锁</strong>和<strong>意向排他锁</strong></p>
<p>事务A获取了某一行的排它锁，尚未提交，此时事务B想要获取表锁时，必须要确认表的每一行都不存在排他锁，很明显效率会很低，引入意向锁之后，效率就会大为改善：</p>
<p>1、如果事务A获取了某一行的排它锁，实际此表存在两种锁，<strong>表中某一行的排他锁</strong>和<strong>表上的意向排他锁</strong>。</p>
<p>2、当事务B试图在该表级别上加锁时，则受到表上一个意向锁的阻塞，它在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p>
<ul>
<li><p>意向共享锁：简称IS锁，一个事务打算给数据行加共享锁前必须先获得该表的IS锁。</p>
</li>
<li><p>意向排他锁：简称IX锁，一个事务打算给数据行加排他锁前必须先获得该表的X锁。</p>
</li>
</ul>
<p>用户无法操作意向锁，意向锁是由InnoDB自己维护的。说白了，意向锁是帮助InnoDB提高效率的一种手段。</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211019100954670.png" alt="image-20211019100954670" style="zoom:67%;" />



<p>注意：<strong>意向锁不会与行级的共享 / 排他锁互斥！！！</strong></p>
<p>举个例子：</p>
<p><code>事务 A</code> 先获取了某一行的<strong>排他锁</strong>，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 A</code> 获取了 <code>users</code> 表上的<strong>意向排他锁</strong>。</li>
<li><code>事务 A</code> 获取了 id 为 6 的数据行上的<strong>排他锁</strong>。</li>
</ol>
<p>之后<code>事务 B</code> 想要获取 <code>users</code> 表的<strong>共享锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="keyword">users</span> <span class="keyword">READ</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 B</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li><code>事务 B</code> 对 <code>users</code> 表的加锁请求被阻塞（排斥）。</li>
</ol>
<p>最后<code>事务 C</code> 也想获取 <code>users</code> 表中某一行的<strong>排他锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 C</code> 申请 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li><code>事务 C</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li>因为意向锁之间并不互斥，所以<code>事务 C</code> 获取到了 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终<code>事务 C</code> 成功获取到了该数据行上的<strong>排他锁</strong>。</li>
</ol>
<p><strong>总结：</strong></p>
<ol>
<li>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</li>
<li>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
</ol>
<h2 id="InnoDB的三种行锁"><a href="#InnoDB的三种行锁" class="headerlink" title="InnoDB的三种行锁"></a>InnoDB的三种行锁</h2><p><strong>MVCC不能解决幻读问题，在可重复读隔离级别下，使用MVCC+Next-key Locks可以解决幻读问题。</strong></p>
<h3 id="什么是幻读？"><a href="#什么是幻读？" class="headerlink" title="什么是幻读？"></a>什么是幻读？</h3><p>幻读是在<code>可重复读</code>的事务隔离级别下会出现的一种问题，简单来说，<code>可重复读</code>保证了当前事务不会读取到其他事务已提交的 <code>UPDATE</code>  操作。但同时，也会导致当前事务无法感知到来自其他事务中的 <code>INSERT</code> 或 <code>DELETE</code> 操作，当当前事务通过 update 等操作获取到该种记录行时，就会产生<code>幻读</code>。</p>
<h3 id="关于行锁我们要知道的"><a href="#关于行锁我们要知道的" class="headerlink" title="关于行锁我们要知道的"></a>关于行锁我们要知道的</h3><p>行锁在 InnoDB 中是基于<code>索引</code>实现的，所以一旦某个加锁操作没有使用索引，那么该锁就会退化为<code>表锁</code>。</p>
<h3 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h3><p>顾名思义，记录锁就是为<strong>某行</strong>记录加锁，它<code>封锁该行的索引记录</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>id 为 1 的记录行会被锁住。</p>
<p>需要注意的是：<code>id</code> 列必须为<code>唯一索引列</code>或<code>主键列</code>，否则上述语句加的锁就会变成<code>临键锁</code>。</p>
<p>同时查询语句必须为<code>精准匹配</code>（<code>=</code>），不能为 <code>&gt;</code>、<code>&lt;</code>、<code>like</code>等，否则也会退化成<code>临键锁</code>（感谢评论区 @decodes 提醒）。</p>
<p><strong>其他实现</strong></p>
<p>在通过 <code>主键索引</code> 与 <code>唯一索引</code> 对数据行进行 UPDATE 操作时，也会对该行数据加<code>记录锁</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> age = <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h3><p><strong>间隙锁</strong>基于<code>非唯一索引</code>，它<code>锁定一段范围内的索引记录</code>。<strong>间隙锁</strong>基于下面将会提到的<code>Next-Key Locking</code> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> BETWEN <span class="number">1</span> <span class="keyword">AND</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>即所有在<code>（1，10）</code>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</p>
<p>除了手动加锁外，在执行完某些 SQL 后，InnoDB 也会自动加<strong>间隙锁</strong>，这个我们在下面会提到。</p>
<h3 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h3><p>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<code>非唯一索引列</code>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。需要强调的一点是，<code>InnoDB</code> 中<code>行级锁</code>是基于索引实现的，<strong>临键锁</strong>只与<code>非唯一索引列</code>有关，在<code>唯一索引列</code>（包括<code>主键列</code>）上不存在<strong>临键锁</strong>。</p>
<p>假设有如下表：<br> <strong>MySql</strong>，<strong>InnoDB</strong>，<strong>Repeatable-Read</strong>：table(id PK, age KEY, name)</p>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>Lee</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>Soraka</td>
</tr>
<tr>
<td>5</td>
<td>32</td>
<td>Zed</td>
</tr>
<tr>
<td>7</td>
<td>45</td>
<td>Talon</td>
</tr>
<tr>
<td>该表中 <code>age</code> 列潜在的<code>临键锁</code>有：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(-∞, 10],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(10, 24],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(24, 32],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(32, 45],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(45, +∞],</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在<code>事务 A</code> 中执行如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据非唯一索引列 UPDATE 某条记录</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> <span class="keyword">name</span> = Vladimir <span class="keyword">WHERE</span> age = <span class="number">24</span>;</span><br><span class="line"><span class="comment">-- 或根据非唯一索引列 锁住某条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> age = <span class="number">24</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>不管执行了上述 SQL 中的哪一句，之后如果在<code>事务 B</code> 中执行以下命令，则该命令会被阻塞：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span>(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;Ezreal&#x27;</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>很明显，<code>事务 A</code> 在对 <code>age</code> 为 24 的列进行 UPDATE 操作的同时，也获取了 <code>(24, 32]</code> 这个区间内的临键锁。</p>
<p>不仅如此，在执行以下 SQL 时，也会陷入阻塞等待：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span>(<span class="number">100</span>, <span class="number">30</span>, <span class="string">&#x27;Ezreal&#x27;</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>那最终我们就可以得知，在根据<code>非唯一索引</code> 对记录行进行 <code>UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE</code> 操作时，InnoDB 会获取该记录行的 <code>临键锁</code> ，并同时获取该记录行下一个区间的<code>间隙锁</code>。</p>
<p>即<code>事务 A </code>在执行了上述的 SQL 后，最终被锁住的记录区间为 <code>(10, 32)</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，该类型的每条记录的索引上都存在这种锁，它是一种特殊的<strong>间隙锁</strong>，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<h2 id="什么是数据库的乐观锁和悲观锁，如何实现？"><a href="#什么是数据库的乐观锁和悲观锁，如何实现？" class="headerlink" title="什么是数据库的乐观锁和悲观锁，如何实现？"></a>什么是数据库的乐观锁和悲观锁，如何实现？</h2><p><strong>乐观锁</strong>：系统假设数据的更新在大多数时候是不会产生冲突的，所以数据库只在更新操作提交的时候对数据检测冲突，如果存在冲突，则数据更新失败。</p>
<p>乐观锁实现方式：一般通过版本号和CAS算法实现。</p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。通俗讲就是每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。</p>
<p>悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for updata.</p>
<h2 id="什么是死锁？如何避免？"><a href="#什么是死锁？如何避免？" class="headerlink" title="什么是死锁？如何避免？"></a>什么是死锁？如何避免？</h2><p>死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在MySQL中，MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。<br>在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。</p>
<p><strong>如何避免MySQL发生死锁或锁冲突：</strong></p>
<ul>
<li>如果不同的程序并发存取多个表，尽量以相同的顺序访问表。</li>
<li>在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处理记录。</li>
<li>在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突或者死锁。<br>尽量使用较低的隔离级别</li>
<li>尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会合理选择事务的大小，小事务发生锁冲突的概率更低</li>
<li>尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别，查询时尽量不要显示加锁对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。</li>
</ul>
<h2 id="大表如何优化"><a href="#大表如何优化" class="headerlink" title="大表如何优化"></a>大表如何优化</h2><ul>
<li>限定数据的范围：避免不带任何限制数据范围条件的查询语句。</li>
<li>读写分离：主库负责写，从库负责读。</li>
<li>垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。</li>
<li>水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。</li>
<li>对单表进行优化：对表中的字段、索引、查询SQL进行优化。</li>
<li>添加缓存</li>
</ul>
<h2 id="什么是垂直分表、垂直分库、水平分表、水平分库？"><a href="#什么是垂直分表、垂直分库、水平分表、水平分库？" class="headerlink" title="什么是垂直分表、垂直分库、水平分表、水平分库？"></a>什么是垂直分表、垂直分库、水平分表、水平分库？</h2><h3 id="为什么要分表分库？"><a href="#为什么要分表分库？" class="headerlink" title="为什么要分表分库？"></a><strong>为什么要分表分库？</strong></h3><p>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a><strong>垂直分表</strong></h3><p>垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。一般会将常用的字段放到一个表中，将不常用的字段放到另一个表中。</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018122823123.png" alt="在这里插入图片描述"></p>
<p>垂直分表的优势：</p>
<ul>
<li>避免IO竞争减少锁表的概率。因为大的字段效率更低，第一数据量大，需要的读取时间长。第二，大字段占用的空间更大，单页内存储的行数变少，会使得IO操作增多。</li>
<li>可以更好地提升热门数据的查询效率。</li>
</ul>
<p>通常我们按以下原则进行垂直拆分:</p>
<ol>
<li>把不常用的字段单独放在一张表;</li>
<li>把text，blob等大字段拆分出来放在附表中;</li>
<li>经常组合查询的列放在一张表中;</li>
</ol>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库：按照业务对表进行分类，部署到不同的数据库上面，不同的数据库可以放到不同的服务器上面。</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA2MjMzOQ==,size_16,color_FFFFFF,t_70.png" alt="垂直分库"></p>
<p>垂直分库的优势：</p>
<ul>
<li>降低业务中的耦合，方便对不同的业务进行分级管理。</li>
<li>可以提升10、数据库连接数、解决单机硬件资源的瓶颈问题。</li>
</ul>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><h2 id="数据库主从复制"><a href="#数据库主从复制" class="headerlink" title="数据库主从复制"></a>数据库主从复制</h2><h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为<strong>从数据库</strong>；主数据库一般是准实时的业务数据库</p>
<h3 id="为什么要主从复制（主从复制的好处）"><a href="#为什么要主从复制（主从复制的好处）" class="headerlink" title="为什么要主从复制（主从复制的好处）"></a>为什么要主从复制（主从复制的好处）</h3><ul>
<li>从数据库可以作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</li>
<li>实现服务器负载均衡。比如说在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。将数据的查询请求全部由从服务器执行。可以缩短应用程序的响应时间、提高系统的性能。</li>
<li>提升I/O性能；随着日常生产中业务量越来越大,I/O访问频率越来越高，单机无法满足，此时做多库的存储，有效降低磁盘I/O访问的频率，提高了单个设备的I/O性能。</li>
<li>读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sq将不会造成前台锁，保证了前台速度。</li>
</ul>
<h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><p><img src="/images/mysql%E7%9B%B8%E5%85%B3/70.png" alt="主从复制"></p>
<p>主从复制主要有三个线程：binlog线程，I/O线程，SQL线程。</p>
<p>主从复制主要围绕这三个线程来进行：</p>
<p>1、主库将更新事件的操作记录(update、delete)写到binlog文件中</p>
<p>2、从库连接主库，并且有多少个从库就会创建多少个binlog dump线程。将binlog的内容传输到从库</p>
<p>3、从库创建I/O线程，接收到主库传来的binlog内容后，将其写入到中继日志（Relay log）中。</p>
<p>4、从库创建SQL线程，从Relay log里面读取内容，执行读取到的更新事件，将更新内容写入到从库中</p>
<h2 id="mysql常见的三种log总结"><a href="#mysql常见的三种log总结" class="headerlink" title="mysql常见的三种log总结"></a>mysql常见的三种log总结</h2><p>mysql中常见的三种log，分别是重做日志(redo log)，回滚日志(undo log)，以及二进制日志(binlog)</p>
<h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p>作用：当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据，如果这个时候发生非正常的DB服务重启，那么这些数据还没在内存，并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），也就是会发生数据丢失，所以在重启mysql服务的时候，可以根据redo log进行重做，从而达到事务的持久性<br>内容：物理日志，即记录修改后的数据行<br>什么时候产生：事务开始之后产生redo log<br>什么时候释放：当对应事务的脏页写入到磁盘之后，redo log即可被覆盖<br>什么时候写入磁盘：</p>
<blockquote>
<p>Master Thread每秒一次执行刷新Innodb_log_buffer到重做日志文件<br>每个事务提交时将重做日志刷新到重做日志文件<br>当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到重做日志文件</p>
</blockquote>
<h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2. undo log"></a>2. undo log</h4><p>作用：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读(MVCC)<br>内容：物理日志，修改前的数据行<br>什么时候产生：事务开始之前，将当前版本生成undo log，undo也会产生redo来保证undo log的可靠性<br>什么时候释放：当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间</p>
<h4 id="3-binlog"><a href="#3-binlog" class="headerlink" title="3. binlog"></a>3. binlog</h4><p>作用：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步；用于数据库的基于时间点的还原<br>什么时候产生：事务提交的时候，一次性将事务中的sql语句或者是修改过后的语句按照一定的格式记录到binlog中<br>什么时候释放：由参数expire_logs_days决定<br>与redo log的不同点：</p>
<blockquote>
<p>作用不同：redo log用来保证事务的持久性，binlog则用来复制数据库<br>内容不同：redo log是物理日志，binlog通常是逻辑日志<br>生命周期不同<br>效率不同：基于物理日志的redo log回复数据的效率高于binlog</p>
</blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>bin log 主要用于复制和数据恢复。</li>
<li>redo log 用于恢复在内存更新后，还没来得及刷到磁盘的数据。</li>
<li>undo log 用于实现回滚和多版本控制。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">pb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/03/mysql相关/">http://example.com/2021/09/03/mysql相关/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">pb</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="social-share pull-right" data-disabled="google,twitter,facebook,douban,instagram,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/"><i class="fa fa-chevron-left">  </i><span>两个大数求和</span></a></div><div class="next-post pull-right"><a href="/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"><span>http相关内容</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '52a38b388c08f769c0fe',
  clientSecret: '5428c9a58faaa3488201c1791496427b41deb385',
  repo: 'jiubukaiji.github.io',
  owner: 'jiubukaiji',
  admin: 'jiubukaiji',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By pb</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>