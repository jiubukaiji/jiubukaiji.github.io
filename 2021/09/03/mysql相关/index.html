<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="mysql相关"><meta name="keywords" content="mysql"><meta name="author" content="pb"><meta name="copyright" content="pb"><title>mysql相关 | pb</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="pb" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%885%E4%B8%AA%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E9%87%8C%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">mysql里面的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql-%E9%87%8C%E9%9D%A2%E6%97%B6%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">mysql 里面时间是怎么存储的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E8%80%8C%E7%94%A8B%E6%A0%91%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">为什么不用平衡二叉树而用B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">为什么使用B+树而不是B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E6%AF%94%E8%BE%83"><span class="toc-number">5.3.</span> <span class="toc-text">哈希索引和B+树索引比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%AB%98%E4%B8%89%E5%B1%82%E8%83%BD%E7%B4%A2%E5%BC%95%E5%8D%83%E4%B8%87%E7%BA%A7%E5%88%AB%EF%BC%8C%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">树高三层能索引千万级别，是怎么计算的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%EF%BC%885%E7%A7%8D%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">索引类型（5种）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">7.</span> <span class="toc-text">聚簇索引非聚簇索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96"><span class="toc-number">8.</span> <span class="toc-text">回表查询和索引覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">9.</span> <span class="toc-text">如何创建索引&#x2F;删除索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88%E6%9A%82%E5%AE%9A6%E7%82%B9%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">索引的设计原则（暂定6点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F%EF%BC%88%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8%E4%B8%8D%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%9F%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">什么情况下索引会失效？（什么情况下用不了索引？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">12.</span> <span class="toc-text">什么是最左匹配原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">为什么建议使用自增ID作为主键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">什么是数据库的事务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88ACID%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">事务的四大特性是什么？（ACID四大特性）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%884%E4%B8%AA%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">数据库的并发一致性问题（4个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%884%E4%B8%AA%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">数据库的隔离级别（4个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">数据库的隔离级别是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMVCC%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">什么是MVCC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">20.</span> <span class="toc-text">MVCC实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">20.1.</span> <span class="toc-text">隐藏字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-number">20.2.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadView"><span class="toc-number">20.3.</span> <span class="toc-text">ReadView</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">数据库的锁与隔离级别的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8MySQL%E7%9A%84%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">在MySQL的可重复读级别下，如何解决幻读问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">23.</span> <span class="toc-text">数据库锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">23.1.</span> <span class="toc-text">表级锁和行级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">23.2.</span> <span class="toc-text">共享锁和排它锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%84%8F%E5%90%91%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">23.3.</span> <span class="toc-text">意向共享锁和意向排它锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A1%8C%E9%94%81%EF%BC%88%E8%AE%B0%E5%BD%95%E9%94%81%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%E3%80%81%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%89"><span class="toc-number">24.</span> <span class="toc-text">InnoDB的三种行锁（记录锁、间隙锁、临键锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB%EF%BC%9F"><span class="toc-number">24.1.</span> <span class="toc-text">什么是幻读？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%A1%8C%E9%94%81%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84"><span class="toc-number">24.2.</span> <span class="toc-text">关于行锁我们要知道的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="toc-number">24.3.</span> <span class="toc-text">记录锁（Record Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-number">24.4.</span> <span class="toc-text">间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="toc-number">24.5.</span> <span class="toc-text">临键锁（Next-Key Locks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">24.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">什么是数据库的乐观锁和悲观锁，如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">什么是死锁？如何避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">27.</span> <span class="toc-text">大表如何优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">28.</span> <span class="toc-text">MySQL慢查询是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8%E3%80%81%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93%E3%80%81%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%E3%80%81%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">什么是垂直分表、垂直分库、水平分表、水平分库？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%EF%BC%9F"><span class="toc-number">29.1.</span> <span class="toc-text">为什么要分表分库？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8"><span class="toc-number">29.2.</span> <span class="toc-text">垂直分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8"><span class="toc-number">29.3.</span> <span class="toc-text">水平分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="toc-number">29.4.</span> <span class="toc-text">垂直分库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93"><span class="toc-number">29.5.</span> <span class="toc-text">水平分库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">30.</span> <span class="toc-text">数据库主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">30.1.</span> <span class="toc-text">什么是主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%89"><span class="toc-number">30.2.</span> <span class="toc-text">为什么要主从复制（主从复制的好处）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">30.3.</span> <span class="toc-text">主从复制的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8Dlog%E6%80%BB%E7%BB%93"><span class="toc-number">31.</span> <span class="toc-text">mysql常见的三种log总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-redo-log"><span class="toc-number">31.0.1.</span> <span class="toc-text">1. redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-undo-log"><span class="toc-number">31.0.2.</span> <span class="toc-text">2. undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-binlog"><span class="toc-number">31.0.3.</span> <span class="toc-text">3. binlog</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/111.jpg"></div><div class="author-info__name text-center">pb</div><div class="author-info__description text-center">This is my site</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">97</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pb</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">mysql相关</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-09-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/">面试学习系列</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">14.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 44 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>MySQL是一种开源的关系型数据库，默认端口号是3306</p>
</blockquote>
<a id="more"></a>

<p>有时间可以看一下CSDN中关注的MySQL专栏</p>
<p><strong>Mysql的默认端口号是3306</strong></p>
<h2 id="MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）"><a href="#MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）" class="headerlink" title="MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）"></a>MySQL常用的存储引擎有什么？它们有什么区别？（5个区别）</h2><p><strong>InnoDB</strong>和<strong>MyISAM</strong>  ，还有一个Memory，但是用到的比较少</p>
<p>从事务、主键、外键、锁、聚簇索引</p>
<p>1、InnoDB支持事务，MyISAM不支持 </p>
<p>2、InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键？），而MyIsam可以没有（没说清楚）</p>
<p>3、InnoDB支持外键，而MyISAM不支持</p>
<p>4、InnoDB支持表级锁、行级锁(默认)，而MyISAM只支持表级锁</p>
<p>5、InnoDB是聚簇索引，使用B+Tree作为索引结构，数据是和主键索引放在一起的。通过主键索引效率很高，但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。</p>
<p>MyISAM是非聚簇索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的地址。</p>
<blockquote>
<p><strong>主键：</strong>是唯一标识一条记录，不能有重复的，不允许为空</p>
<p><strong>外键：</strong>对于本张表来说是外键，对另一张表来说是主键, 外键可以有重复的, 可以是空值，用来和其他表建立联系用的。</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018122822629.png" alt="主键和外键" style="zoom:67%;" />
</blockquote>
<p><strong>Memory引擎介绍：</strong></p>
<p><strong>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中</strong>。这些特性与前面的两个很不同。</p>
<p><strong>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率</strong>。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p>
<p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p>
<p><strong>注意</strong>，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，<strong>基于MEMORY的表的生命周期很短，一般是一次性的</strong>。</p>
<p><strong>如何选择（适用场景）：</strong></p>
<p>1、是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p>
<p>2、如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。</p>
<p>3、系统奔溃后，MyISAM恢复起来更困难，能否接受；</p>
<p>4、MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</p>
<h2 id="mysql里面的数据类型"><a href="#mysql里面的数据类型" class="headerlink" title="mysql里面的数据类型"></a>mysql里面的数据类型</h2><p>主要分为四种：<strong>整数型、小数、字符串、时间</strong></p>
<ul>
<li><p>整数：tinyint、smallint、mediumint、int、bigint</p>
</li>
<li><p>小数型：浮点型float、double  定点型decimal</p>
</li>
</ul>
<ul>
<li><p>字符串型：char、varchar、text、enum、blob</p>
</li>
<li><p>时间日期型：year、timestamp、time、date、datetime</p>
</li>
</ul>
<p>整数型分别占：1、2、3、4、8个字节</p>
<p>blob用来存储二进制的大文件，比如图片或者音乐</p>
<p>text用来存储文本</p>
<img src="/images/mysql/image-20210903171114888.png" alt="数据类型"  />

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/50891083">https://zhuanlan.zhihu.com/p/50891083</a></p>
<p>decimal 和 float、Double区别？</p>
<p>decimal 定点型、float单精度、double双精度</p>
<p>结论：decimal型比浮点型计算精度要高，推荐使用这个。</p>
<h2 id="mysql-里面时间是怎么存储的"><a href="#mysql-里面时间是怎么存储的" class="headerlink" title="mysql 里面时间是怎么存储的"></a>mysql 里面时间是怎么存储的</h2><p>存储时间的类型：year、date、time、datetime、timestamp</p>
<p><strong>DATE</strong> - 以YYYY-MM-DD格式的日期，在1000-01-01和9999-12-31之间。 例如，1973年12月30日将被存储为1973-12-30。</p>
<p><strong>DATETIME</strong> - 日期和时间组合以YYYY-MM-DD HH:MM:SS格式，在1000-01-01 00:00:00 到9999-12-31 23:59:59之间。例如，1973年12月30日下午3:30，会被存储为1973-12-30 15:30:00。</p>
<p><strong>TIMESTAMP</strong> - 1970年1月1日午夜之间的时间戳，到2037的某个时候。这看起来像前面的DATETIME格式，无需只是数字之间的连字符; 1973年12月30日下午3点30分将被存储为19731230153000(YYYYMMDDHHMMSS)。</p>
<p><strong>TIME</strong> - 存储时间在HH:MM:SS格式。</p>
<p><strong>YEAR(M)</strong> - 以2位或4位数字格式来存储年份。如果长度指定为2(例如YEAR(2))，年份就可以为1970至2069(70〜69)。如果长度指定为4，年份范围是1901-2155，默认长度为4。</p>
<p><img src="/images/mysql/v2-63be71052bbe166d1d1bfdf63a0dc83a_1440w.jpg"></p>
<h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种数据结构,可以帮助我们<strong>快速的进行数据的查找.</strong></p>
<p><strong>优点</strong>：大大加快数据检索的速度。</p>
<p><strong>缺点</strong>：从空间角度考虑，建立索引需要占用磁盘物理空间<br>            从时间角度考虑，对数据进行增删改的时候都需要维护索引，创建和维护索引都需要花费时间。</p>
<p>拿字典作比方，字典目录的作用是快速定位某一个汉字，而索引的作用是快速定位所需数据</p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>索引的数据结构主要有B+树和哈希表，默认的InnoDB引擎的索引类型有<strong>B+树索引</strong>和<strong>哈希索引</strong>，默认的索引类型为B+树索引。等值查找的时候可以用哈希索引。</p>
<p>我们可以按这样一个思考方式：</p>
<p>二叉查找树 -》平衡二叉树 -》B树 -》B+树 这样的顺序来讲解。层层介绍为什么最后使用B+树</p>
<h3 id="为什么不用平衡二叉树而用B树？"><a href="#为什么不用平衡二叉树而用B树？" class="headerlink" title="为什么不用平衡二叉树而用B树？"></a><strong>为什么不用平衡二叉树而用B树？</strong></h3><p>我们先来看一下B树数据结构，每个节点对应磁盘块中的一部分，我们称为页。每个节点包含多条记录，每个记录由一个二元组【key，data】组成，key代表主键值，data代表除主键以外的数据，除此之外，还包含着指向其他节点的指针。</p>
<ul>
<li>非叶子节点：每条记录由主键值key、数据data、指针构成</li>
<li>叶子结点：每条记录由主键值key、数据data构成，没有指针</li>
</ul>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018194626790.png" alt="B树的数据结构"></p>
<p>考虑内存的易失性。我们会把数据库的数据和索引存储在磁盘中。</p>
<p>但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取次数。</p>
<p>另外，从磁盘中读取数据时，并不是一条条数据来读取的，而是按照磁盘块来读取的，<strong>每个磁盘块对应着B树中的一个节点</strong>，<strong>也称为一个页，InnoDB 中页的默认大小是 16KB</strong>。每个节点存储了很多键（key）和数据（data）。基于以上特性，相对于平衡二叉树来说，B树每层能存储更多的信息，树的高度更低，B 树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p>
<h3 id="为什么使用B-树而不是B树？"><a href="#为什么使用B-树而不是B树？" class="headerlink" title="为什么使用B+树而不是B树？"></a><strong>为什么使用B+树而不是B树？</strong></h3><p>从1.每层存储更多数据，高度更矮 2.便于顺序查找和范围查找 </p>
<p>B+树相当于对B树的进一步优化。B+树的高度一般为2<del>4层，也就是说查找某个键值的行记录时最多需要1</del>3次磁盘IO，若树深度为3，只需两次IO，因为根节点的话在内存中读取</p>
<p><strong>第一点</strong>：B+ 树非叶子节点上是不存储数据的，仅存储键值和指针，而 B 树非叶子节点中不仅存储键值，也会存储数据。又因为数据库中页的大小是固定的，比如InnoDB 中页的默认大小是 16KB。这样的话，每个节点可以存储更多的键值，相应的树的每一层可以存取的节点个数更多，树的层数就会减小，这样一来我们查找数据进行磁盘的 IO 次数会减少，数据查询的效率也会更快。</p>
<p><strong>第二点</strong>：B+树的叶子节点是从小到大连接在一起的，类似于链表，所以范围查找，顺序查找更加方便</p>
<p>那在什么情况适合使用B树呢，因为B树的内部节点也可以存储值，所以可以把一些频繁访问的值放在距离根节点比较近的地方，这样就可以提高查询效率。综上所述，B+树的性能更加适合作为数据库的索引</p>
<h3 id="哈希索引和B-树索引比较"><a href="#哈希索引和B-树索引比较" class="headerlink" title="哈希索引和B+树索引比较"></a>哈希索引和B+树索引比较</h3><p>哈希表的底层是一个数组，通过哈希函数计算键对应的数组位置，如果发生了哈希冲突，采用拉链法将数据连接起来。</p>
<ul>
<li><p>如果是<strong>等值查询</strong>，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p>
</li>
<li><p>如果是<strong>范围查询</strong>，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</p>
</li>
<li><p>同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分<strong>模糊查询</strong>，其实本质上也是范围查询）；</p>
</li>
<li><p>哈希索引也<strong>不支持多列联合索引的最左匹配规则；</strong></p>
</li>
<li><p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的<strong>哈希冲突</strong>问题。</p>
</li>
</ul>
<p>在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。</p>
<h3 id="树高三层能索引千万级别，是怎么计算的？"><a href="#树高三层能索引千万级别，是怎么计算的？" class="headerlink" title="树高三层能索引千万级别，是怎么计算的？"></a>树高三层能索引千万级别，是怎么计算的？</h3><p><img src="/images/mysql%E7%9B%B8%E5%85%B3/1fc0a50ad54a41458a3aa643aef3b46d.png" alt="B+树"></p>
<p>B+树中，每个节点对应磁盘块中的一部分，我们称为页。<strong>在InnoDB中，每页大小默认为16KB</strong>；并且每个节点含有多个索引。</p>
<p>非叶子节点和叶子结点构成不同：</p>
<ul>
<li><p>非叶子节点：每条记录由索引（也就是主键）和指针构成</p>
</li>
<li><p>叶子结点：每条记录由索引和数据构成</p>
</li>
</ul>
<p>假如：B+Tree的表都存满了。索引的节点的<strong>类型为BigInt，大小为8B，指针为6B</strong>。</p>
<p>最后一层的叶子结点中， <strong>存放的数据data为1k</strong> 大小，那么</p>
<ol>
<li>第一层只有一个根节点，含有的记录条数： <strong>16k / (8B + 6B) = 1170 (条)；</strong>每条记录对应一个节点。</li>
<li>第二层 <strong>最大节点数 = 第一层记录数</strong> 也应为：<strong>1170个；</strong></li>
<li>第三层中每个节点含有的记录数：**16k / 1k = 16 (个)**。</li>
</ol>
<p>则，一张B+Tree的表最多存放 <strong>1170 * 1170 * 16 ≈ 2千万。</strong></p>
<p>所以，通过分析，我们可以得出，B+Tree结构的表可以容纳千万数据量的查询。</p>
<p>而且一般来说，MySQL会把 B+Tree <strong>根节点放在内存中</strong>，那只需要<strong>两次磁盘IO</strong>就行。</p>
<h2 id="索引类型（5种）"><a href="#索引类型（5种）" class="headerlink" title="索引类型（5种）"></a>索引类型（5种）</h2><ul>
<li>主键索引：不能为NULL，一个表只能有一个主键索引，会在建表指定。</li>
<li>普通（单值）索引：即一个索引只包含单个列，一个表可以有多个普通索引，可以为NULL</li>
<li>唯一索引：可以为NULL，索引列的值必须唯一的。</li>
<li>复合索引：即一个索引包含多个列</li>
<li>全文索引：对文本的内容进行搜索。</li>
</ul>
<p>补充一个<strong>前缀索引</strong>的解释</p>
<p>前缀索引：当要索引的列字符很长时 ，索引会很大且变慢。我们可以选择<strong>索引开始的部分字符</strong>，这样可以节约索引空间，提高索引效率。我们需要注意的是，尽量让前缀重复值低。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table test add key(name(4));   # 取name字段的前4个字母作为索引</span><br><span class="line">Query OK, 4 rows affected (0.15 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>



<h2 id="聚簇索引非聚簇索引"><a href="#聚簇索引非聚簇索引" class="headerlink" title="聚簇索引非聚簇索引"></a>聚簇索引非聚簇索引</h2><p>聚簇索引和非聚簇索引最主要的区别是<strong>数据和索引是否分开存储。</strong></p>
<ul>
<li>聚簇索引：将数据和索引放到一起存储，索引叶子节点存储了数据行。</li>
<li>非聚簇索引：将数据和索引分开存储，索引叶子节点存储的是指向数据行的地址。</li>
</ul>
<p><strong>在InnoDB存储引擎中</strong>，<strong>默认的索引为B+树索引，利用主键创建的索引是聚簇索引，在主键索引之上创建的索引为辅助索引，也是非聚簇索引。</strong>为什么说辅助索引是在主键索引之上创建的呢，因为辅助索引中的叶子节点存储的是主键的值。先通过辅助索引查找主键值，再通过主键索引的聚簇方式找到行数据。</p>
<p>因此我们通过索引查找数据分为两种：通过主键索引查找数据（走聚簇索引），通过非主键索引查找数据（先走非聚簇索引，再走聚簇索引）</p>
<p>举个例子，id是主键，name是非主键。我们查找id时，直接通过主键索引即可查找到所在数据行；当我们查找name时，先通过辅助索引查找到对应的主键id，再根据主键id通过聚簇索引的方式查找到数据行。（这个步骤叫<strong>回表查询</strong>）</p>
<p><strong>为什么InnoDB辅助索引存的是主键的值，而不是地址呢？</strong></p>
<ul>
<li><p>当对数据库表进行增删改操作时，数据行的地址可能会变化，因而就需要去维护辅助索引的B+树；要是存储的是主键的值，只要主键值不变就不用修改。</p>
</li>
<li><p>存储主键值的话相对地址更加节省存储空间</p>
</li>
</ul>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211017210606347.png" alt="InnoDB索引过程" style="zoom:67%;" />



<p><strong>在MyISAM存储引擎中</strong>，<strong>默认的索引也是B+树索引，但主键索引和辅助索引都是非聚簇索引，主键索引和辅助索引B+树的叶子节点存储的都是一个指向数据行的地址</strong>。而不需要两次查询。</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211017210704977.png" alt="MyISAM索引过程" style="zoom:67%;" />

<h2 id="回表查询和索引覆盖"><a href="#回表查询和索引覆盖" class="headerlink" title="回表查询和索引覆盖"></a>回表查询和索引覆盖</h2><p>可以参考一下这篇文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ghoster/p/12510691.html">https://www.cnblogs.com/ghoster/p/12510691.html</a></p>
<p><strong>什么是回表查询？</strong></p>
<p>回表查询：就是mysql内部两次查询的过程，即先通过非聚簇索引找到主键值，再通过聚簇索引找到主键值所对应的数据行</p>
<p>回表查询需要两次查询，性能相对于只查询一次聚簇索引的性能要低，我们可以用索引覆盖来解决这个问题</p>
<p>使用explain 查看查询语句的执行情况分析</p>
<p><strong>什么是覆盖索引？</strong></p>
<p>覆盖索引并不是说一种索引类型，覆盖索引是一种很常用的优化手段。</p>
<p>在辅助索引上就可以查询到所需要的数据，而不需要通过辅助索引查找到主键后，再通过主键去回表查询得到数据。</p>
<p>总之一句话：只需要在一棵索引树上就能获取所需的数据，无需回表，速度更快。</p>
<p>举个例子。例如有一张表存储着个人信息包括id，name，age等字段。假设聚簇索引是以ID为键值构建的索引，非聚簇索引是以name为键值构建的素引，<code>select id，name from user where name = &#39;zhangsan&#39;</code>；这个查询便不需要进行回表查询。因为通过非聚簇索引已经能全部检索出数据，这就是索引覆盖的情况。</p>
<p><strong>如何实现覆盖索引？</strong></p>
<p><strong>办法：将被查询的字段建立到联合索引中</strong></p>
<p>如果查询语句是这样，<code>select id，name，age from user where name=&quot;zhangsan</code>；则需要进行回表查询，因为通过非聚簇索引不能检索出age的值。</p>
<p>那应该如何解决那呢？只需要将索引覆盖即可，<strong>建立age和name的联合索引</strong>再使用<code>select id，name，age from user where name=&#39;zhangsan&#39;</code>；进行查询即可。</p>
<p>同时通过explain 该语句，可以看到 Extra 字段中有 using index 。</p>
<h2 id="如何创建索引-删除索引"><a href="#如何创建索引-删除索引" class="headerlink" title="如何创建索引/删除索引"></a>如何创建索引/删除索引</h2><p><strong>创建索引：</strong>（分为在建表的时候创建和建完表后再创建）</p>
<ul>
<li>在创建表的时候创建索引，但是这样不能指定索引的名字</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>  //创建主键索引，在字段后面加上primary <span class="keyword">key</span></span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">CHAR</span>,</span><br><span class="line">	<span class="keyword">KEY</span> (<span class="keyword">name</span>)     //为<span class="keyword">name</span>字段创建一个普通索引，当然主键索引仍然存在</span><br><span class="line">    <span class="keyword">UNIQUE</span> (<span class="keyword">name</span>)  //为<span class="keyword">name</span>字段创建一个唯一索引</span><br><span class="line">    <span class="keyword">KEY</span> (<span class="keyword">id</span>,<span class="keyword">name</span>)  //创建复合索引</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以单独用<strong>CREATE INDEX</strong>或<strong>ALTER TABLE</strong>来为表增加索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">creat index index_name ON table_name(column_name,column_name)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name (column_name);</span><br></pre></td></tr></table></figure>

<p><strong>删除索引：</strong></p>
<p>可利用<strong>ALTER TABLE</strong>或<strong>DROP INDEX</strong>语句来删除索引。只有一个主键不用指明名字</p>
<ul>
<li><p>删除主键索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除其他索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">index</span> index_name</span><br><span class="line">或</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>查看表中创建好的索引</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure>



<p><strong>测试索引是否创建成功：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> age = <span class="number">20</span></span><br><span class="line"><span class="comment"># 执行计划</span></span><br></pre></td></tr></table></figure>



<h2 id="索引的设计原则（暂定6点）"><a href="#索引的设计原则（暂定6点）" class="headerlink" title="索引的设计原则（暂定6点）"></a>索引的设计原则（暂定6点）</h2><ul>
<li><p>尽量满足最左匹配原则</p>
</li>
<li><p>为经常需要排序、分组操作的字段建立索引</p>
<blockquote>
<p>经常需要ORDER BY、GROUP BY、DISTINCT等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p>
</blockquote>
</li>
<li><p>为那些常作为查询条件的字段建立索引</p>
<blockquote>
<p>比如说Where 子句 中经常使用的字段应该创建索引</p>
</blockquote>
</li>
<li><p><strong>值会频繁变化的列不适合建索引。</strong>因为索引也有维护成本。</p>
</li>
<li><p>不要建过多的索引，每个索引都需要额外的物理空间，维护也需要花费时间，所以索引不是越多越好。</p>
</li>
<li><p>不要在区分度低的列创建索引，比如性别这样的字段只有两个值，不适合创建索引</p>
</li>
</ul>
<h2 id="什么情况下索引会失效？（什么情况下用不了索引？）"><a href="#什么情况下索引会失效？（什么情况下用不了索引？）" class="headerlink" title="什么情况下索引会失效？（什么情况下用不了索引？）"></a>什么情况下索引会失效？（什么情况下用不了索引？）</h2><p>如果索引失效了，将会采用全表扫描。有以下几种情况会导致索引失效：</p>
<ul>
<li><p>不符合最左匹配原则</p>
</li>
<li><p>当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效</p>
</li>
<li><p>使用like查询并且以%开头，比如like ‘%abc’会失效</p>
</li>
<li><p><strong>在索引上进行计算</strong>会导致索引失效，例如 <code>select*from table_name where a+1=2</code></p>
</li>
<li><p><strong>在索引中使用函数</strong>会导致索引失效，例如 <code>select*from table_name where abs(a)=1</code></p>
</li>
<li><p><strong>索引上使用is null</strong> 判断时会导致索引失效，例如 <code>select*from table_name where a is nul1</code></p>
</li>
</ul>
<h2 id="什么是最左匹配原则"><a href="#什么是最左匹配原则" class="headerlink" title="什么是最左匹配原则"></a>什么是最左匹配原则</h2><p>最左匹配原则：索引<strong>从最左边为起点开始</strong>连续匹配，遇到范围查询（&lt;，&gt;、between，like）会停止匹配。并且mysql的<strong>优化器会自动优化查询顺序</strong>。</p>
<p><strong>举一些例子：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#比方说我们建立了一个联合索引（a,b,c）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span> <span class="keyword">and</span> c =<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c）,用上a,b,c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c）,用上a,b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> b=<span class="number">1</span> <span class="keyword">and</span> a=<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c）,用上a,b（mysql有查询优化器）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span>;     <span class="comment">#这样也可以利用到定义的索引（a,b,c）,用上a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> b=<span class="number">1</span> <span class="keyword">and</span> c=<span class="number">1</span>;     <span class="comment">#这样不可以利用到定义的索引（a,b,c）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> c=<span class="number">1</span>;     <span class="comment">#这样可以利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b&gt;<span class="number">1</span> <span class="keyword">and</span> c =<span class="number">1</span>; <span class="comment">#这样只能用上a、b索引，c索引用不到 （遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。）</span></span><br><span class="line"></span><br><span class="line">若索引是（a,c,b）</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a=<span class="number">1</span> <span class="keyword">and</span> b&gt;<span class="number">1</span> <span class="keyword">and</span> c =<span class="number">1</span>;<span class="comment">#那么a,c,b都能匹配上，mysql优化器会改写顺序</span></span><br></pre></td></tr></table></figure>




<h2 id="为什么建议使用自增ID作为主键？"><a href="#为什么建议使用自增ID作为主键？" class="headerlink" title="为什么建议使用自增ID作为主键？"></a>为什么建议使用自增ID作为主键？</h2><p><strong>InnoDB中是如何将主键作为聚簇索引的？</strong></p>
<p>如果我们定义了主键(PRIMARY KEY)，那么主键就是聚簇索引；</p>
<p>如果没有定义主键，那么第一个不含有NULL值的唯一索引就是聚簇索引；</p>
<p>如果也没有的话，那么InnoDB 会创建一个隐藏的 ROWID 作为聚集索引。<strong>ROWID随着行记录的写入而主动递增</strong>，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的。</p>
<p><strong>自增的好处？</strong></p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就<strong>会顺序添加到当前索引节点的后续位置</strong>，当一页写满，就会自动开辟一个新的页。</p>
<p>如果使用非自增主键（如果学号等），由于每次插入主键的值近似于随机，因此每条新数据都要被插到索引页的中间某个位置，<strong>因为我们知道B+树的叶子结点近似于链表，这时就不得不移动数据，调整分页，增加了很多开销。</strong></p>
<h2 id="什么是数据库的事务？"><a href="#什么是数据库的事务？" class="headerlink" title="什么是数据库的事务？"></a>什么是数据库的事务？</h2><p>百度百科的解释：数据库事务（transaction）是访问并可能操作各种数据项的一个数据库擦操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务的全部数据库操作组成。</p>
<p><strong>开启事务</strong> start transaction，<strong>提交语句</strong>是commit，<strong>回滚语句</strong>是rollback。</p>
<h2 id="事务的四大特性是什么？（ACID四大特性）"><a href="#事务的四大特性是什么？（ACID四大特性）" class="headerlink" title="事务的四大特性是什么？（ACID四大特性）"></a>事务的四大特性是什么？（ACID四大特性）</h2><ul>
<li>原子性 (atomicity）：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。</li>
<li>一致性 (consistency)：一致性指事务在执行前后状态是一致的。</li>
</ul>
<blockquote>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
</blockquote>
<ul>
<li>隔离性 (isolation)：多个并发事务之间相互隔离，不会其他事务的操作所干扰。</li>
<li>持久性 (durability)：事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。</li>
</ul>
<p>面试题：MySQL如何保证原子性？</p>
<p>利用Innodb的undo log，回滚日志</p>
<h2 id="数据库的并发一致性问题（4个）"><a href="#数据库的并发一致性问题（4个）" class="headerlink" title="数据库的并发一致性问题（4个）"></a>数据库的并发一致性问题（4个）</h2><p>当多个事务并发执行时，可能会出现以下问题：</p>
<ul>
<li><p><strong>脏读</strong>：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。（事务A更新了数据未提交-》B读取-》A回滚-》B读取了脏数据）</p>
</li>
<li><p><strong>不可重复读</strong>：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。（A多次读取的过程中B进行了修改，导致A前后读取<strong>数据内容</strong>不一致）</p>
</li>
<li><p><strong>幻读</strong>：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。（A多次读取的过程中B进行了数据数目的修改，导致A前后读取的<strong>数据数目</strong>不一致）</p>
</li>
<li><p><strong>丢失修改</strong>：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。（AB对同一个数据修改，B的修改覆盖了A的修改）</p>
</li>
</ul>
<p>不可重复读和幻读看起来比较像，都是读取了另一条已经提交的事务，它们主要的区别是：在不可重复读中，发现数据不一致主要是数据被更新了（内容不一样）。在幻读中，发现数据不一致主要是数据增多或者减少了（数量不一样）。</p>
<h2 id="数据库的隔离级别（4个）"><a href="#数据库的隔离级别（4个）" class="headerlink" title="数据库的隔离级别（4个）"></a>数据库的隔离级别（4个）</h2><p>数据库的隔离级别分别可以解决数据库的脏读、不可重复读、幻读的问题。</p>
<ul>
<li>读未提交（READ UNCOMMITTED）：一个事务在提交前，它的修改对其他事务也是可见的。</li>
<li>读已提交（READ COMMITTED）：一个事务提交之后，它的修改才能被其他事务看到。可避免 <strong><em>脏读</em></strong> 的发生</li>
<li>可重复读（REPEATABLE READ）：在同一个事务中多次读取到的数据是一致的。可避免 <strong><em>脏读</em></strong> 、**<em>不可重复读**</em> 的发生。 <strong>是MySQL的默认隔离级别</strong></li>
<li>串行化（SERIALIZABLE）：需要加锁实现，会强制事务串行执行。可避免 <strong><em>脏读、不可重复读、幻读</em></strong> 的发生。</li>
</ul>
<p>以上四种隔离级别最高的是 <strong>Serializable</strong> 级别，最低的是 <strong>Read uncommitted</strong> 级别，当然级别越高，执行效率就越低。</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211017224521900.png" alt="隔离级别"></p>
<h2 id="数据库的隔离级别是如何实现的？"><a href="#数据库的隔离级别是如何实现的？" class="headerlink" title="数据库的隔离级别是如何实现的？"></a>数据库的隔离级别是如何实现的？</h2><p>事务的隔离机制主要是依靠数据库的锁机制和MVCC（多版本并发控制）实现的，读已提交和可重复读可以通过MVCC实现，串行化可以通过锁机制实现。</p>
<h2 id="什么是MVCC？"><a href="#什么是MVCC？" class="headerlink" title="什么是MVCC？"></a>什么是MVCC？</h2><p> <strong>MVCC有什么作用？</strong></p>
<p>MVCC（multiple version concurrent control）叫做多版本并发控制，它可以用不加锁、非阻塞的方式来解决读写冲突，提高了数据库并发性能，解决了一些并发安全问题.</p>
<p><strong>所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。</strong></p>
<p>在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成 ReadView 的时机不同。</p>
<p><strong>在 读已提交 的隔离级别下每次查询都会生成一个实时的 ReadView，做到保证每次提交后的数据是处于当前的可见状态。</strong></p>
<p><strong>而 可重复读 的隔离级别下，在当前事务第一次查询时生成当前的 ReadView，并且当前的 ReadView 会一直沿用到当前事务提交，以此来保证可重复读（REPEATABLE READ）。</strong></p>
<h2 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h2><p>主要与 <strong>三个隐藏字段</strong>、<strong>undo log</strong>、<strong>ReadView</strong> 这三个东西有关</p>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的 DB_TRX_ID,  DB_ROLL_PTR,  DB_ROW_ID 等字段</p>
<ul>
<li><strong>DB_TRX_ID</strong><br>6 byte，最近修改(修改/插入)事务 ID：记录创建这条记录/最后一次修改该记录的事务 ID</li>
<li><strong>DB_ROLL_PTR</strong><br>7 byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）</li>
<li><strong>DB_ROW_ID</strong><br>6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以DB_ROW_ID产生一个聚簇索引</li>
</ul>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211023114056854.png" alt="隐藏字段"></p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log 主要分为两种：</p>
<ul>
<li><strong>insert undo log</strong><br>代表事务在 insert 新记录时产生的 undo log</li>
<li><strong>update undo log</strong><br>事务在进行 update 或 delete 时产生的 undo log ; 对 MVCC 有帮助的实质是 <code>update undo log</code></li>
</ul>
<p>事务对同一记录的修改，记录的各个会在Undo日志中连接成一个链表，在表头的就是最新纪录。在undo log我们可以通过回滚来找到之前的记录。</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211023114417708.png" alt="image-20211023114417708"></p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>说白了 Read View 就是事务进行<code>快照读</code>操作的时候生产的<code>读视图</code> 。</p>
<p>它主要是用来做<strong>可见性判断</strong>的, 即当我们某个事务执行读操作（快照读）的时候，对该记录创建一个 <code>Read View</code> ，把这个ReadView作为条件，用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是<code>undo log</code>里面的某个版本的数据。</p>
<ul>
<li>对于READ COMMITTED 隔离级别下的ReadView，**每次读取数据前都生成一个ReadView **</li>
<li>REPEATABLE READ 隔离级别下的ReadView，<strong>在事务开始后第一次读取数据时生成一个ReadView</strong>，之后会一直用第一次的ReadView，<strong>以此来保证可重复读（REPEATABLE READ）的隔离级别</strong></li>
</ul>
<p>而对于对于 读未提交 隔离级别下，所有事务直接读取数据库的最新值即可</p>
<p>对于串行化 隔离级别，所有请求都会加锁，同步执行。所以这对这两种情况下是不需要使用到 Read View 的版本控制。</p>
<p><strong>总结一下</strong>，MVCC的作用就是在避免加锁的情况下最大限度解决读写并发冲突的问题，它可以实现<strong>读已提交</strong>和<strong>可重复读</strong>两个隔离级别。</p>
<h2 id="数据库的锁与隔离级别的关系？"><a href="#数据库的锁与隔离级别的关系？" class="headerlink" title="数据库的锁与隔离级别的关系？"></a>数据库的锁与隔离级别的关系？</h2><p>为了解决数据库并发的问题采用了锁机制</p>
<p>加锁实现不同的隔离级别，如下图所示：</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018114214135.png" alt="加锁实现不同的隔离级别"></p>
<h2 id="在MySQL的可重复读级别下，如何解决幻读问题？"><a href="#在MySQL的可重复读级别下，如何解决幻读问题？" class="headerlink" title="在MySQL的可重复读级别下，如何解决幻读问题？"></a>在MySQL的可重复读级别下，如何解决幻读问题？</h2><p><img src="/images/mysql%E7%9B%B8%E5%85%B3/v2-7ca404a7a1a3be58fbffe0d6c89732ab_1440w.jpg" alt="img"></p>
<p><strong>标准回答：</strong></p>
<p><strong>使用MVCC + Next-Key Locks（临键锁）可以解决MySQL的幻读问题</strong></p>
<p>MVCC–快照读 （查到的是第一个视图） ， Next-Key Locks –当前读 （查到的是最新的视图）</p>
<p>在可重复读的级别下，我们使用select语句查询是快照读。</p>
<p>可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个视图，然后后续的查询语句都用这个视图，「快照读」读的就是这个视图的数据，视图你可以理解为版本数据，这样就使得每次查询的数据都是一样的。</p>
<p>MySQL 里除了普通查询是快照度，其他都是<strong>当前读</strong>，比如update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做 进一步的操作。</p>
<p>这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且 提交事务了，这样不是会产生冲突吗，所以 update 的时候肯定要知道最新的数据。</p>
<p>另外，<code>select ... for update</code> 这种查询语句是当前读，每次执行的时候都是读取最新的数据。</p>
<p><strong>因此，要讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下。</strong></p>
<p>所以，<strong>Innodb 引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了 next-key 锁</strong>，就是记录锁和间隙锁的组合。</p>
<ul>
<li>记录锁，锁的是记录本身；</li>
<li>间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。</li>
</ul>
<p>比如，执行这条语句的时候，会锁住，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞，因而就解决了幻读的问题。</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/v2-1797f59c730254982b9dc78bbbe7c099_b.jpg" alt="img"></p>
<h2 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h2><p><strong>封锁粒度</strong>：表级锁、行级锁</p>
<p><strong>封锁类型</strong>：排它锁和共享锁（读写锁）、意向排它锁和意向共享锁（意向锁）</p>
<h3 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h3><p><strong>按照锁的粒度可以将MySQL锁分为三种：</strong>表级锁、行级锁、页面锁</p>
<p>InnoDB默认采用行级锁，MyISAM默认采用表级锁。</p>
<ul>
<li><strong>表级锁</strong></li>
</ul>
<p>Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p>
<ul>
<li><strong>行级锁</strong></li>
</ul>
<p>Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>
<p> InnoDB支持的行级锁，包括如下几种。</p>
<ul>
<li>Record Lock: 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</li>
<li>Gap Lock: 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</li>
<li>Next-key Lock： 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</li>
</ul>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018114344753.png" alt="image-20211018114344753"></p>
<p><strong>虽然使用行级索具有粒度小、并发度高等特点，但是表级锁有时候也是非常必要的</strong>：</p>
<ul>
<li>事务更新大表中的大部分数据直接使用表级锁效率更高；</li>
<li>事务比较复杂，使用行级索很可能引起死锁导致回滚。</li>
</ul>
<hr>
<h3 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h3><p><strong>按照是否可读写分为两种</strong>：共享锁和排他锁</p>
<ul>
<li><strong>共享锁</strong>：共享锁又称<strong>读锁</strong>，简写为S锁，一个事务对一个数据对象加了S锁，可以读数据，不能改数据。加锁期间，其他事务只能对这个数据对象加S锁，不能加X锁。</li>
<li><strong>排他锁</strong>：排他锁又称为<strong>写锁</strong>，简写为X锁，一个事务对一个数据对象加了X锁，可以读数据也可以改数据。加锁期间，其他事务不能对这个数据对象加S锁或X锁。</li>
</ul>
<p>兼容情况如下：</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018120648931.png" alt="image-20211018120648931" style="zoom:67%;" />

<p><strong>使用方式：</strong></p>
<p>共享锁： select… in share mode      排它锁： select… for update</p>
<ul>
<li>select * from table lock in share mode 为table的所有数据加上共享锁，既表级共享锁</li>
<li>select * from table for update 为table的所有数据加上排他锁，既表级排他锁</li>
<li>select * from table where id = 1 for update 为table中id为1的那行数据加上排他锁，既行级排他锁</li>
<li>select * from table where id = 1 lock in share mode为table中id为1的那行数据加上共享锁，既行级共享锁</li>
</ul>
<p>当然以上，加的是行锁的前提是，id为主键且在查询命中，否则行锁会轮为表锁</p>
<h3 id="意向共享锁和意向排它锁"><a href="#意向共享锁和意向排它锁" class="headerlink" title="意向共享锁和意向排它锁"></a>意向共享锁和意向排它锁</h3><p>需要注意的<strong>意向锁是表锁</strong>，不会与行锁发生冲突</p>
<p><strong>意向共享锁</strong>和<strong>意向排他锁</strong></p>
<p>事务A获取了某一行的排它锁，尚未提交，此时事务B想要获取表锁时，必须要确认表的每一行都不存在排他锁，很明显效率会很低，引入意向锁之后，效率就会大为改善：</p>
<p>1、如果事务A获取了某一行的排它锁，实际此表存在两种锁，<strong>表中某一行的排他锁</strong>和<strong>表上的意向排他锁</strong>。</p>
<p>2、当事务B试图在该表级别上加锁时，则受到表上一个意向锁的阻塞，它在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。</p>
<ul>
<li><p>意向共享锁：简称IS锁，事务打算给数据行加共享锁，事务在给某些行加S锁前必须先获得该表的IS锁。</p>
</li>
<li><p>意向排他锁：简称IX锁，事务打算给数据行加排他锁，事务在给某些行加X锁前必须先获得该表的IX锁。</p>
</li>
</ul>
<p>用户无法操作意向锁，意向锁是由InnoDB自己维护的。说白了，意向锁是帮助InnoDB提高效率的一种手段。</p>
<img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211019100954670.png" alt="image-20211019100954670" style="zoom:67%;" />



<p>注意：<strong>意向锁不会与行级的共享 / 排他锁互斥！！！</strong></p>
<p>举个例子：</p>
<p><code>事务 A</code> 先获取了某一行的<strong>排他锁</strong>，并未提交：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 A</code> 获取了 <code>users</code> 表上的<strong>意向排他锁</strong>。</li>
<li><code>事务 A</code> 获取了 id 为 6 的数据行上的<strong>排他锁</strong>。</li>
</ol>
<p>之后<code>事务 B</code> 想要获取 <code>users</code> 表的<strong>共享锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="keyword">users</span> <span class="keyword">READ</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 B</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li><code>事务 B</code> 对 <code>users</code> 表的加锁请求被阻塞（排斥）。</li>
</ol>
<p>最后<code>事务 C</code> 也想获取 <code>users</code> 表中某一行的<strong>排他锁</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>事务 C</code> 申请 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li><code>事务 C</code> 检测到<code>事务 A</code> 持有 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li>因为意向锁之间并不互斥，所以<code>事务 C</code> 获取到了 <code>users</code> 表的<strong>意向排他锁</strong>。</li>
<li>因为id 为 5 的数据行上不存在任何<strong>排他锁</strong>，最终<code>事务 C</code> 成功获取到了该数据行上的<strong>排他锁</strong>。</li>
</ol>
<p>例子：</p>
<p>(1) 事务A向student表申请a行的<code>行级S锁</code>，所以存储引擎自动为该表先加上<code>IS锁</code></p>
<p>(2) 事务B向student表申请全表的<code>表级X锁</code>，因为<code>表级X锁</code>与<code>IS锁</code>不兼容，所以事务B的表级X锁申请被事务A阻塞</p>
<p>(3) 事务C向student表申b行的<code>行级X锁</code>, 所以存储引擎自动为该表先加上<code>IX锁</code>。因为<code>IX锁</code>和<code>IS锁</code>是互相兼容的，且事务A与事务C针对的行记录不同，所以事务C成功获得<code>行级X锁</code></p>
<p><strong>总结：</strong></p>
<ol>
<li>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</li>
<li>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
</ol>
<h2 id="InnoDB的三种行锁（记录锁、间隙锁、临键锁）"><a href="#InnoDB的三种行锁（记录锁、间隙锁、临键锁）" class="headerlink" title="InnoDB的三种行锁（记录锁、间隙锁、临键锁）"></a>InnoDB的三种行锁（记录锁、间隙锁、临键锁）</h2><p><strong>MVCC不能解决幻读问题，在可重复读隔离级别下，使用MVCC+Next-key Locks可以解决幻读问题。</strong></p>
<h3 id="什么是幻读？"><a href="#什么是幻读？" class="headerlink" title="什么是幻读？"></a>什么是幻读？</h3><p>幻读是在<code>可重复读</code>的事务隔离级别下会出现的一种问题，简单来说，<code>可重复读</code>保证了当前事务不会读取到其他事务已提交的 <code>UPDATE</code>  操作。但同时，也会导致当前事务无法感知到来自其他事务中的 <code>INSERT</code> 或 <code>DELETE</code> 操作，当当前事务通过 update 等操作获取到该种记录行时，就会产生<code>幻读</code>。</p>
<h3 id="关于行锁我们要知道的"><a href="#关于行锁我们要知道的" class="headerlink" title="关于行锁我们要知道的"></a>关于行锁我们要知道的</h3><p>行锁在 InnoDB 中是基于<code>索引</code>实现的，所以一旦某个加锁操作没有使用索引，那么该锁就会退化为<code>表锁</code>。</p>
<h3 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h3><p>记录锁就是为<strong>某行</strong>记录加锁，它锁住的是该行的索引记录：</p>
<p>InnoDB的<strong>行锁是依赖索引实现的</strong>，而其锁住某行数据的<strong>本质是锁住行数据对应在聚簇索引的索引记录</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>id 为 1 的记录行会被锁住。</p>
<p>需要注意的是：<code>id</code> 列必须为<code>唯一索引列</code>或<code>主键列</code>，否则上述语句加的锁就会变成<code>临键锁</code>。</p>
<p>同时查询语句必须为<code>精准匹配</code>（<code>=</code>），不能为 <code>&gt;</code>、<code>&lt;</code>、<code>like</code>等，否则也会退化成<code>临键锁</code>（感谢评论区 @decodes 提醒）。</p>
<p><strong>其他实现</strong></p>
<p>在通过 <code>主键索引</code> 与 <code>唯一索引</code> 对数据行进行 UPDATE 操作时，也会对该行数据加<code>记录锁</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> age = <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h3><p><strong>间隙锁</strong>基于<code>非唯一索引</code>，它<code>锁定一段范围内的索引记录</code>。<strong>间隙锁</strong>基于下面将会提到的<code>Next-Key Locking</code> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的一条数据</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>即所有在<code>（1，10）</code>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</p>
<h3 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h3><p>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<code>非唯一索引列</code>上都会存在一把<strong>临键锁</strong>，当某个事务持有该数据行的<strong>临键锁</strong>时，会锁住一段<strong>左开右闭区间</strong>的数据。需要强调的一点是，<code>InnoDB</code> 中<code>行级锁</code>是基于索引实现的，<strong>临键锁</strong>只与<code>非唯一索引列</code>有关，在<code>唯一索引列</code>（包括<code>主键列</code>）上不存在<strong>临键锁</strong>。</p>
<p>假设有如下表：<br> <strong>MySql</strong>，<strong>InnoDB</strong>，<strong>Repeatable-Read</strong>：table(id PK, age KEY, name)</p>
<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>Lee</td>
</tr>
<tr>
<td>3</td>
<td>24</td>
<td>Soraka</td>
</tr>
<tr>
<td>5</td>
<td>32</td>
<td>Zed</td>
</tr>
<tr>
<td>7</td>
<td>45</td>
<td>Talon</td>
</tr>
<tr>
<td>该表中 <code>age</code> 列潜在的<code>临键锁</code>有：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(-∞, 10],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(10, 24],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(24, 32],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(32, 45],</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(45, +∞],</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在<code>事务 A</code> 中执行如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据非唯一索引列 UPDATE 某条记录</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> <span class="keyword">name</span> = Vladimir <span class="keyword">WHERE</span> age = <span class="number">24</span>;</span><br><span class="line"><span class="comment">-- 或根据非唯一索引列 锁住某条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> age = <span class="number">24</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>不管执行了上述 SQL 中的哪一句，之后如果在<code>事务 B</code> 中执行以下命令，则该命令会被阻塞：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span>(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;Ezreal&#x27;</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>很明显，<code>事务 A</code> 在对 <code>age</code> 为 24 的列进行 UPDATE 操作的同时，也获取了 <code>(24, 32]</code> 这个区间内的临键锁。</p>
<p>不仅如此，在执行以下 SQL 时，也会陷入阻塞等待：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span>(<span class="number">100</span>, <span class="number">30</span>, <span class="string">&#x27;Ezreal&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>那最终我们就可以得知，在根据<code>非唯一索引</code> 对记录行进行 <code>UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE</code> 操作时，InnoDB 会获取该记录行的 <code>临键锁</code> ，并同时获取该记录行下一个区间的<code>间隙锁</code>。</p>
<p>即<code>事务 A </code>在执行了上述的 SQL 后，最终被锁住的记录区间为 <code>(10, 32)</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong>InnoDB</strong> 中的<code>行锁</code>的实现依赖于<code>索引</code>，一旦某个加锁操作没有使用到索引，那么该锁就会退化为<code>表锁</code>。</li>
<li><strong>记录锁</strong>存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录。</li>
<li><strong>间隙锁</strong>存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段索引记录。</li>
<li><strong>临键锁</strong>存在于<code>非唯一索引</code>中，锁定一段<code>左开右闭</code>的索引区间。</li>
</ol>
<p><strong>记录锁，间隙锁，临键锁的关系</strong></p>
<p>我们知道InnoDB的行锁默认是基于B+Tree的。所以行锁依赖的索引是有序的。</p>
<ul>
<li>记录锁就是单纯意义上的行锁，锁的就是单行数据，该数据是真实存在的</li>
<li>而间隙锁则是锁住一个区间中多行数据，但这些多行的数据实际是并不存在的。既只锁住真实数据对应索引项之间的一个空间范围</li>
<li>而临键锁说白了就是记录锁+间隙锁的组合。只要把记录锁和间隙锁组合在一起，就是临键锁，既锁住索引项本身的真实数据，又锁住两两索引之间没有数据的空间范围。</li>
</ul>
<h2 id="什么是数据库的乐观锁和悲观锁，如何实现？"><a href="#什么是数据库的乐观锁和悲观锁，如何实现？" class="headerlink" title="什么是数据库的乐观锁和悲观锁，如何实现？"></a>什么是数据库的乐观锁和悲观锁，如何实现？</h2><p><strong>乐观锁</strong>：他比较乐观，认为每次去拿数据都是不会发生冲突的，只在更新操作提交的时候对数据检测冲突，如果存在冲突，则数据更新失败。</p>
<p>乐观锁实现方式：一般通过版本号和CAS算法实现。</p>
<p><strong>悲观锁</strong>：他比较悲观，认为每次去拿数据的时候都认为别人会修改，因此会在每次拿数据的时候加锁。</p>
<p>悲观锁的实现方式：通过数据库的锁机制实现，对查询语句添加for update</p>
<h2 id="什么是死锁？如何避免？"><a href="#什么是死锁？如何避免？" class="headerlink" title="什么是死锁？如何避免？"></a>什么是死锁？如何避免？</h2><p>死锁是指两个或者两个以上进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象。在MySQL中，MyISAM是一次获得所需的全部锁，要么全部满足，要么等待，所以不会出现死锁。<br>在InnoDB存储引擎中，除了单个SQL组成的事务外，锁都是逐步获得的，所以存在死锁问题。</p>
<p><strong>如何避免MySQL发生死锁或锁冲突：</strong></p>
<ul>
<li>如果不同的程序并发存取多个表，尽量以相同的顺序访问表。</li>
<li>在程序以批量方式处理数据的时候，如果已经对数据排序，尽量保证每个线程按照固定的顺序来处理记录。</li>
<li>在事务中，如果需要更新记录，应直接申请足够级别的排他锁，而不应该先申请共享锁，更新时在申请排他锁，因为在当前用户申请排他锁时，其他事务可能已经获得了相同记录的共享锁，从而造成锁冲突或者死锁。<br>尽量使用较低的隔离级别</li>
<li>尽量使用索引访问数据，使加锁更加准确，从而减少锁冲突的机会合理选择事务的大小，小事务发生锁冲突的概率更低</li>
<li>尽量用相等的条件访问数据，可以避免Next-Key锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别，查询时尽量不要显示加锁对于一些特定的事务，可以表锁来提高处理速度或减少死锁的概率。</li>
</ul>
<h2 id="大表如何优化"><a href="#大表如何优化" class="headerlink" title="大表如何优化"></a>大表如何优化</h2><ul>
<li>限定数据的范围：避免不带任何限制数据范围条件的查询语句。</li>
<li>读写分离：主库负责写，从库负责读。</li>
<li>垂直分表：将一个表按照字段分成多个表，每个表存储其中一部分字段。</li>
<li>水平分表：在同一个数据库内，把一个表的数据按照一定规则拆分到多个表中。</li>
<li>对单表进行优化：对表中的字段、索引、查询SQL进行优化。</li>
<li>添加缓存</li>
</ul>
<h2 id="MySQL慢查询是什么"><a href="#MySQL慢查询是什么" class="headerlink" title="MySQL慢查询是什么"></a>MySQL慢查询是什么</h2><p>MySQL的慢查询，全名是<strong>慢查询日志</strong>，是MySQL提供的一种日志记录，用来<strong>记录在MySQL中执行时间超过阈值的语句</strong>。慢查询日志能帮助我们分析优化SQL语句。</p>
<p>具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。</p>
<p>long_query_time的默认值为10，意思是记录运行10秒以上的语句。</p>
<p>默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。</p>
<p>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</p>
<p><strong>几个重要参数：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log：是否开启慢查询日志，1表示开启，0表示关闭。</span><br><span class="line"></span><br><span class="line">long_query_time：慢查询阈值，当查询时间多于设定的阈值时，会记录在日志中。</span><br><span class="line"></span><br><span class="line">slow_query_log_file ：指定慢查询日志得存储路径及文件</span><br></pre></td></tr></table></figure>



<p><strong>分析慢查询语句：</strong></p>
<p>当我们找到执行缓慢的语句后，</p>
<p>使用explain关键字可以<strong>模拟优化器执行SQL语句</strong>，从而知道MySQL是如何处理你的SQL语句的。</p>
<p><img src="https://img-blog.csdn.net/20180520151002824?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doeTE1NzMyNjI1OTk4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li><p>id：</p>
</li>
<li><p>select_type：用来表示查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p>
</li>
</ul>
<p>SIMPLE 简单的select查询，查询中不包含子查询或者UNION</p>
<p>PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</p>
<p>SUBQUERY 在SELECT或WHERE列表中包含了子查询</p>
<p>DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中</p>
<p>UNION 若第二个SELECT出现在UNION之后，则被标记为UNION：若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</p>
<p>UNION RESULT 从UNION表获取结果的SELECT</p>
<ul>
<li>table：当前查询的表</li>
<li>type：</li>
<li>possible_keys：可能使用的索引</li>
<li>key：实际使用的索引，若没有使用索引或者索引失效就为null</li>
<li>extra：一些额外信息，比如using where；using index</li>
</ul>
<p><strong>索引优化：</strong></p>
<p>当我们分析慢查询语句时候，发现有的语句没用上索引，就需要优化SQL语句</p>
<h2 id="什么是垂直分表、垂直分库、水平分表、水平分库？"><a href="#什么是垂直分表、垂直分库、水平分表、水平分库？" class="headerlink" title="什么是垂直分表、垂直分库、水平分表、水平分库？"></a>什么是垂直分表、垂直分库、水平分表、水平分库？</h2><h3 id="为什么要分表分库？"><a href="#为什么要分表分库？" class="headerlink" title="为什么要分表分库？"></a><strong>为什么要分表分库？</strong></h3><p>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a><strong>垂直分表</strong></h3><p>垂直分表：将一个表按照字段进行划分，每个表存储其中一部分字段。 一般我们会把表中的大字段分到一个表中，比如text字段，blob字段从表中分离出去，这样可以大大减轻原表的数据压力，而且这些大字段的访问量通常没有其它字段的访问频率高。</p>
<p>举一个淘宝上商品的例子，比如我们搜索一个商品，会显示商品基本信息和商品描述，商品基本信息一般会展示在商品列表，商品描述在商品详情页，因为在商品列表的页面上，我们只需要商品的基本信息，因此可以将商品基本信息和商品描述拆分成两张表。</p>
<p>效率高的原因：<strong>行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。</strong></p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211018122823123.png" alt="在这里插入图片描述"></p>
<p>通常我们按以下原则进行垂直拆分:</p>
<ol>
<li>把不常用的字段单独放在一张表;</li>
<li>把text，blob等大字段拆分出来放在附表中;</li>
<li>经常组合查询的列放在一张表中;</li>
</ol>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>垂直分表是按照字段进行拆分，而水平分表是按照行记录进行拆分。</p>
<p>比如说表中有1亿条记录，按照水平拆分成10个表，每个表的字段结构相同，都包含1000万条记录。</p>
<p>我们的拆分规则是怎样的的呢？ 按照每一行的id对10取余，分散在各个表中，当我们查询的时候，也进行取余去相应的数据表中查询。</p>
<p>这样有两个好处：</p>
<ul>
<li>一个是在每个表中的数据量小了，提高了检索性能</li>
<li>第二个是，减小了锁住表的几率，同样可以提高检索性能</li>
</ul>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>垂直分库：按照业务对表进行划分，处理不同业务的表放入不同的数据库中</p>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA2MjMzOQ==,size_16,color_FFFFFF,t_70.png" alt="垂直分库"></p>
<p>垂直分库的优势：</p>
<ul>
<li>降低业务中的耦合，方便对不同的业务进行分级管理。</li>
<li>可以提升10、数据库连接数、解决单机硬件资源的瓶颈问题。</li>
</ul>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>类似于水平分表，当表的数据量越来越大的时候，同样可以考虑用不同的数据库存放这些数据。</p>
<h2 id="数据库主从复制"><a href="#数据库主从复制" class="headerlink" title="数据库主从复制"></a>数据库主从复制</h2><h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为<strong>从数据库</strong>；主数据库一般是准实时的业务数据库</p>
<h3 id="为什么要主从复制（主从复制的好处）"><a href="#为什么要主从复制（主从复制的好处）" class="headerlink" title="为什么要主从复制（主从复制的好处）"></a>为什么要主从复制（主从复制的好处）</h3><ul>
<li><p><strong>实现服务器负载均衡</strong>。比如说在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。将数据的查询请求全部由从服务器执行。可以缩短应用程序的响应时间、提高系统的性能。</p>
</li>
<li><p><strong>实现数据备份</strong>。可定期将数据从主服务器上备份到从服务器上，从数据库可以作为后备数据库。</p>
</li>
<li><p><strong>提高数据库系统可用性</strong>。主数据库服务器故障后，可切换到从数据库继续工作。</p>
</li>
</ul>
<h3 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h3><img src="/images/mysql%E7%9B%B8%E5%85%B3/主从复制.png" alt="主从复制" style="zoom:67%;" />

<p>主从复制主要有三个线程：<strong>binlog线程</strong>、<strong>I/O线程</strong>、<strong>SQL线程。</strong></p>
<p>主从复制主要围绕这三个线程来进行：</p>
<p>1、主库数据变化后，将更新事件的操作记录(update、delete)写到binlog文件中</p>
<p>2、从库创建I/O线程，读取主库binlog文件内容并写入到relay log中</p>
<p>3、从库创建SQL线程，读取Relay log中的内容并执行，将更新内容写入到从库中</p>
<h2 id="mysql常见的三种log总结"><a href="#mysql常见的三种log总结" class="headerlink" title="mysql常见的三种log总结"></a>mysql常见的三种log总结</h2><p>mysql中常见的三种log，分别是重做日志**(redo log**)，回滚日志(<strong>undo log</strong>)，以及二进制日志(<strong>bin log</strong>)</p>
<h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p>作用：当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据，如果这个时候发生非正常的DB服务重启，那么这些数据还没在内存，并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），也就是会发生数据丢失，所以在重启mysql服务的时候，可以根据redo log进行重做，从而达到事务的持久性<br>内容：物理日志，即记录修改后的数据行<br>什么时候产生：事务开始之后产生redo log<br>什么时候释放：当对应事务的脏页写入到磁盘之后，redo log即可被覆盖<br>什么时候写入磁盘：</p>
<blockquote>
<p>Master Thread每秒一次执行刷新Innodb_log_buffer到重做日志文件<br>每个事务提交时将重做日志刷新到重做日志文件<br>当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到重做日志文件</p>
</blockquote>
<p><img src="/images/mysql%E7%9B%B8%E5%85%B3/image-20211024224109659.png" alt="image-20211024224109659"></p>
<h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2. undo log"></a>2. undo log</h4><p>作用：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读(MVCC)<br>内容：物理日志，修改前的数据行<br>什么时候产生：事务开始之前，将当前版本生成undo log，undo也会产生redo来保证undo log的可靠性<br>什么时候释放：当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间</p>
<h4 id="3-binlog"><a href="#3-binlog" class="headerlink" title="3. binlog"></a>3. binlog</h4><p>作用：用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步；用于数据库的基于时间点的还原<br>什么时候产生：事务提交的时候，一次性将事务中的sql语句或者是修改过后的语句按照一定的格式记录到binlog中<br>什么时候释放：由参数expire_logs_days决定<br>与redo log的不同点：</p>
<blockquote>
<p>作用不同：redo log用来保证事务的持久性，binlog则用来复制数据库<br>内容不同：redo log是物理日志，binlog通常是逻辑日志<br>生命周期不同<br>效率不同：基于物理日志的redo log回复数据的效率高于binlog</p>
</blockquote>
<p><strong>总结：</strong></p>
<ul>
<li>bin log 主要用于复制和数据恢复。</li>
<li>redo log 用于恢复在内存更新后，还没来得及刷到磁盘的数据。</li>
<li>undo log 用于实现回滚和多版本控制。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">pb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/03/mysql相关/">http://example.com/2021/09/03/mysql相关/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">pb</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="social-share pull-right" data-disabled="google,twitter,facebook,douban,instagram,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/"><i class="fa fa-chevron-left">  </i><span>两个大数求和</span></a></div><div class="next-post pull-right"><a href="/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"><span>http相关内容</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '52a38b388c08f769c0fe',
  clientSecret: '5428c9a58faaa3488201c1791496427b41deb385',
  repo: 'jiubukaiji.github.io',
  owner: 'jiubukaiji',
  admin: 'jiubukaiji',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By pb</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>