<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="java集合框架"><meta name="keywords" content="java集合框架"><meta name="author" content="pb"><meta name="copyright" content="pb"><title>java集合框架 | pb</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="pb" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">java集合框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-List-Set-Map-%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">说说 List,Set,Map 三者的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">数组与集合的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8EArrayList%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%883%E4%B8%AA%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">数组与ArrayList的区别（3个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">如何选用集合?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">Iterator迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">有哪些集合是线程不安全的？怎么解决呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8BList"><span class="toc-number">8.</span> <span class="toc-text">Collection子接口之List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">ArrayList源码介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.</span> <span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%EF%BC%9A"><span class="toc-number">8.3.</span> <span class="toc-text">扩容机制总结一下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%883%E4%B8%AA%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">ArrayList 和 Vector 的区别？（3个）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%883%E4%B8%AA%EF%BC%89"><span class="toc-number">8.5.</span> <span class="toc-text">ArrayList 和 LinkedList 的区别？（3个）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E6%BA%90%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.6.</span> <span class="toc-text">LinkedList源码介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8BSet"><span class="toc-number">9.</span> <span class="toc-text">Collection子接口之Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">Comparable 和 Comparator 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">HashSet的底层实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">HashSet如何检查重复？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83HashSet%EF%BC%8CLinkedHashSet%E5%92%8CTreeSet%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">9.4.</span> <span class="toc-text">比较HashSet，LinkedHashSet和TreeSet三者的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">HashMap原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.2.</span> <span class="toc-text">字段结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97%EF%BC%883%E6%AD%A5%EF%BC%89"><span class="toc-number">10.1.3.</span> <span class="toc-text">索引计算（3步）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">10.1.4.</span> <span class="toc-text">put方法流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">10.1.5.</span> <span class="toc-text">扩容机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">10.1.6.</span> <span class="toc-text">并发安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">10.1.7.</span> <span class="toc-text">其他的一些注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">10.2.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">10.3.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable"><span class="toc-number">10.4.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB-5%E4%B8%AA%E5%8C%BA%E5%88%AB"><span class="toc-number">10.5.</span> <span class="toc-text">HashMap和Hashtable的区别(5个区别)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E3%80%81ConcurrentHashMap%E5%8F%8AHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.6.</span> <span class="toc-text">HashMap、ConcurrentHashMap及Hashtable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.7.</span> <span class="toc-text">HashMap和HashSet的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">10.8.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">10.9.</span> <span class="toc-text">HashMap有哪几种常见的遍历方式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">12.</span> <span class="toc-text">其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5-fail-fast-%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">什么是快速失败(fail-fast)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5-fail-safe-%E5%91%A2%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">什么是安全失败(fail-safe)呢？</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/111.jpg"></div><div class="author-info__name text-center">pb</div><div class="author-info__description text-center">This is my site</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">88</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pb</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">java集合框架</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/">面试学习系列</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">12.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 43 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>落后就要站直挨打，人菜就要多读书</p>
</blockquote>
<a id="more"></a>

<p>待做：简单理解一下红黑树</p>
<p>多关注一下底层的实现，重点要掌握ArrayList和HashMap的底层原理。</p>
<p>这三篇都是讲HashMap比较清楚的文章</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40574571/article/details/97612100">https://blog.csdn.net/qq_40574571/article/details/97612100</a></p>
<p><a target="_blank" rel="noopener" href="https://angela.blog.csdn.net/article/details/104889549">https://angela.blog.csdn.net/article/details/104889549</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/362214327">https://zhuanlan.zhihu.com/p/362214327</a></p>
<h2 id="java集合框架"><a href="#java集合框架" class="headerlink" title="java集合框架"></a>java集合框架</h2><p><img src="/images/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/image-20211022083130548.png" alt="image-20211022083130548"></p>
<p>主要分为<strong>Collection</strong> 和 <strong>Map</strong> 两种体系，他们都是接口</p>
<p>再细化一点，我们关注 Collection中的 list 和 Set </p>
<h2 id="说说-List-Set-Map-三者的区别？"><a href="#说说-List-Set-Map-三者的区别？" class="headerlink" title="说说 List,Set,Map 三者的区别？"></a>说说 List,Set,Map 三者的区别？</h2><p><strong>List</strong>：存储的元素是<strong>有序的</strong>、<strong>可重复的。</strong>（有序指元素存入的顺序和取出的顺序是一样的）</p>
<p><strong>Set</strong>：存储的元素是<strong>无序的、不可重复的。</strong></p>
<p><strong>Map</strong>：使用键值对（kye-value）存储，Key是无序的、不可重复的，value是无序的、可重复的，每个key只能对应一个value，不同的key可以对应相同的value。</p>
<p>还需要关注是否能存储null值。</p>
<h2 id="数组与集合的区别"><a href="#数组与集合的区别" class="headerlink" title="数组与集合的区别"></a>数组与集合的区别</h2><p>由于<strong>数组的弊端</strong>： 只能存取相同类型的元素，长度固定的。</p>
<p>如果我们想存储多种多样的数据类型，就可以用集合来存储，并且集合还可以存储具有映射关系的数据。</p>
<h2 id="数组与ArrayList的区别（3个）"><a href="#数组与ArrayList的区别（3个）" class="headerlink" title="数组与ArrayList的区别（3个）"></a>数组与ArrayList的区别（3个）</h2><p>数据类型、大小、内置方法三个方面</p>
<ul>
<li>数组可以包含基本数据类型和对象类型，ArrayList只能存储对象类型</li>
<li>数组大小是固定的，ArrayList的大小是动态变化的。</li>
<li>相比于数组，ArrayList有很多的内置方法，方便我们操作数据</li>
</ul>
<h2 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h2><p>根据要存放数据的特点来选择</p>
<p><strong>要存放具有映射关系的数据时</strong>，就用<strong>Map接口</strong>下的集合，要排序就用 TreeMap， 不需要排序用 HashMap， 需要保证线程安全就用 ConcurrentHashMap </p>
<p><strong>当我们只需要存放元素值时</strong>，就选择实现<strong>Collection接口</strong>的集合，需要保证<strong>元素唯一</strong>时选择实现 Set接口的集合比如TreeSet或HashSet，不需要就选择实现<strong>List接口</strong>的比如ArrayList或Linkedlist，然后再根据实现这些接口的集合的特点来选用。 </p>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p><strong>迭代器是什么？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下⼀个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义为：<strong>iterator是一个接口，提供方法遍历集合对象中的元素，而又不需要暴露集合对象的内部细节。</strong></p>
<p><strong>为什么要用迭代器？</strong></p>
<p>迭代器目的是<strong>对集合进行遍历</strong>，而每一个集合内部的存储结构都是不同的，所以每一个集合存和取都是不一样，那么就需要在每一个类中定义<strong>hasNext()**方法和</strong>next()**方法，这样做是可以的，但是会让整个集合体系过于臃肿。</p>
<p>迭代器是将这样的方法抽取出来作为接口，然后在每个类的内部，自己定义迭代方式。</p>
<p>这样做的好处有二：</p>
<p>第一，规定了整个集合体系的遍历方式都是hasNext()和next()方法；</p>
<p>第二，代码有底层内部实现，使用者不用管怎么实现的，会用即可 </p>
<p><strong>迭代器如何使用？</strong>（以map为例）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="comment">//这里我们可以写得更加精炼，用for-each语句来代替,就不用迭代器，在后面的集合遍历方式中会提到</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">        System.out.println(entry.getKey());</span><br><span class="line">        System.out.println(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="有哪些集合是线程不安全的？怎么解决呢？"><a href="#有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="有哪些集合是线程不安全的？怎么解决呢？"></a>有哪些集合是线程不安全的？怎么解决呢？</h2><p>我们常用的 Arraylist，Linkedlist，HashMap，TreeMap，HashSet，TreeSet，PriorityQueue 不是线程安全的。解决办法很简单，可以<strong>使用线程安全的集合来代替。</strong></p>
<p>如果你要使用线程安全的集合的话，可以使用Hashtable、vector、<code>java.util.concurrent</code>包（简称JUC包）中很多的<strong>并发容器</strong>：<br>1、ConcurrentHashMap：可以看作是线程安全的HashMap<br>2、CopyOnwriteArraylist：可以看作是线程安全的Arraylist，在读多写少的场合性能非常好，远远好于Vector<br>3、ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的inkedList，这是一个非阻塞队列。<br>4、BlockingQueue：这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。<br>5、ConcurrentSkipListMap：跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。</p>
<h2 id="Collection子接口之List"><a href="#Collection子接口之List" class="headerlink" title="Collection子接口之List"></a>Collection子接口之List</h2><p>List接口下面主要有三个实现类：<strong>ArrayList</strong> 、 <strong>LinkedList</strong>、 <strong>Vector</strong></p>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20211019152639627.png" alt="List接口主要实现类"></p>
<p>主要的遍历方式主要有三种：</p>
<ul>
<li><strong>for循环遍历</strong>：遍历者自己在集合外部维护一个计数器，依次读取每一个位置的元素。</li>
<li><strong>Iterator遍历</strong>：基于顺序存储集合的iterator可以直接按位置访问数据。</li>
<li><strong>foreach遍历</strong>：foreach内部也是采用了Iterator的方式实现，但使用时不需要显示地声明Iterator.</li>
</ul>
<h3 id="ArrayList源码介绍"><a href="#ArrayList源码介绍" class="headerlink" title="ArrayList源码介绍"></a>ArrayList源码介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>与LinkedList不同的是，ArrayList实现了<strong>RandomAccess</strong>接口，没有实现<strong>Deque</strong>接口。</p>
<blockquote>
<p><strong>关于 RandomAccess 接口的作用？</strong></p>
<p>我们在源码中可以看到， RandomAccess 接口没有定义任何方法，相当于一个标识</p>
<p>只要集合中实现这个接口，就能支持快速随机访问，那什么是快速随机访问呢？</p>
<p>通过查看 Collections类中的binarySearch() 方法</p>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210725152536103.png" alt="Collections类中的binarySearch() 方法"></p>
<p>这两个方法有什么区别呢？</p>
<p>首先判断传入的list是否为 RandomAccess 的实例</p>
<p>实现 RandomAccess 接口的List集合采用一般的<strong>for循环遍历</strong>，而未实现这接口则采用<strong>迭代器</strong>。</p>
</blockquote>
<p><strong>结论：</strong>RandomAccess接口是支持快速随机访问的一个标识，有这个标识用for循环效率会更高。</p>
<p> （1）如果有实现 RandomAccess接口，在遍历该集合时采用for循环效率会更高。</p>
<p>（2）如果没有实现 RandomAccess接口，那么在遍历该集合时采用Iterator迭代器的效率会更高一些。</p>
<h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p><strong>ArrayList的主要成员变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//数组默认初始容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空的数组实例以供其他需要用到空数组的地方调用 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//定义一个空数组，跟前面的区别就是这个空数组是用来判断ArrayList第一添加数据的时候要扩容多少。默认的构造器情况下返回这个空数组 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//数据存的地方它的容量就是这个数组的长度，同时只要是使用默认构造器（DEFAULTCAPACITY_EMPTY_ELEMENTDATA ）第一次添加数据的时候容量扩容为DEFAULT_CAPACITY = 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//当前数组的长度</span></span><br></pre></td></tr></table></figure>

<p><strong>ArrayList有三种构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始容量大小</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//默认无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带初始容量参数的构造函数,(用户可以在创建ArrayList对象时自己指定集合的初始大小)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个包含指定集合的元素的列表</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>以<strong>无参数构造方法</strong>创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个<strong>空数组</strong>。当真正对数组进行<strong>添加元素操作</strong>时，才真正分配容量。<strong>即向数组中添加第一个元素时，数组容量扩为 10</strong>。</p>
<p>1.<strong>以默认构造函数为例</strong>，将elementData赋值为Object类型的空数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.调用add()方法，尝试添加一个元素，进入<code>ensureCapacityInternal(size + 1)</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指定的元素追加到此列表的末尾。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;  <span class="comment">//等价于elementData[size] = e; size++;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2.此时的minCapacity = 1（因为最开始是空数组，size = 0，size + 1 = 1），进入if语句中，minCapcity = Max.math(10, 1) , 所以 minCapcity在添加完第一个元素后变成了10，接着进入ensureExplicitCapacity(minCapacity); </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.此时的elementData.length = 0(因为还没有真正的向elementData数组中添加元素)，minCapcity = 10，进入grow函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity); <span class="comment">//第一次调用grow方法，minCapcity的值是10</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>4.在grow函数中，<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>这句话很重要，说明了新容量是旧容量的1.5倍，经过第一个元素的添加后newCapcity = 10，<code>elementData = Arrays.copyOf(elementData, newCapacity);</code>这句话将原数组扩充到新容量这么大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>5.以上就是第一个元素添加的过程，<strong>在添加第二个元素</strong>时进入 ensureExplicitCapacity 函数中，因为判断条件不满足（此时mincapcity = size + 1 = 2 ， 而elementData.length = 10），不会进入grow函数，也就不会扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br></pre></td></tr></table></figure>



<p>6.添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p>
<p>直到添加<strong>第 11 个元素</strong>，minCapacity (为 11) 比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p>
<p>newCapcity为原来的1.5倍，大小为15，数组容量也从10扩充为15，不会进入hugeCapacity(minCapacity);方法中</p>
<blockquote>
<p><strong>关于扩容newCapcity扩容为1.5倍的准确说法</strong>：</p>
<p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) **,  所以 ArrayList 每次扩容之后容量都会变为原来的 **1.5 倍左右</strong>（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。<strong>如果是奇数的话会丢掉小数.</strong></p>
</blockquote>
<blockquote>
<p>关于<code>hugeCapacity(minCapacity);</code>函数：</p>
<p>感觉这部分代码有点多余，那段的代码实际意思就是：只要minCapcity大于MAX_ARRAY_SIZE（即Integer.MAX_VALUE - 8），minCapcity = Integer.MAX_VALUE</p>
</blockquote>
<blockquote>
<p><code>length()</code>  、 <code>length</code>  、<code>size()</code>    三者的比较</p>
<p>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.(相当于数组大小)</p>
<p>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</p>
<p>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!（相当于元素多少）</p>
</blockquote>
<h3 id="扩容机制总结一下："><a href="#扩容机制总结一下：" class="headerlink" title="扩容机制总结一下："></a>扩容机制<strong>总结一下：</strong></h3><p>四个关键属性、四个关键方法。当然默认构造函数和提供初始容量的构造函数有略微区别</p>
<p>几个重要的属性：elementData数组、minCapcity、oldCapcity、newCapcity</p>
<p>几个重要的方法：add() -&gt; ensureCapacityInternal() -&gt; ensureExplicitCapacity() -&gt; <strong>grow()</strong></p>
<ul>
<li>调用add就会进入ensureCapcityInternal，就会进入ensureExplicitCapcity，但要扩容才会进入grow，否则不会进入grow。</li>
<li>oldCapcity = elementData.length,也就是没有扩容之前的长度。newCapcity = oldCapcity 的1.5倍。接着扩容到newCapcity的长度</li>
<li>以<strong>无参数构造方法</strong>创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个<strong>空数组</strong>。<strong>向数组中添加第一个元素时，数组容量扩为 10</strong>。</li>
<li>接着添加的第11个元素的时候发生扩容，容量由10变为10+ 10&gt;&gt;1 =15；添加到第16个元素的时候，容量由15变为15 + 15&gt;&gt;1 = 22。由此可见并不是完全的1.5倍。</li>
</ul>
<h3 id="ArrayList-和-Vector-的区别？（3个）"><a href="#ArrayList-和-Vector-的区别？（3个）" class="headerlink" title="ArrayList 和 Vector 的区别？（3个）"></a>ArrayList 和 Vector 的区别？（3个）</h3><p>相同点：</p>
<ul>
<li>都实现了list接口</li>
<li>底层都用数组存储</li>
</ul>
<p>不同点：</p>
<ul>
<li><strong>线程安全</strong>：vector使用了synchronized来实现线程同步，所以是线程安全的，而ArrayList是线程不安全的。</li>
<li><strong>性能</strong>：由于vector使用了synchronized进行加锁，所以性能不如ArrayList.</li>
<li><strong>扩容机制</strong>：ArrayList每次扩容为旧容量的<strong>1.5倍</strong>，而vector每次扩容为旧容量的<strong>2倍</strong>。</li>
</ul>
<h3 id="ArrayList-和-LinkedList-的区别？（3个）"><a href="#ArrayList-和-LinkedList-的区别？（3个）" class="headerlink" title="ArrayList 和 LinkedList 的区别？（3个）"></a>ArrayList 和 LinkedList 的区别？（3个）</h3><p>1、<strong>底层数据结构</strong>：Arraylist 底层使用的是 <strong>Object数组</strong>；LinkedList底层使用的是<strong>双向链表</strong>（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p>2、<strong>是否支持快速随机访问</strong>：ArrayList实现了RandomAccess接口，支持快速随机访问，而LinkedList没有实现这个接口不支持。快速随机访问就是get()方法，通过元素的序号快速获取元素对象。</p>
<p>3、<strong>查找和插入的效率</strong>：</p>
<p>List 是集合列表接口，ArrayList 和 LinkedList 都是 List 接口的实现类。</p>
<p>ArrayList 是动态数组顺序表，顺序表的存储地址是连续的，所以<strong>查找比较快，但是插入和删除时由于需要把其它的元素顺序移动，所以比较耗时。</strong></p>
<p>LinkedList 是双向链表的数据结构，同时实现了双端队列 Deque 接口，链表节点的存储地址是不连续的，每个存储地址通过指针关联，在<strong>查找时需要进行指针遍历节点</strong>，所以<strong>查找比较慢，而在插入和删除时比较快。</strong></p>
<h3 id="LinkedList源码介绍"><a href="#LinkedList源码介绍" class="headerlink" title="LinkedList源码介绍"></a><strong>LinkedList源码介绍</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到 LinkedList 实现了<strong>Deque</strong>，可以作为一个双端队列，实现了<strong>Cloneable接口</strong>，能被克隆，实现了<strong>Serializable接口</strong>，因此它支持序列化，能够通过序列化传输。</p>
<p>LinkedList类中有一个内部私有类Node，这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//分别:前驱节点，本节点的值，后继节点</span></span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.item = element;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210725115825089.png" alt="LinkedList结构图 -- 双向链表"></p>
<h2 id="Collection子接口之Set"><a href="#Collection子接口之Set" class="headerlink" title="Collection子接口之Set"></a>Collection子接口之Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p>1、<strong>Comparable接口</strong>出自java.lang包，它有一个<strong>compareTo（object obj）</strong>方法用来排序</p>
<p>2、<strong>Comparator接口</strong>出自java.util包，它有一个<strong>compare（Object obj1，Object obj2）</strong>方法用来排序</p>
<p>1.实现Comparable接口来排序，需要重写接口中的compareTo方法，像String类和Integer类已经实现了Comparable接口，如果我们自定义一个类的话，需要手动实现接口，并重写方法</p>
<blockquote>
<p><code>compareTo():</code></p>
<p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p>
<p>升序： o1.compareTo(o2)     降序： o2.compareTo(o1)</p>
</blockquote>
<p>2.Comparator定制排序，具体使用见<a href="D:\Blog\source_posts\实现Comparator接口来排序.md">实现Comparator接口来排序</a></p>
<h3 id="HashSet的底层实现原理"><a href="#HashSet的底层实现原理" class="headerlink" title="HashSet的底层实现原理"></a>HashSet的底层实现原理</h3><p>HashSet底层是<strong>基于HashMap实现的，</strong>所有放入 HashSet 中的元素保存在 HashMap 的 key 中，而 HashMap 的 value 存储了一个静态的Object对象，叫做PRESENT。默认构造函数是构建一个初始容量为16，负载因子为0.75的HashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"> 	<span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet如何检查重复？"><a href="#HashSet如何检查重复？" class="headerlink" title="HashSet如何检查重复？"></a>HashSet如何检查重复？</h3><p>HashSet是基于HashMap实现的，元素的值存储在key上，value的值所有元素都一样，都是这个 <code>private static final Object PRESENT = new Object();</code></p>
<p>HashSet在添加一个元素时（比如此时添加的是”a”这个元素），都会将该元素与set中所遍历到的每个元素作比较，比较的过程是这样的：</p>
<p>先用该元素的hashCode值与遍历到的每个元素的hashCode作比较，如果hashCode不相等，则直接添加；若hashCode的值一样，则继续用该元素的equals()方法比较（是被添加的equals()方法，与之比较的元素作为参数），如果equals()方法得到的值是一样的，说明两个元素是相通的则不再添加，如果equals()的值是不一样的，就会将该对象添加到其他内存地址（重新计算出不一样的hashCode）。</p>
<h3 id="比较HashSet，LinkedHashSet和TreeSet三者的异同"><a href="#比较HashSet，LinkedHashSet和TreeSet三者的异同" class="headerlink" title="比较HashSet，LinkedHashSet和TreeSet三者的异同"></a>比较HashSet，LinkedHashSet和TreeSet三者的异同</h3><p>如需要详细理解源码，看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/a724888/article/details/80295328">Java集合详解7：HashSet，TreeSet与LinkedHashSet</a> 这篇文章</p>
<p>HashSet与LinkedHashSet都是基于Set接口的实现类。TreeSet是Set的子接口SortedSet的实现类。Set接口及其子接口、实现类的结构如下所示：</p>
<p>Set接口</p>
<p>​        |——SortedSet接口——TreeSet实现类</p>
<p>​        |——HashSet实现类         </p>
<p>​        |——LinkedHashSet实现类</p>
<p><strong>1.HashSet</strong></p>
<p>底层基于<strong>HashMap</strong>实现的，使用HashMap保存所有元素，我们加入进去的元素相当于HashMap中的Key，所有的Value都是相同的。</p>
<p>1.HashSet中不能有相同的元素，可以有一个Null元素，存入的元素是<strong>无序</strong>的。</p>
<p>2.HashSet如何保证唯一性？</p>
<p>1).HashSet底层数据结构是哈希表，哈希表就是存储唯一系列的表，而哈希值是由对象的hashCode()方法生成。</p>
<p>2).确保唯一性的两个方法：hashCode()和equals()方法。</p>
<p>3.非线程安全</p>
<p><strong>2.LinkedHashSet</strong></p>
<p> LinkedHashSet底层使用 <strong>LinkedHashMap</strong> 来保存所有元素，继承了 HashSet，其所有的方法操作上又与 HashSet 相同</p>
<p>1.LinkedHashSet中不能有相同元素，可以有一个Null元素，是有序的，也就是说当遍历该集合时候，LinkedHashSet将会按照元素的添加顺序访问集合的元素。</p>
<p>2.LinkedHashSet如何保证有序和唯一性？</p>
<p>1).底层数据结构由哈<strong>希表和链表</strong>组成。</p>
<p>2).<strong>链表保证了元素的有序性</strong>，哈希表保证了元素的唯一性。</p>
<p>3.非线程安全</p>
<p><strong>3.TreeSet</strong></p>
<p>若想了解TreeSet中自然排序和定制排序，看这篇文章 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lixiaolun/archive/2012/12/25/2832775.html">Tree自然排序和定制排序</a></p>
<p>1.TreeSet中不能有相同元素，<strong>不可以有Null元素</strong>（与前两个的区别），不可以放入两个类型不相同的元素，根据元素的<strong>自然顺序</strong>进行排序。</p>
<p>2.如果要将一个类的对象放入TreeSet中，这个类必须要实现Comparable接口，TreeSet会调用对象的comparaTo方法进行比较，没有实现这个接口，则会出现ClassCastException异常。</p>
<p>2.TreeSet如何保证元素的排序和唯一性？</p>
<p>底层的数据结构是红黑树(一种自平衡二叉查找树)</p>
<p>3.添加、删除操作时间复杂度都是O(log(n))</p>
<p>4.非线程安全</p>
<p>一个对象如果放到TreeSet中，必然会实现Comparable接口，实现Comparable的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比 较大小，TreeSet中有个比较大小的东西，两个不同种类的对象就不能比较大小啦。</p>
<blockquote>
<p> <strong>TreeSet的自然排序：</strong></p>
<p> TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间大小关系，然后将集合元素按升序排列，这种方式就是自然排序。</p>
</blockquote>
<p><strong>总结：</strong><br>通过以上特点可以分析出，三者都保证了元素的唯一性，如果无排序要求可以选用HashSet；如果想取出元素的顺序和放入元素的顺序相同，那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>主要有四个实现类：HashMap、HashTable、TreeMap、LinkedHashMap（继承HashMap）</p>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20211019163650245.png" alt="Map接口"></p>
<h3 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h3><p><strong>HashMap简介</strong></p>
<p>HashMap位于java.util目录下。 HashMap是一个哈希表，存储的内容是&lt;key,value&gt;键值对。它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度。</p>
<p>HashMap继承于AbstractMap，实现了Map、Cloneable、Serializable接口 ，HashMap是线程不安全的，其中key、value都可以为null，且是无序的，但 null 作为键只能有一个，null 作为值可以有多个。</p>
<p><strong>JDK1.8 之前</strong> HashMap 由 <strong>数组+链表</strong> 组成的，数组是 HashMap 的主体，链表则是主要为了解决<strong>哈希冲突</strong>而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于8并且数组的长度大于等于64时，将链表转化为红黑树，以减少搜索时间。</p>
<p><code>HashMap</code> 默认的初始化大小为 16。每次扩容，容量变为原来的 2 倍。并且， <code>HashMap</code> 的大小总是2的n次方</p>
<blockquote>
<p>二叉搜索树（也叫二叉排序树）：对于二叉搜索树上的节点，每个节点的左子树都比它小，右子树都比它大。</p>
<p>平衡二叉树（一种特殊的二叉搜索树）：平衡二叉树上的每个节点左子树和右子树的深度小于等于1</p>
<p>红黑树（也是一种特殊的二叉搜索树）：要求没有平衡二叉树那么严，每个节点分为红色和黑色，根节点和叶子节点都是黑色，每个红色节点的两个子节点都是黑色。</p>
<p>三者总结：平衡二叉树树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。</p>
<p><strong>为什么有了平衡二叉树还要有红黑树</strong>？</p>
<p>因为平衡树要求<strong>每个节点的左子树和右子树的高度差至多等于1</strong>，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</p>
<p>显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了<strong>红黑树</strong></p>
</blockquote>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p><strong>HashMap底层数据结构是什么？</strong></p>
<p>在JDK1.7 和JDK1.8 中有所差别：</p>
<ul>
<li>在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的，使用“拉链法”来解决哈希冲突。拉链法就是如果两个节点计算的</li>
</ul>
<blockquote>
<p>解决哈希冲突的算法：<strong>拉链法</strong>、<strong>开放定址法</strong>（用函数计算索引位置，冲突了采用线性探测一直往后找空位）</p>
</blockquote>
<ul>
<li>在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是的 O(n)。</li>
</ul>
<p>链表和红黑树在达到一定条件会进行转换：</p>
<ul>
<li>当链表长度 &gt; 8 且 数组长度 &gt;= 64，链表会转换成红黑树</li>
<li>当红黑树中节点个数 &lt; 6 ，红黑树又会退化成链表</li>
</ul>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20211019211906322.png" alt="链表和红黑树转换"></p>
<p><strong>为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</strong></p>
<p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，如果一开始就用红黑树结构，元素太少，新增节点效率比较慢，所以开始用链表；而当元素大于 8 个的时候， 因为红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度。</p>
<p><strong>不用红黑树，用二叉查找树可以么?</strong></p>
<p>可以。但是二叉查找树在特殊情况下会变成一条线性结构，这就跟原来使用链表结构一样了，遍历查找会非常慢。</p>
<p><strong>为什么链表改为红黑树的阈值是 8，红黑树退化为链表的阈值是6?</strong> </p>
<p>这个其实在HashMap源码的注释中有提到。</p>
<p>根据泊松分布，在负载因子默认为0.75的时候，单个hash桶中链表元素个数为8的概率小于百万分之一，已经非常小了，阈值再高就没什么必要了。</p>
<p>红黑树退化为链表的阈值是6是因为，如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的互相转化，为了预防这种情况的发生。</p>
<h4 id="字段结构"><a href="#字段结构" class="headerlink" title="字段结构"></a>字段结构</h4><p>HashMap中一些重要属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">int</span> threshold;             <span class="comment">// 容纳键值对的最大值，大于这个值就要进行扩容</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line">   <span class="keyword">int</span> modCount;  			<span class="comment">//记录HashMap内部结构发生变化的次数，主要用于快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</span></span><br><span class="line">   <span class="keyword">int</span> size;                  <span class="comment">//HashMap中实际存在的键值对数量</span></span><br><span class="line">Node[] table;              <span class="comment">//Node数组，一个Node就是一个哈希桶，用来存数据</span></span><br></pre></td></tr></table></figure>

<p>Node[] table的初始化长度length(默认值是16)，Load factor为<strong>负载因子</strong>(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值，超过这个数目就要<strong>resize(扩容)**，扩容后的HashMap容量是之前容量的</strong>两倍**。也就是说当键值对个数超过12，数组长度由16扩容为32。</p>
<p>有这样的关系：*<em>threshold = length * Load factor*</em>。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>默认的loadFactor是0.75，0.75是对空间和时间效率的一个平衡，一般不要修改，除非在时间和空间比较特殊的情况下 ：</p>
<ul>
<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值 。</li>
<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li>
</ul>
<p>HashMap是用哈希表来存储的。哈希表中存储的是一个个Node，即&lt;K,V&gt;键值对。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="索引计算（3步）"><a href="#索引计算（3步）" class="headerlink" title="索引计算（3步）"></a>索引计算（3步）</h4><p><strong>HashMap 中 key 的存储索引是怎么计算的？（哈希函数是如何计算的？）</strong></p>
<p>在JDK1.7中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.7</span></span><br><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode(); <span class="comment">// 1.取hashCode值</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>); </span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>); <span class="comment">//2.对得到的hashCode进行了四次位运算和四次异或，得到hash值</span></span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但实现原理一样</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//3.取模运算（哈希值对数组长度取模）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JDK1.8中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk1.8</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   </span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     h = key.hashCode() 为第一步：取hashCode值</span></span><br><span class="line"><span class="comment">     h ^ (h &gt;&gt;&gt; 16)  为第二步：高位参与运算</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 Hash 算法本质上就是三步：<strong>取key的 hashCode 值、根据 hashcode 计算出hash值、通过取模计算下标</strong>。其中，JDK1.7和1.8的不同之处，就在于第二步。</p>
<p>其实第二步就是hashCode()高16位和低16位异或。第三步就是取模（对长度取余数）。</p>
<p>我们以JDK1.8为例，看看具体的计算过程</p>
<img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTc0NTcx,size_16,color_FFFFFF,t_70.png" alt="hash算法过程"  />

<p><strong>hash函数能不能直接用key的hashCode？</strong></p>
<p>不能，从hashCode函数的定义出发。</p>
<p>hashcode()返回int类型散列值，哈希值范围太大，不可能在内存中建立这么大的数组。</p>
<p><strong>JDK1.8 为什么要 hashcode 异或其右移十六位的值？（即hashcode高16位异或低16位）</strong></p>
<p>从程序性能上和下标随机程度上两方面</p>
<ul>
<li>因为在JDK 1.7 中hashcode右移了 4 次异或了4次，而JDK1.8只有一次，从性能上来看这样会更好些</li>
<li>用hashCode()的高16位异或低16位实现，让高位和低位都参与到Hash的计算中，在数组table的length比较小的时候，更能保证计算下标的随机性。</li>
</ul>
<p><strong>为什么 hash 值要与length-1按位与？</strong></p>
<ul>
<li>把 hash 值对数组长度取模运算，模运算的消耗很大，没有位运算快。</li>
<li>当 length 总是 2 的n次方时，h&amp; (length-1) 运算等价于对length取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。</li>
</ul>
<p><strong>HashMap数组的长度为什么是 2 的幂次方？</strong>（待完善）</p>
<p>这样做效果上等同于取模，在速度、效率上比直接取模要快得多。除此之外，2 的 N 次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空间不浪费。</p>
<p><strong>如果我们指定了HashMap初始长度的大小，会有什么变化？</strong></p>
<p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。<strong>会取大于或等于这个数的 且最近的2次幂作为 table 数组的初始容量</strong>，使用<code>tableSizeFor(int)</code>方法，如 tableSizeFor(10) = 16（2 的 4 次幂），tableSizeFor(20) = 32（2 的 5 次幂）</p>
<h4 id="put方法流程"><a href="#put方法流程" class="headerlink" title="put方法流程"></a>put方法流程</h4><p><strong>HashMap 的put方法流程？</strong></p>
<p>简要流程如下：</p>
<ol>
<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>
<li>如果数组是空的，则调用 resize 进行初始化；</li>
<li>如果没有哈希冲突直接放在对应的数组下标里；</li>
<li>如果冲突了，且 key 已经存在，就覆盖掉 value；</li>
<li>如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</li>
<li>如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</li>
</ol>
<img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/v2-22ad271660f124de749950ca1916fbb5_1440w.jpg" alt="put方法流程图" style="zoom: 80%;" />



<p><strong>JDK1.7 和1.8 的put方法区别是什么？</strong></p>
<ul>
<li><p>解决哈希冲突时，JDK1.7 只使用链表，JDK1.8 使用链表+红黑树，当满足一定条件，链表会转换为红黑树。</p>
</li>
<li><p>链表插入元素时，<strong>JDK1.7 使用头插法</strong>插入元素，在<strong>多线程</strong>的环境下有可能导致<strong>环形链表</strong>的出现，扩容的时候会导致死循环。因此，<strong>JDK1.8使用尾插法</strong>插入元素，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了，但JDK1.8 的 HashMap 仍然是<strong>线程不安全</strong>的。</p>
</li>
</ul>
<h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>Hashmap 在容量超过负载因子所定义的容量之后，就会将 Hashmap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。主要是使用了resize()方法。</p>
<p><strong>扩容的具体步骤是什么？</strong></p>
<p>为了方便理解，先来看下JDK1.7 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">        Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">            threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">        transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">        table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                    e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                    newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                    e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>newTable[i] 的引用赋给了 e.next ，也就是使用了单链表的头插入方式，同一位置上后放上去的元素会被放在链表的头部位置；最开始元素会被放到 Entry 链的尾部(如果发生了 hash 冲突的话）。</p>
<p><strong>JDK1.8做了两处优化：</strong></p>
<p>1、扩容的时候JDK1.7需要对原数组中的元素重新进行hash计算，定位其在新数组的位置（相当于重做第二步第三步），JDK1.8采用更简单的判断逻辑，不需要重新计算hash（重做第三步），原数组中元素位置只有两种可能：<strong>位置不变 **或 **索引+旧容量大小</strong>；</p>
<p>扩容前长度为16，用于计算(n-1) &amp; hashcode 的二进制n-1为0000 1111，扩容为32后的二进制就高位多了1，为0001 1111。   （n-1位与上hashcode 就是 直接截取hashcode的后几位，因为n-1的二进制前面全是0，后面全是1）</p>
<p>因为是&amp; 运算，1和任何数 &amp; 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；</p>
<p>第五位高位为0，重新hash数值不变；第五位为1，重新hash数值比原来大16（旧数组的容量）</p>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nd2FuZ3p3,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>2、JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置（头插法）。JDK1.8 不会倒置，使用尾插法。</p>
<p>下图为 16扩充为 32 的 resize 示意图：</p>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/v2-42064a0899ee6ccf20e57880ab9b7592_1440w.jpg" alt="img"></p>
<h4 id="并发安全性"><a href="#并发安全性" class="headerlink" title="并发安全性"></a>并发安全性</h4><p><strong>HashMap不是线程安全的。</strong></p>
<p>JDK1.7的 hashMap遇到hash冲突采用的是头插法，在多线程情况下<strong>会存在死循环</strong>问题。</p>
<p>但JDK1.8已经改成了尾插法，不存在这个问题了。但需要注意的是JDK1.8中的HashMap仍然是不安全的。</p>
<p>JDK1.8 中会有<strong>数据覆盖</strong>的问题，以1.8为例，当A线程判断index位置为空后阻塞，这时B线程开始往index位置的写入节点数据，这时A线程恢复开始执行，进行赋值操作，就把B线程的数据给覆盖了；</p>
<p><strong>如何解决HashMap线程不安全的问题？</strong></p>
<ul>
<li>使用Hashtable，它是直接在方法上加synchronized关键字，锁的粒度比较大。</li>
<li>使用Collections工具类下的synchronizedMap类，它是Collections工具类的内部类，通过传入Map封装出一个SynchronizedMap对象，用的是同步代码块的方式，效率不高。</li>
<li>使用ConcurrentHashMap，它使用分段锁，降低了锁粒度，让并发度大大提高。</li>
</ul>
<p>具体参见ConcurrentHashMap的实现原理</p>
<h4 id="其他的一些注意点"><a href="#其他的一些注意点" class="headerlink" title="其他的一些注意点"></a>其他的一些注意点</h4><p><strong>key 可以为 Null 吗?</strong></p>
<p>可以，key 为 Null 的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</p>
<p><strong>一般用什么作为HashMap的key?</strong></p>
<p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>
<ul>
<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</li>
<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li>
</ul>
<p><strong>用可变类当 HashMap 的 key 有什么问题?</strong></p>
<p>hashcode 可能发生改变，导致 put 进去的值，无法 get 出。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Object objectValue = <span class="keyword">new</span> Object();</span><br><span class="line">changeMap.put(list, objectValue);</span><br><span class="line">System.out.println(changeMap.get(list));</span><br><span class="line">list.add(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//hashcode发生了改变</span></span><br><span class="line">System.out.println(changeMap.get(list));</span><br></pre></td></tr></table></figure>

<p>输出值如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@74a14482</span><br><span class="line">null</span><br></pre></td></tr></table></figure>



<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>简单来说：<strong>LinkedHashMap = HashMap + 双向链表</strong></p>
<p>LinkedHashMap<strong>继承自HashMap</strong>，它的多种操作都是建立在HashMap操作的基础上的。同HashMap不同的是，LinkedHashMap<strong>维护了一个Entry的双向链表</strong>，Entry继承HashMap的Node类，新增了before 和 after用于标识前置节点和后置节点。可以实现<strong>按插入的顺序访问</strong>。</p>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDUwNTg2,size_16,color_FFFFFF,t_70.png" alt="LinkedHashMap"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LinkedHashMap继承了HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedHashMap节点用Entry来标识，继承了HashMap的Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;安琪拉&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;的&quot;</span>);</span><br><span class="line">  map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;博客&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(Map.Entry&lt;String,String&gt; item: map.entrySet())&#123;</span><br><span class="line">    System.out.println(item.getKey() + <span class="string">&quot;:&quot;</span> + item.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console输出，按插入顺序返回</span></span><br><span class="line"><span class="number">1</span>:安琪拉</span><br><span class="line"><span class="number">2</span>:的</span><br><span class="line"><span class="number">3</span>:博客</span><br></pre></td></tr></table></figure>



<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>与HashMap相比，TreeMap是一个能比较元素大小的Map集合，会对传入的key进行了大小排序。其中，可以按照key的自然顺序排序，或者自定义一个实现了Comparator接口的比较器。</p>
<p>不同于HashMap的哈希映射，TreeMap实现了<strong>红黑树</strong>的结构，</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>HashtabTe的底层数据结构是<strong>数组+链表</strong>，链表主要是为了解决哈希冲突，并且整个数组都是synchronized修饰的，所以Hashtable是线程安全的，但锁的粒度太大，操作效率很低。</p>
<p>官方不建议使用Hashtable，建议在多线程环境下使用ConcurrentHashMap类。</p>
<p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20211020104206090.png" alt="image-20211020104206090"></p>
<h3 id="HashMap和Hashtable的区别-5个区别"><a href="#HashMap和Hashtable的区别-5个区别" class="headerlink" title="HashMap和Hashtable的区别(5个区别)"></a>HashMap和Hashtable的区别(5个区别)</h3><p>1.<strong>线程是否安全</strong>：HashMap是<strong>线程不安全</strong>的，HashTable是<strong>线程安全</strong>的，因为HashTable内部的方法基本<strong>都经过synchronized修饰</strong>。（如果你要保证线程安全的话就使用<strong>ConcurrentHashMap</strong>吧！）；</p>
<p>2.<strong>效率</strong>：因为线程安全的问题，<strong>HashMap要比HashTable效率高一点</strong>。另外，<strong>HashTable基本被淘汰</strong>，不要在代码中使用它；<br>3.<strong>对Null key和Null value的支持</strong>：HashMap的键和值都可以为null，但null作为键只能有一个，null作为值可以有多个；HashTable<strong>的键和值都不能为null</strong>，否则会抛出空指针异常</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap的hash计算方法，如果key为null，hashCode值为0.</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hashtable的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// put方法一进来就会先判断value是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode(); <span class="comment">//null不能调用hashCode方法，会报空指针异常</span></span><br></pre></td></tr></table></figure>

<p>hashCode方法：是一个native方法，本地方法，用 <code>C/C++</code> 语言实现，由 Java 调用。</p>
</blockquote>
<p>4.<strong>初始容量大小和每次扩充容量大小的不同</strong>：</p>
<p>①创建时<strong>如果不指定容量初始值</strong>，Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1，HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。</p>
<p>②创建时<strong>如果给定了容量初始值</strong>，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小（HashMap中的tablesizeFor（）方法保证，下面给出了源代码）。也就是说HashMap总是使用2的幂作为哈希表的大小、后面会介绍到为什么是2的幂次方。</p>
<p>5.<strong>底层实现结构不一样</strong></p>
<h3 id="HashMap、ConcurrentHashMap及Hashtable的区别"><a href="#HashMap、ConcurrentHashMap及Hashtable的区别" class="headerlink" title="HashMap、ConcurrentHashMap及Hashtable的区别"></a>HashMap、ConcurrentHashMap及Hashtable的区别</h3><p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20211020104457484.png" alt="image-20211020104457484">                         </p>
<h3 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h3><p>HashSet底层就<strong>是基于HashMap实现的</strong>。（HashSet的源码非常非常少，因为除了<code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code> 是HashSet自己实现之外，其他方法都是<strong>直接调用HashMap中的方法。</strong></p>
<p>以HashSet的 get方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet中的add方法，直接调用HashMap中的put方法来实现的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210727105418705.png" alt="HashMap和HashSet比较" style="zoom: 80%;" />



<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>JDK1.7底层是ReentrantLock + Segment + HashEntry，JDK1.8底层是synchronized + CAS +链表/红黑树<br>JDK1.7采用的是分段锁，同时锁住几个HashEntry，JDK1.8锁的是Node节点，只要没有发生哈希冲突，就不会产生锁的竞争。所以JDK1.8相比于JDK1.7提供了一种粒度更小的锁，减少了锁的竞争，提高了concurrentHashMap的并发能力。</p>
<h3 id="HashMap有哪几种常见的遍历方式？"><a href="#HashMap有哪几种常见的遍历方式？" class="headerlink" title="HashMap有哪几种常见的遍历方式？"></a>HashMap有哪几种常见的遍历方式？</h3><p>HashMap 遍历从大的方向来说，可分为<strong>以下 4 类</strong>：</p>
<ol>
<li>迭代器（Iterator）方式遍历；  2种</li>
<li>For Each 方式遍历；   2种</li>
<li>Lambda 表达式遍历（JDK 1.8+）    1种</li>
<li>Streams API 遍历（JDK 1.8+）  2种      </li>
</ol>
<p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为<strong>以下 7 种</strong>：</p>
<ol>
<li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li>
<li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li>
<li>使用 For Each EntrySet 的方式进行遍历；</li>
<li>使用 For Each KeySet 的方式进行遍历；</li>
<li>使用 Lambda 表达式的方式进行遍历；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>6.使用 Streams API 单线程的方式进行遍历；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    *<span class="comment">// 创建并赋值 HashMap*</span></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">    *<span class="comment">// 遍历*</span></span><br><span class="line">    map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">      System.out.print(entry.getKey());</span><br><span class="line">      System.out.print(entry.getValue());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="7">
<li><p>使用 Streams API 多线程的方式进行遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    *<span class="comment">// 创建并赋值 HashMap*</span></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">    *<span class="comment">// 遍历*</span></span><br><span class="line">    map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">      System.out.print(entry.getKey());</span><br><span class="line">      System.out.print(entry.getValue());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p><strong>Collections工具类常用方法：</strong></p>
<p>1、排序<br>2、查找，替换操作<br>3、同步控制（不推荐，需要线程安全的集合类型时请考虑使用JUC包下的并发集合）</p>
<p><strong>排序操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list，Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list，<span class="keyword">int</span> i，<span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list，<span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后</span></span></span><br></pre></td></tr></table></figure>



<p><strong>查找,替换操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarysearch</span><span class="params">(List list，Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll，Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll，Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list，Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c，object o)</span><span class="comment">//统计元素出现次数int indexOfSublist(List list，List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source，list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>，用新元素替换旧元素</span></span><br></pre></td></tr></table></figure>



<p><strong>同步控制</strong></p>
<p>Collections提供了多个<code>synchronizedxxx</code>方法，该方法可以<strong>将指定集合包装成线程同步的集合</strong>，<strong>从而解决多线程并发访问集合时的线程安全问题。</strong><br>我们知道HashSet，TreeSet，Arraylist，LinkedList，HashMap，TreeMap都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。<br><strong>最好不要用下面这些方法，效率非常低，</strong>需要线程安全的集合类型时请考虑使用 JUC包 下的并发集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt; c)<span class="comment">//返回指定collection支持的同步（线程安全的）collection.</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List.</span></span><br><span class="line">synchronizedMap(Map&lt;k，v&gt; m)<span class="comment">//返回由指定映射支持的同步（线程安全的）Map.</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s)<span class="comment">//返回指定set支持的同步（线程安全的）set.</span></span><br></pre></td></tr></table></figure>



<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="什么是快速失败-fail-fast-？"><a href="#什么是快速失败-fail-fast-？" class="headerlink" title="什么是快速失败(fail-fast)？"></a>什么是快速失败(fail-fast)？</h3><p>快速失败（fail-fast）是Java集合框架中的一种错误检测机制，当多个线程同时对集合中的内容进行修改时可能就会抛出concurrentModificationException异常。不仅仅是在多线程状态下，在单线程中一边使用增强for循环遍历集合，一边修改集合的元素也会抛出concurrentModificationException异常。看下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="number">1</span>);</span><br><span class="line">       list.add(<span class="number">2</span>);</span><br><span class="line">       list.add(<span class="number">3</span>);</span><br><span class="line">       <span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">           list.remove(i);    <span class="comment">//运行时抛出ConcurrentModificationException异常</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p>正确的做法是用迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       list.add(<span class="number">1</span>);</span><br><span class="line">       list.add(<span class="number">2</span>);</span><br><span class="line">       list.add(<span class="number">3</span>);</span><br><span class="line">       Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">       <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">           iterator.next();   <span class="comment">//要使用remove方法，必须先使用next方法。</span></span><br><span class="line">		   iterator.remove();    <span class="comment">//正常删除</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p><strong>为什么使用增强for循环会失败，而使用iterator不会失败呢？</strong></p>
<p><strong>原理</strong>：主要与modCount和expectedModCount这两个变量有关系。在ArrayList源码里面，基本上所有方法中都有一个checkForComodification()方法，都会<strong>检测 modCount 变量是否等于 expectedmodCount 值</strong>，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>增强for循环iterator的remove()方法内部不一样。</p>
<p>在增强for循环的remove中，只有modCount++，而expectedModcount没有操作，所以两者并不相等会抛出异常。</p>
<p>而在iterator的remove中，有一段代码<code>expectedModcount = modcount</code>，保证了两者相等，不会抛出异常。</p>
<p><strong>多线程下使用iterator为什么也会抛出异常呢？</strong></p>
<p>根本原因还是<strong>modCount变量不等于 expectedModCount</strong> 。</p>
<p>答案是在多线程的情况下即使用了迭代器调用remove（）方法，还是会报concurrentModificationException异常。这又是为什么呢？还是要从expectedModcount和modcount这两个变量入手分析，刚刚说了modCount在AbstractList类中定义，而expectedModcount在ArrayList内部类中定义，所以modcount是个共享变量而expectedmodcount是属于线程各自的。简单说，线程1更新了modcount和属于自己的expectedModcount，而在线程2看来只有modcount更新了，expectedModcount并未更新，所以会抛出concurrentModificationException异常。</p>
<p>两个线程使用的一个ArrayList，每个线程修改都会使modCount++，但是在每个线程内expectedModcount是独立的，只会等于本线程中的modCount。所以一旦调用方法时就会发生异常。</p>
<p><strong>场景：</strong>java.util 包下的集合类<strong>都是快速失败</strong>的，不能在多线程下发生并发修改（迭代过程中被修改）。</p>
<h3 id="什么是安全失败-fail-safe-呢？"><a href="#什么是安全失败-fail-safe-呢？" class="headerlink" title="什么是安全失败(fail-safe)呢？"></a>什么是安全失败(fail-safe)呢？</h3><p>采用安全失败机制的集合容器，<strong>在遍历时不是直接在集合内容上访问的，而是先把原有集合内容复制一份，在复制的集合上进行遍历。</strong>这样的话，在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发异常。</p>
<p><strong>原理：</strong>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</p>
<p><strong>缺点</strong> ：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p><strong>场景：</strong>JUC 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">pb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/25/java集合框架/">http://example.com/2021/07/25/java集合框架/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">pb</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">java集合框架</a></div><div class="social-share pull-right" data-disabled="google,twitter,facebook,douban,instagram,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/07/27/7-27java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>7.27java基础学习</span></a></div><div class="next-post pull-right"><a href="/2021/07/24/final-static-this-super-%E5%85%B3%E9%94%AE%E5%AD%97%E6%80%BB%E7%BB%93/"><span>final,static,this,super 关键字总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '52a38b388c08f769c0fe',
  clientSecret: '5428c9a58faaa3488201c1791496427b41deb385',
  repo: 'jiubukaiji.github.io',
  owner: 'jiubukaiji',
  admin: 'jiubukaiji',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By pb</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>