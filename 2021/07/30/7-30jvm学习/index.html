<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="7.30jvm学习"><meta name="keywords" content="JVM"><meta name="author" content="pb"><meta name="copyright" content="pb"><title>7.30jvm学习 | pb</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="pb" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是JVM内存结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F-%EF%BC%88JMM%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 什么是JVM内存模型？ （JMM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">JMM主内存工作内存介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E5%AE%9A%E4%B9%89%E4%BA%86%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%82"><span class="toc-number">2.2.</span> <span class="toc-text">JMM定义了原子性，可见性和有序性。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%848%E7%A7%8D%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">主内存工作内存的8种交互操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-heap-%E5%92%8Cstack-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. heap 和stack 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. 什么情况下会发生栈内存溢出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%B0%88%E8%B0%88%E5%AF%B9-OOM-%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%9F%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5-OOM-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B0%88%E8%B0%88-JVM-%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6. 谈谈 JVM 中的常量池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">java对象的创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F%EF%BC%88GC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">7. 如何判断一个对象是否存活？（GC对象的判定方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%A2%AB%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%83%BD%E5%AD%98%E6%B4%BB%E5%90%97%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">9. 被引用的对象就一定能存活吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Java%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">10. Java中的垃圾回收算法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">11. 有哪几种垃圾回收器，各自的优缺点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8BCMS%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%9FCMS%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">12. 详细说一下CMS的回收过程？CMS的问题是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8BG1%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">13. 详细说一下G1的回收过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-JVM%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84GC%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">14. JVM中一次完整的GC是什么样子的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E4%B8%83%EF%BC%89%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">15.0.1.</span> <span class="toc-text">（七）内存分配与回收策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Minor-GC-%E5%92%8C-Full-GC-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">15. Minor GC 和 Full GC 有什么不同呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">16. 介绍下空间分配担保原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">17. 什么是类加载？类加载的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">18. 什么是类加载器，常见的类加载器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">19. 什么是双亲委派模型？为什么需要双亲委派模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%93%E7%A0%B4%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">21.说一下 JVM 调优的命令？</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/111.jpg"></div><div class="author-info__name text-center">pb</div><div class="author-info__description text-center">This is my site</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pb</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">7.30jvm学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/">面试学习系列</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 41 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>jvm就硬背吧 （这10000字咋背呀^&gt;_&lt;^）</p>
</blockquote>
<a id="more"></a>

<p>面经知识点汇总：</p>
<p>hashmap、 hashtable、juc包下的东西concurrenthashmap</p>
<p>多线程：syn</p>
<p>操作系统：的线程和进程</p>
<p>jvm: gc、内存模型、类加载机制、jvm调优有哪些锁？</p>
<p>数据库：mysql和redis ，b和b+</p>
<p>算法：快排  、两个栈实现队列</p>
<p>linux：学了哪些命令？</p>
<p>设计模式：知道哪些？</p>
<p>有哪些锁？</p>
<hr>
<p>作者：牛客网<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/431895555/answer/1933089375">https://www.zhihu.com/question/431895555/answer/1933089375</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>这个并不一定所有公司都会问到，但为了确保万无一失，最好还是提前做好准备。这里分享一篇牛客大佬的<a href="https://link.zhihu.com/?target=https://www.nowcoder.com/discuss/627413">《面试小抄》之JVM篇21问与答</a>，帮助大家快速掌握JVM常考面试题。</p>
<p>本文包含了JVM中内存结构、垃圾回收算法、垃圾回收器、类加载、双亲委派模型、和JVM调优的常见面试题。</p>
<p>这是本期的 JVM面试题目录，不会的快快查漏补缺~</p>
<p><img src="https://pic2.zhimg.com/80/v2-3ef1f1697eac6bcbb6bd02dbf3a1b3b0_1440w.jpg" alt="img"></p>
<h2 id="1-什么是JVM内存结构？"><a href="#1-什么是JVM内存结构？" class="headerlink" title="1. 什么是JVM内存结构？"></a>1. 什么是JVM内存结构？</h2><p><img src="https://pica.zhimg.com/80/v2-1b82e0a874152d3a2903b6453507ca28_1440w.jpg" alt="img"></p>
<p> jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区； </p>
<ul>
<li><p>程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址； </p>
</li>
<li><p>虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError； </p>
</li>
<li><p>本地方法栈：线程私有的，保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法； </p>
</li>
<li><p>堆：java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作； </p>
</li>
<li><p>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；</p>
</li>
</ul>
<h2 id="2-什么是JVM内存模型？-（JMM）"><a href="#2-什么是JVM内存模型？-（JMM）" class="headerlink" title="2. 什么是JVM内存模型？ （JMM）"></a>2. 什么是JVM内存模型？ （JMM）</h2><h3 id="JMM主内存工作内存介绍"><a href="#JMM主内存工作内存介绍" class="headerlink" title="JMM主内存工作内存介绍"></a>JMM主内存工作内存介绍</h3><p>可以参考一下这篇文章<a target="_blank" rel="noopener" href="https://www.sohu.com/a/420276955_612370">面试官问我什么是JVM内存模型</a></p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211014200550571.png" alt="image-20211014200550571"></p>
<p><strong>Java内存模型</strong>是一套规范，描述了Java程序中各种变量的访问规则（比如说一些线程共享变量），在JVM中如何将变量存储到内存以及如何从内存中读取变量这样的底层细节，具体如下。</p>
<ul>
<li><strong>主内存</strong><br>主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li>
<li><strong>工作内存</strong><br>每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的<strong>副本</strong>。线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。 </li>
</ul>
<p>这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。导致了变量的可见性问题</p>
<img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211014194313372.png" alt="image-20211014194313372" style="zoom: 67%;" />

<p><strong>volatile关键字是如何保证可见性？</strong></p>
<p>当一个线程修改了volatile修饰的共享变量时</p>
<p>1）该变量会立即刷新回主内存。2）其他线程工作内存中的该变量副本失效，会重新从主内存中读取最新值</p>
<h3 id="JMM定义了原子性，可见性和有序性。"><a href="#JMM定义了原子性，可见性和有序性。" class="headerlink" title="JMM定义了原子性，可见性和有序性。"></a>JMM定义了原子性，可见性和有序性。</h3><p>原子性：一个操作不可分割，不可中断，不可被其他线程干扰。JMM提供moniterenter和monitereixt俩个字节码指令保证代码块的原子性<br>可见性：当一个变量被修改后，其他线程能够立即看到修改的结果<br>有序性：禁止指令重排序</p>
<h3 id="主内存工作内存的8种交互操作"><a href="#主内存工作内存的8种交互操作" class="headerlink" title="主内存工作内存的8种交互操作"></a>主内存工作内存的8种交互操作</h3><p><strong>交互过程</strong>：lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock</p>
<img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211014195609937.png" alt="image-20211014195609937" style="zoom:67%;" />

<h2 id="3-heap-和stack-有什么区别？"><a href="#3-heap-和stack-有什么区别？" class="headerlink" title="3. heap 和stack 有什么区别？"></a>3. heap 和stack 有什么区别？</h2><p><strong>（1</strong>）申请方式 </p>
<p>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间 </p>
<p>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟 </p>
<p><strong>（2</strong>）申请后系统的响应 </p>
<p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 </p>
<p>heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 </p>
<p><strong>（3</strong>）申请大小的限制 </p>
<p>stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 </p>
<p>heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。 </p>
<p><strong>（4</strong>）申请效率的比较 </p>
<p>stack：由系统自动分配，速度较快。但程序员是无法控制的。 </p>
<p>heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 </p>
<p><strong>（5</strong>）heap和stack中的存储内容 </p>
<p>stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 </p>
<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 </p>
<p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>
<h2 id="4-什么情况下会发生栈内存溢出？"><a href="#4-什么情况下会发生栈内存溢出？" class="headerlink" title="4. 什么情况下会发生栈内存溢出？"></a>4. 什么情况下会发生栈内存溢出？</h2><p>1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用； 2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题； 3、调整参数-xss去调整jvm栈的大小 </p>
<blockquote>
<p> StackOverFlow:</p>
<p><strong>内存溢出</strong>(OOM) OutOfMemory，指程序在申请内存时，没有足够的内存空间供其使用。 </p>
<p> <strong>内存泄露</strong> Memory Leak，指程序在申请内存后，无法释放已申请的内存空间，内存泄漏最终将导致内存溢出。</p>
</blockquote>
<h2 id="5-谈谈对-OOM-的认识？如何排查-OOM-的问题？"><a href="#5-谈谈对-OOM-的认识？如何排查-OOM-的问题？" class="headerlink" title="5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？"></a>5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？</h2><p>除了程序计数器，其他内存区域都有 OOM 的风险。 </p>
<ul>
<li><p>栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM </p>
</li>
<li><p>Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效； </p>
</li>
<li><p>堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错； </p>
</li>
<li><p>方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等； </p>
</li>
<li><p>直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。 </p>
</li>
</ul>
<p>排查 OOM 的方法： </p>
<ul>
<li>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录； </li>
<li>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域； </li>
<li>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。</li>
</ul>
<h2 id="6-谈谈-JVM-中的常量池？"><a href="#6-谈谈-JVM-中的常量池？" class="headerlink" title="6. 谈谈 JVM 中的常量池？"></a>6. 谈谈 JVM 中的常量池？</h2><p>JVM常量池主要分为<strong>Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池</strong>。 </p>
<ul>
<li><p><strong>Class文件常量池</strong>。class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 </p>
</li>
<li><p><strong>运行时常量池</strong>：运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。 </p>
</li>
<li><p><strong>全局字符串常量池</strong>：字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。  </p>
</li>
<li><p>基本类型包装类对象常量池：java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。 </p>
</li>
</ul>
<h2 id="java对象的创建过程"><a href="#java对象的创建过程" class="headerlink" title="java对象的创建过程"></a>java对象的创建过程</h2><p>大家都知道，java使用new 关键字进行对象的创建，但这只是从语言层次上理解了对象的创建，下边我们从jvm的角度来看看，对象是怎么被创建出来的，即对象的创建过程。</p>
<p>对象的创建大概分为以下几步：</p>
<p>1：检查类是否已经被加载；</p>
<p>2：为对象分配内存空间；</p>
<p>3：为对象字段设置零值；</p>
<p>4：设置对象头；</p>
<p>5：执行构造方法。</p>
<p>第一步，当程序遇到new 关键字时，首先会去运行时常量池中查找该引用所指向的类有没有被虚拟机加载，如果没有被加载，那么会进行类的加载过程，如果已经被加载，那么进行下一步，为对象分配内存空间；</p>
<p>第二步，加载完类之后，需要在堆内存中为该对象分配一定的空间，该空间的大小在类加载完成时就已经确定下来了，这里多说一点，为对象分配内存空间有两种方式：</p>
<p>（1）第一种是jvm将堆区抽象为两块区域，一块是已经被其他对象占用的区域，另一块是空白区域，中间通过一个指针进行标注，这时只需要将指针向空白区域移动相应大小空间，就完成了内存的分配，当然这种划分的方式要求虚拟机的对内存是地址连续的，且虚拟机带有内存压缩机制，可以在内存分配完成时压缩内存，形成连续地址空间，这种分配内存方式成为“指针碰撞”，但是很明显，这种方式也存在一个比较严重的问题，那就是多线程创建对象时，会导致指针划分不一致的问题，例如A线程刚刚将指针移动到新位置，但是B线程之前读取到的是指针之前的位置，这样划分内存时就出现不一致的问题，解决这种问题，虚拟机采用了循环CAS操作来保证内存的正确划分；</p>
<p>（2）第二种也是为了解决第一种分配方式的不足而创建的方式，多线程分配内存时，虚拟机为每个线程分配了不同的空间，这样每个线程在分配内存时只是在自己的空间中操作，从而避免了上述问题，不需要同步。当然，当线程自己的空间用完了才需要需申请空间，这时候需要进行同步锁定。为每个线程分配的空间称为“本地线程分配缓冲（TLAB）”,是否启用TLAB需要通过 -XX:+/-UseTLAB参数来设定。</p>
<p>第三步，分配完内存后，需要对对象的字段进行零值初始化，对象头除外，零值初始化意思就是对对象的字段赋0值，或者null值，这也就解释了为什么这些字段在不需要进程初始化时候就能直接使用；</p>
<p>第四步，这里，虚拟机需要对这个将要创建出来的对象，进行信息标记，包括是否为新生代/老年代，对象的哈希码，元数据信息，这些标记存放在对象头信息中，对象头非常复杂，这里不作解释，可以另行百度；</p>
<p>第五步，也就是最后一步，执行对象的构造方法，这里做的操作才是程序员真正想做的操作，例如初始化其他对象啊等等操作，至此，对象创建成功。</p>
<h2 id="7-如何判断一个对象是否存活？（GC对象的判定方法）"><a href="#7-如何判断一个对象是否存活？（GC对象的判定方法）" class="headerlink" title="7. 如何判断一个对象是否存活？（GC对象的判定方法）"></a>7. 如何判断一个对象是否存活？（GC对象的判定方法）</h2><p>判断一个对象是否存活，分为两种算法1：引用计数法；2：可达性分析法； </p>
<p><strong>引用计数法</strong>： 给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收； </p>
<p>缺点：无法解决<strong>循环引用</strong>的问题，当A引用B，B也引用A的时候，此时A、B对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环引用的例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buidDog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    a.b = b;</span><br><span class="line">    b.a = a;    <span class="comment">//a、b相互引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可达性分析法</strong>： 从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种： </p>
<ul>
<li><p>虚拟机栈中引用的对象 </p>
</li>
<li><p>方法区类静态属性引用的变量 </p>
</li>
<li><p>方法区常量池引用的对象 </p>
</li>
<li><p>本地方法栈JNI引用的对象 </p>
</li>
</ul>
<p>被判定为不可达的对象不一定就会被回收，还需要进行两次标记过程；如果在这两次标记过程中仍然没有成为可达对象，则基本上就要被回收了。</p>
<h2 id="8-强引用、软引用、弱引用、虚引用是什么，有什么区别？"><a href="#8-强引用、软引用、弱引用、虚引用是什么，有什么区别？" class="headerlink" title="8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？"></a>8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？</h2><ul>
<li><p>强引用，最常见的引用，例如使用 new 创建对象。只要对象有强引用指向且 GC Roots 可达，即使濒将要内存耗尽也不会回收。</p>
</li>
<li><p>软引用，弱于强引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象。SoftReference 实现 </p>
</li>
<li><p>弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会被回收。WeakReference 实现 </p>
</li>
<li><p>虚引用，最弱的引用，无法通过引用获取对象。唯一目的是在对象被回收时收到一个系统通知，必须与引用队列配合。PhantomReference 实现 </p>
</li>
</ul>
<h2 id="9-被引用的对象就一定能存活吗？"><a href="#9-被引用的对象就一定能存活吗？" class="headerlink" title="9. 被引用的对象就一定能存活吗？"></a>9. 被引用的对象就一定能存活吗？</h2><p>不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。 </p>
<h2 id="10-Java中的垃圾回收算法有哪些？"><a href="#10-Java中的垃圾回收算法有哪些？" class="headerlink" title="10. Java中的垃圾回收算法有哪些？"></a>10. Java中的垃圾回收算法有哪些？</h2><p>二、典型的垃圾收集算法<br>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。</p>
<p>1.<strong>Mark-Sweep（标记-清除）算法</strong></p>
<p>这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。</p>
<p>标记-清除算法分为两个阶段：标记阶段和清除阶段。在标记阶段标记出所有需要被回收的对象，在清除阶段回收被标记的对象。具体过程如下图所示：</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211010222847683.png" alt="标记-清除算法"></p>
<p>标记-清除算法容易实现，缺点是容易产生内存碎片，当碎片太多时，如果后续过程中需要为大对象分配空间，就无法找到足够的空间，会提前触发新的一轮垃圾回收。</p>
<p>2.<strong>Copying（复制）算法</strong></p>
<p>　　为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211010222858465.png" alt="复制算法"></p>
<p>这种算法虽然实现简单，不容易产生内存碎片；但是我们能使用的内存是原来的一半，并且复制算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，我们需要复制的操作次数就很多，那么Copying算法的效率将会大大降低</p>
<p>3.<strong>Mark-Compact（标记-整理）算法（压缩法）</strong></p>
<p>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和标记-清除法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211010222911142.png" alt="标记-整理算法"></p>
<p>4.<strong>Generational Collection（分代收集）算法</strong></p>
<p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，因为只需要付出少量存活对象的复制成本就可以完成。而老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。</p>
<p>在Java虚拟机分代垃圾回收机制中，应用程序的堆空间可以分为年轻代与老年代，然后年轻代有被分为Eden区，From区与To区。</p>
<p>目前大部分垃圾收集器对于新生代都采取复制算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例（默认比例为8：1）来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p>
<hr>
<p><strong>分代收集算法的具体步骤：</strong></p>
<p>在Java虚拟机分代垃圾回收机制中，应用程序可用的堆空间可以分为*<strong>年轻代*</strong>与*<strong>老年代*</strong>，然后年轻代有被分为*<strong>Eden区，From区与To区*</strong>。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200335693.png" alt="这里写图片描述"></p>
<p>当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次*<strong>YoungGC*</strong>，也就是*<strong>年轻代的垃圾回收*</strong>。</p>
<p>一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200530361.png" alt="这里写图片描述"></p>
<p>这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，*<strong>会将Eden区与From区还在被使用的对象复制到To区*</strong>，</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200709299.png" alt="这里写图片描述"></p>
<p>再下一次YoungGC的时候，则是将*<strong>Eden区与To区中的还在被使用的对象复制到From区*</strong>。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200920951.png" alt="这里写图片描述"></p>
<p>经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101201239084.png" alt="这里写图片描述"></p>
<p>老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（*<strong>Full GC*</strong>），也就是全量回收，一起滚蛋吧。</p>
<p>全量回收呢，就好比我们刚才比作的大扫除，毕竟动做比较大，成本高，不能跟平时的小型值日（Young GC）相比，所以如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。</p>
<p>所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作</p>
<p>而由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记-整理算法（压缩法）。</p>
<hr>
<blockquote>
<p><strong>为什么要将java 堆分为新生代和老年代？</strong></p>
<p>对堆空间分代的目的就是优化GC性能。</p>
<p>不分代同样可以完成GC，如果没有分代，那我们所有的对象都在一块，GC的时候我们会对堆的所有区域进行扫描，找到哪些对象没用。但是我们的很多对象生命周期都比较短，如果分代的话，我们把这些新创建的对象放到某一块区域，当GC的时候先把这块区域进行回收，能优化GC性能</p>
</blockquote>
<p><strong>对比</strong> </p>
<p><img src="https://pic2.zhimg.com/80/v2-8608f268f11f6220b43676e8009c22cd_1440w.jpg" alt="img"></p>
<h2 id="11-有哪几种垃圾回收器，各自的优缺点是什么？"><a href="#11-有哪几种垃圾回收器，各自的优缺点是什么？" class="headerlink" title="11. 有哪几种垃圾回收器，各自的优缺点是什么？"></a>11. 有哪几种垃圾回收器，各自的优缺点是什么？</h2><p>垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。</p>
<p>1.Serial/Serial Old收集器 是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p>
<p>2.ParNew收集器 是Serial收集器的多线程版本，也会暂停正在执行的线程，使用多个线程进行垃圾收集。</p>
<p>3.Parallel Scavenge收集器 是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p>
<p>4.Parallel Old收集器 是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p>
<p>5.CMS（Concurrent Mark Sweep）收集器 是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器，它是一种并发收集器，采用的是标记清除算法。</p>
<p>6.G1收集器 是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p>
<p><strong>垃圾回收器间的配合使用图：</strong> </p>
<p><img src="https://pic4.zhimg.com/80/v2-25cb5804757e48387305cb1501739623_1440w.jpg" alt="img"></p>
<p><strong>各个垃圾回收器对比</strong>： </p>
<p><img src="https://pic3.zhimg.com/80/v2-4579a5210bc3767590eb428bf5509b7a_1440w.jpg" alt="img"></p>
<h2 id="12-详细说一下CMS的回收过程？CMS的问题是什么？"><a href="#12-详细说一下CMS的回收过程？CMS的问题是什么？" class="headerlink" title="12. 详细说一下CMS的回收过程？CMS的问题是什么？"></a>12. 详细说一下CMS的回收过程？CMS的问题是什么？</h2><p>CMS(Concurrent Mark Sweep，并发标记清除) 收集器是<strong>以获取最短回收停顿时间为目标</strong>的垃圾回收器（追求低停顿），对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。因为CMS在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。 </p>
<blockquote>
<p> 注意：“标记”是指将存活的对象和要回收的对象都给标记出来，而“清除”是指清除掉将要回收的对象。</p>
</blockquote>
<p>从名字就可以知道，CMS是基于“标记-清除”算法实现的。CMS 回收过程分为以下六步： </p>
<ul>
<li><p>初始标记 ：这个阶段主要是标记 GC Root 直接相关联的下一级对象，这个过程会停顿正在执行的任务 （简称STW），但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。</p>
</li>
<li><p>并发标记 ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，没有STW</p>
</li>
<li><p>并发预清理 ：在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。<strong>通过重新扫描，减少下一个阶段”重新标记”的工作，因为下一个阶段会Stop The World。</strong></p>
</li>
<li><p>重新标记 ：这个阶段会STW。扫描从”跟对象”开始向下追溯，并处理对象关联。因为在第二步并发标记阶段并没有阻塞其它工作线程，因此在标记的过程中，很有可能会产生新的垃圾。</p>
</li>
<li><p>并发清理 ：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。</p>
</li>
<li><p>并发重置 ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</p>
</li>
</ul>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/2b525609-ce63-3a42-bf19-b2fbcd42f26c.png" alt="CMS回收过程"></p>
<p><strong>CMS 的问题：</strong> </p>
<p><strong>1. 并发回收导致CPU资源紧张：</strong> </p>
<p>在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：（CPU核数 + 3）/ 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。 </p>
<p><strong>2. 无法清理浮动垃圾：</strong> </p>
<p>在CMS的并发标记和并发清理阶段，用户线程还在继续运行，在这个过程中，一些对象开始被判定为非垃圾，但之后变成了垃圾，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。 </p>
<p><strong>3. 并发失败（Concurrent Mode Failure）：</strong> </p>
<p>由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX**:** CMSInitiatingOccupancyFraction 参数来设置。 </p>
<p>这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。 </p>
<p><strong>4.内存碎片问题：</strong> </p>
<p>CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦。</p>
<p>往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。 </p>
<p>为了解决这个问题，CMS收集器提供了一个 -XX**:<strong>+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX</strong>:**CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。</p>
<h2 id="13-详细说一下G1的回收过程？"><a href="#13-详细说一下G1的回收过程？" class="headerlink" title="13. 详细说一下G1的回收过程？"></a>13. 详细说一下G1的回收过程？</h2><p>G1（Garbage First）回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。G1设计初衷就是替换 CMS，成为一种全功能收集器。G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于标记-整理算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制算法实现的。 </p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211011160511149.png" alt="image-20211011160511149"></p>
<blockquote>
<p>基于Region的内存布局形式：</p>
<p>传统的收集器问题都是基于分代理论,将堆内存划分成固定大小的连续内存区域。而G1开创了一套新的堆内存布局方案,虽然仍然是遵守分代理论的，但它把堆内存划分为多个大小想等的独立区域即Region。每一个Region都可以根据需要去扮演Eden区，Survivor区，Old区，Humongous区。(注：Humongous区是一类特殊区域专门存放大对象)</p>
</blockquote>
<p>在回收时以Region作为最小的回收单位，G1会预测出每个Region的回收时间，回收后得到的内存大小以此计算出的该Region回收的”价值”，根据用户设置的期望GC停顿时间，每次回收优先处理回收价值最大的Region，这也是G1(Garabage First)名字的由来原因。</p>
<p><strong>G1 回收过程</strong>，G1 回收器的运作过程大致可分为四个步骤： </p>
<ol>
<li><p>初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。 </p>
</li>
<li><p>并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。 </p>
</li>
<li><p>最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。 </p>
</li>
<li><p>清理阶段（会STW）：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。 </p>
</li>
</ol>
<h2 id="14-JVM中一次完整的GC是什么样子的？"><a href="#14-JVM中一次完整的GC是什么样子的？" class="headerlink" title="14. JVM中一次完整的GC是什么样子的？"></a>14. JVM中一次完整的GC是什么样子的？</h2><p>先描述一下Java堆内存划分。 </p>
<p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的 1/3，老年代默认占 2/3。 新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。 </p>
<p>新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。 </p>
<p>老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。 </p>
<p><img src="https://pic2.zhimg.com/80/v2-f2a086e09f8bb950b63381145f6f16c2_1440w.jpg" alt="img"></p>
<p>再描述它们之间转化流程。 </p>
<ul>
<li>对象优先在Eden分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。<ul>
<li>在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；</li>
<li>Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制 到 to 区； </li>
<li>移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。GC年龄的阀值可以 通过参数 -XX:MaxTenuringThreshold 设置，默认为 15；</li>
<li>动态对象年龄判定：Survivor 区相同年龄所有对象大小的总和 &gt; (Survivor 区内存大小 * 这个 目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 - XX:TargetSurvivorRatio 指定，默认为 50%； </li>
<li>Survivor 区内存不足会发生担保分配，超过指定大小的对象可以直接进入老年代。 </li>
</ul>
</li>
<li>大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 </li>
<li>老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – <strong>包括年轻代和老年代</strong>。</li>
</ul>
<p>作者：擎宇要努力努力再努力<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/595546?type=post&amp;order=time&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack">https://www.nowcoder.com/discuss/595546?type=post&amp;order=time&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</a><br>来源：牛客网</p>
<h4 id="（七）内存分配与回收策略"><a href="#（七）内存分配与回收策略" class="headerlink" title="（七）内存分配与回收策略"></a>（七）内存分配与回收策略</h4><p> <strong>对象优先在 Eden 区分配</strong> </p>
<p> 大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。 </p>
<p> <strong>大对象直接进入老年代</strong> </p>
<p> 大对象指需要大量连续内存空间的对象，例如很长的字符串或大数组，容易导致内存还有不少空间就提前触发 GC 以获得足够连续空间。 </p>
<p> HotSpot 提供了 -XX:PretenureSizeThreshold 参数，大于该值的对象直接在老年代分配，避免在 Eden 和 Survivor 间来回复制。 </p>
<p> <strong>长期存活对象进入老年代</strong> </p>
<p> 虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头。如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1。对象在 Survivor 中每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。对象晋升老年代的阈值可通过 -XX:MaxTenuringThreshold 设置。 </p>
<p> <strong>动态对象年龄判定</strong> </p>
<p> 为了适应不同内存状况，虚拟机不要求对象年龄达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。 </p>
<p> <strong>空间分配担保</strong> </p>
<p> MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。 </p>
<p> 如果不满足，虚拟机会查看 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将冒险尝试一次 Minor GC，否则改成一次 FullGC。 </p>
<p> 冒险是因为新生代使用复制<a href="">算法</a>，只用一个 Survivor，大量对象在 Minor GC 后仍然存活时需要老年代接收 Survivor 无法容纳的对象。</p>
<h2 id="15-Minor-GC-和-Full-GC-有什么不同呢？"><a href="#15-Minor-GC-和-Full-GC-有什么不同呢？" class="headerlink" title="15. Minor GC 和 Full GC 有什么不同呢？"></a>15. Minor GC 和 Full GC 有什么不同呢？</h2><p>Minor GC：只回收新生代的GC。 </p>
<p>Full GC: 回收整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式。 </p>
<p><strong>Minor GC触发条件：</strong>当Eden区满时，触发Minor GC。 </p>
<p><strong>Full GC触发条件</strong>： </p>
<ul>
<li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。 </p>
</li>
<li><p>老年代空间不够分配新的内存（或永久代空间不足，但只是JDK1.7有的，这也是用元空间来取代永久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率）。 </p>
</li>
<li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。 </p>
</li>
<li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行。 </p>
</li>
</ul>
<h2 id="16-介绍下空间分配担保原则？"><a href="#16-介绍下空间分配担保原则？" class="headerlink" title="16. 介绍下空间分配担保原则？"></a>16. 介绍下空间分配担保原则？</h2><p>如果YougGC时新生代有大量对象存活下来，而 survivor 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。 </p>
<p>在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 survivor 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。 </p>
<p>在允许担保失败并尝试进行YoungGC后，可能会出现三种情况： </p>
<ul>
<li><p>① YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中 </p>
</li>
<li><p>② YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。 </p>
</li>
<li><p>③ YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。 </p>
</li>
</ul>
<p>通过下图来了解空间分配担保原则： </p>
<p><img src="https://pic2.zhimg.com/80/v2-230afbe3d56d81be16ec7cd9b4d126d9_1440w.jpg" alt="img"></p>
<h2 id="17-什么是类加载？类加载的过程？"><a href="#17-什么是类加载？类加载的过程？" class="headerlink" title="17. 什么是类加载？类加载的过程？"></a>17. 什么是类加载？类加载的过程？</h2><p>虚拟机把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象； </p>
<p>类加载的五个过程：加载、验证、准备、解析、初始化、使用、卸载，</p>
<p>为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序开始。如图所示：</p>
<p><img src="https://pica.zhimg.com/v2-428183fb231daeaf4571dabf2a19af8c_b.jpg" alt="img"></p>
<p><strong>加载</strong><br>在加载阶段，虚拟机主要完成三件事：</p>
<ul>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构。</p>
</li>
</ul>
<ul>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区域数据的访问入口。</li>
</ul>
<p><strong>验证</strong><br>验证阶段作用是保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害。如果验证失败，就会抛出一个java.lang.VerifyError异常或其子类异常。验证过程分为四个阶段：</p>
<ul>
<li><p>文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。</p>
</li>
<li><p>元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范要求</p>
</li>
<li><p>字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。</p>
</li>
<li><p>符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。</p>
</li>
</ul>
<p><strong>准备</strong><br>准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量。对已非final的变量，JVM会将其设置成“零值”，而不是其赋值语句的值：pirvate static int size = 12; 那么在这个阶段，size的值为0，而不是12。但final修饰的类变量将会赋值成真实的值。</p>
<p><strong>解析</strong><br>解析过程是将常量池内的符号引用替换成直接引用。主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析。</p>
<p><strong>初始化</strong><br>在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。</p>
<p>至于使用和卸载阶段阶段，这里不再过多说明，使用过程就是根据程序定义的行为执行，卸载由GC完成。</p>
<h2 id="18-什么是类加载器，常见的类加载器有哪些？"><a href="#18-什么是类加载器，常见的类加载器有哪些？" class="headerlink" title="18. 什么是类加载器，常见的类加载器有哪些？"></a>18. 什么是类加载器，常见的类加载器有哪些？</h2><p>类加载器：把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为“类加载器”。</p>
<p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分</li>
<li>所有其它类的加载器，使用 Java 实现，独立于虚拟机，并且全部继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p><strong>类加载器分为以下四种：</strong> </p>
<ul>
<li>启动类加载器（BootStrapClassLoader）：用来加载java核心类库，无法被java程序直接引用； </li>
<li>扩展类加载器（Extension ClassLoader）：用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类； </li>
<li>应用程序类加载器（AppClassLoader）：它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的； </li>
<li>自定义类加载器：由java语言实现，继承自ClassLoader； </li>
</ul>
<p>类加载器按照层次，从顶层到底层的顺序（<strong>如图只是类加载的层次顺序，和类继承无关</strong>）：</p>
<img src="https://pic4.zhimg.com/v2-64c33143d2d28029df7e6ea37659dce0_b.jpg" alt="img" style="zoom: 80%;" />

<h2 id="19-什么是双亲委派模型？为什么需要双亲委派模型？"><a href="#19-什么是双亲委派模型？为什么需要双亲委派模型？" class="headerlink" title="19. 什么是双亲委派模型？为什么需要双亲委派模型？"></a>19. 什么是双亲委派模型？为什么需要双亲委派模型？</h2><p><strong>运行流程：</strong></p>
<p>当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，一层一层向上，请求最终到达顶层的启动类加载器，只如果父类加载器可以完成类加载任务，就<strong>成功返回</strong>，倘若父类加载器无法完成此加载任务，<strong>子加载器才会尝试自己去加载</strong>，如果都没找到则会抛出ClassNotFound异常，这就是双亲委派模型。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/src=http%253A%252F%252Fwww.west.cn%252Finfo%252Fupload%252F20191016%252F4wjcrsxfmj0.jpg&refer=http%253A%252F%252Fwww.west.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="双亲委派模型"></p>
<p>为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。 </p>
<p><strong>类的唯一性：</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在JVM中的唯一性。</p>
<p>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。</p>
<p><strong>双亲委派模型的好处（为什么需要双亲委派模型）</strong>：</p>
<ul>
<li>Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>，通过这种层级关可以<strong>避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>
<li>其次是考虑到安全因素，<strong>防止核心API库被随意篡改</strong>。假设通过网络传递一个名java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以<strong>防止核心API库被随意篡改</strong>。</li>
</ul>
<p><strong>怎么打破双亲委派模型</strong>？ </p>
<p>自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。 </p>
<h2 id="20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？"><a href="#20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？" class="headerlink" title="20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？"></a>20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</h2><ul>
<li><p>JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。 </p>
</li>
<li><p>Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。<br>  tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的： </p>
</li>
</ul>
<ul>
<li><ul>
<li><p>对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。 </p>
</li>
<li><p>与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏； </p>
</li>
<li><p>热部署。 </p>
</li>
</ul>
</li>
</ul>
<p>tomcat类加载器如下图： </p>
<p><img src="https://pic2.zhimg.com/80/v2-0f8b46ab0eef7d30938798eebb401dbb_1440w.jpg" alt="img"></p>
<ul>
<li><p>OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。 </p>
</li>
<li><p>JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。 </p>
</li>
</ul>
<h2 id="21-说一下-JVM-调优的命令？"><a href="#21-说一下-JVM-调优的命令？" class="headerlink" title="21.说一下 JVM 调优的命令？"></a>21.说一下 JVM 调优的命令？</h2><ul>
<li><p>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 </p>
</li>
<li><p>jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 </p>
</li>
<li><p>jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。 </p>
</li>
<li><p>jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。 </p>
</li>
<li><p>jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">pb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/30/7-30jvm学习/">http://example.com/2021/07/30/7-30jvm学习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">pb</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="social-share pull-right" data-disabled="google,twitter,facebook,douban,instagram,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/07/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><i class="fa fa-chevron-left">  </i><span>十大经典排序算法</span></a></div><div class="next-post pull-right"><a href="/2021/07/28/cpu%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/"><span>cpu、寄存器、缓存、内存概念</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '52a38b388c08f769c0fe',
  clientSecret: '5428c9a58faaa3488201c1791496427b41deb385',
  repo: 'jiubukaiji.github.io',
  owner: 'jiubukaiji',
  admin: 'jiubukaiji',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By pb</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>