<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="7.30jvm学习"><meta name="keywords" content="JVM"><meta name="author" content="pb"><meta name="copyright" content="pb"><title>7.30jvm学习 | pb</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="pb" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFJVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是JVM内存结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F-%EF%BC%88JMM%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">2. 什么是JVM内存模型？ （JMM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">JMM主内存工作内存介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E5%AE%9A%E4%B9%89%E4%BA%86%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%8C%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%82"><span class="toc-number">2.2.</span> <span class="toc-text">JMM定义了原子性，可见性和有序性。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%848%E7%A7%8D%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">主内存工作内存的8种交互操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-heap-%E5%92%8Cstack-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3. heap 和stack 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. 什么情况下会发生栈内存溢出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%B0%88%E8%B0%88%E5%AF%B9-OOM-%E7%9A%84%E8%AE%A4%E8%AF%86%EF%BC%9F%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5-OOM-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B0%88%E8%B0%88-JVM-%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6. 谈谈 JVM 中的常量池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%885%E6%AD%A5%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">java对象的创建过程（5步）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">7. 如何判断一个对象是否存活？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%A2%AB%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%83%BD%E5%AD%98%E6%B4%BB%E5%90%97%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">9. 被引用的对象就一定能存活吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Java%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">10. Java中的垃圾回收算法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">12.</span> <span class="toc-text">内存分配与回收策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Minor-GC%EF%BC%88Young-GC%EF%BC%89-%E5%92%8C-Full-GC-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">15. Minor GC（Young GC） 和 Full GC 有什么不同呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">14.</span> <span class="toc-text">对象进入老年代的四种情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">11. 有哪几种垃圾回收器，各自的优缺点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">12. CMS垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">17.</span> <span class="toc-text">13. G1垃圾收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1%E5%92%8CCMS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%883%E4%B8%AA%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">G1和CMS的区别（3个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-JVM%E4%B8%AD%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84GC%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">14. JVM中一次完整的GC是什么样子的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E4%BB%8B%E7%BB%8D%E4%B8%8B%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">16. 介绍下空间分配担保原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">17. 什么是类加载？类加载的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">18. 什么是类加载器，常见的类加载器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">19. 什么是双亲委派模型？为什么需要双亲委派模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%93%E7%A0%B4%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E8%AF%B4%E4%B8%80%E4%B8%8B-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">21.说一下 JVM 调优的命令？</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/111.jpg"></div><div class="author-info__name text-center">pb</div><div class="author-info__description text-center">This is my site</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">94</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">13</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">pb</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">7.30jvm学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-07-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/">面试学习系列</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 41 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>jvm就硬背吧 （这10000字咋背呀^&gt;_&lt;^）</p>
</blockquote>
<a id="more"></a>

<p><img src="https://pic2.zhimg.com/80/v2-3ef1f1697eac6bcbb6bd02dbf3a1b3b0_1440w.jpg" alt="img"></p>
<h2 id="1-什么是JVM内存结构？"><a href="#1-什么是JVM内存结构？" class="headerlink" title="1. 什么是JVM内存结构？"></a>1. 什么是JVM内存结构？</h2><p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/v2-73ccd948b2d98055aa28261a18dd145b_b.jpg" alt="完整的JVM架构"></p>
<p>JVM被分为三个主要的子系统</p>
<p>（1）类加载器（2）运行时数据区（3）执行引擎</p>
<p><img src="https://pica.zhimg.com/80/v2-1b82e0a874152d3a2903b6453507ca28_1440w.jpg" alt="img"></p>
<p> jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区； </p>
<ul>
<li><p><strong>程序计数器</strong>：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，<strong>用于记录当前线程指令地址；</strong> </p>
</li>
<li><p><strong>虚拟机栈</strong>：线程私有的，<strong>存储当前线程运行方法指令数据，方法被调用时会在栈中开辟一块叫栈帧的空间，方法运行在栈帧空间中</strong>。栈帧出栈后，里面的局部变量直接就从内存里清理掉了</p>
</li>
<li><p><strong>本地方法栈</strong>：线程私有的，<strong>保存的是native方法的信息</strong>（native方法底层是用C或C++编写的），当一个jvm创建的线程调用native方法后，<strong>jvm不会在虚拟机栈中为该线程创建栈帧</strong>，而是<strong>简单的动态链接</strong>并直接调用该方法； </p>
</li>
<li><p><strong>堆</strong>：java堆是所有线程共享的一块内存，<strong>主要存储new出来的对象信息</strong>，因此该区域<strong>经常发生垃圾回收的操作；</strong> </p>
</li>
<li><p><strong>方法区</strong>：<strong>主要存储类的信息、比如类方法、类常量</strong>，即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；</p>
</li>
</ul>
<h2 id="2-什么是JVM内存模型？-（JMM）"><a href="#2-什么是JVM内存模型？-（JMM）" class="headerlink" title="2. 什么是JVM内存模型？ （JMM）"></a>2. 什么是JVM内存模型？ （JMM）</h2><h3 id="JMM主内存工作内存介绍"><a href="#JMM主内存工作内存介绍" class="headerlink" title="JMM主内存工作内存介绍"></a>JMM主内存工作内存介绍</h3><p>可以参考一下这篇文章<a target="_blank" rel="noopener" href="https://www.sohu.com/a/420276955_612370">面试官问我什么是JVM内存模型</a></p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211014200550571.png" alt="image-20211014200550571"></p>
<p><strong>Java内存模型</strong>是一套规范，<strong>主要描述了在JVM中如何将变量存储到内存以及如何从内存中读取变量这样的底层细节</strong>，具体如下。</p>
<ul>
<li><strong>主内存</strong><br>主内存是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li>
<li><strong>工作内存</strong><br>每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的<strong>副本</strong>。线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。 </li>
</ul>
<p>这就可能造成一个线程在工作内存中修改了变量的值传回了主内存，而另外一个线程还继续使用这个共享变量原来的值，造成数据的不一致，导致了<strong>变量的可见性问题</strong></p>
<img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211014194313372.png" alt="image-20211014194313372" style="zoom: 67%;" />

<p><strong>volatile关键字是如何保证可见性？</strong></p>
<p>当一个线程修改了volatile修饰的共享变量时</p>
<ul>
<li>将变量的值刷新回主内存</li>
<li>其他线程中这个变量的副本会失效，重新从主内存中读取最新值。</li>
</ul>
<h3 id="JMM定义了原子性，可见性和有序性。"><a href="#JMM定义了原子性，可见性和有序性。" class="headerlink" title="JMM定义了原子性，可见性和有序性。"></a>JMM定义了原子性，可见性和有序性。</h3><p>原子性：一个操作不可分割，不可中断，不可被其他线程干扰。JMM提供moniterenter和monitereixt俩个字节码指令保证代码块的原子性<br>可见性：当一个变量被修改后，其他线程能够立即看到修改的结果<br>有序性：禁止指令重排序</p>
<h3 id="主内存工作内存的8种交互操作"><a href="#主内存工作内存的8种交互操作" class="headerlink" title="主内存工作内存的8种交互操作"></a>主内存工作内存的8种交互操作</h3><p><strong>交互过程</strong>：lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock</p>
<img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211014195609937.png" alt="image-20211014195609937" style="zoom:67%;" />

<h2 id="3-heap-和stack-有什么区别？"><a href="#3-heap-和stack-有什么区别？" class="headerlink" title="3. heap 和stack 有什么区别？"></a>3. heap 和stack 有什么区别？</h2><p><strong>（1</strong>）申请方式 </p>
<p>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间 </p>
<p>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟 </p>
<p><strong>（2</strong>）申请后系统的响应 </p>
<p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 </p>
<p>heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 </p>
<p><strong>（3</strong>）申请大小的限制 </p>
<p>stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 </p>
<p>heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。 </p>
<p><strong>（4</strong>）申请效率的比较 </p>
<p>stack：由系统自动分配，速度较快。但程序员是无法控制的。 </p>
<p>heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 </p>
<p><strong>（5</strong>）heap和stack中的存储内容 </p>
<p>stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 </p>
<p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 </p>
<p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p>
<h2 id="4-什么情况下会发生栈内存溢出？"><a href="#4-什么情况下会发生栈内存溢出？" class="headerlink" title="4. 什么情况下会发生栈内存溢出？"></a>4. 什么情况下会发生栈内存溢出？</h2><p>1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用； 2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题； 3、调整参数-xss去调整jvm栈的大小 </p>
<blockquote>
<p> StackOverFlow:</p>
<p><strong>内存溢出</strong>(OOM) OutOfMemory，指程序在申请内存时，没有足够的内存空间供其使用。 </p>
<p> <strong>内存泄露</strong> Memory Leak，指程序在申请内存后，无法释放已申请的内存空间，内存泄漏最终将导致内存溢出。</p>
</blockquote>
<h2 id="5-谈谈对-OOM-的认识？如何排查-OOM-的问题？"><a href="#5-谈谈对-OOM-的认识？如何排查-OOM-的问题？" class="headerlink" title="5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？"></a>5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？</h2><p><strong>内存溢出</strong>(OOM) OutOfMemory，<strong>指程序在申请内存时，没有足够的内存空间供其使用。</strong> </p>
<p><strong>除了程序计数器，其他内存区域都有 OOM 的风险。</strong> </p>
<ul>
<li><p>栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM </p>
</li>
<li><p>Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效； </p>
</li>
<li><p>堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错； </p>
</li>
<li><p>方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等； </p>
</li>
<li><p>直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。 </p>
</li>
</ul>
<p>排查 OOM 的方法： </p>
<ul>
<li>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录； </li>
<li>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域； </li>
<li>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。</li>
</ul>
<h2 id="6-谈谈-JVM-中的常量池？"><a href="#6-谈谈-JVM-中的常量池？" class="headerlink" title="6. 谈谈 JVM 中的常量池？"></a>6. 谈谈 JVM 中的常量池？</h2><p>JVM常量池主要分为<strong>Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池</strong>。 </p>
<ul>
<li><p><strong>Class文件常量池</strong>。class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 </p>
</li>
<li><p><strong>运行时常量池</strong>：运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。 </p>
</li>
<li><p><strong>全局字符串常量池</strong>：字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。  </p>
</li>
<li><p>基本类型包装类对象常量池：java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。 </p>
</li>
</ul>
<h2 id="java对象的创建过程（5步）"><a href="#java对象的创建过程（5步）" class="headerlink" title="java对象的创建过程（5步）"></a>java对象的创建过程（5步）</h2><p>大家都知道，java使用new 关键字进行对象的创建，但这只是从语言层次上理解了对象的创建，下边我们从jvm的角度来看看，对象是怎么被创建出来的，即对象的创建过程。</p>
<p>对象的创建大概分为以下几步：</p>
<p><strong>1：检查类是否已经被加载；</strong></p>
<p><strong>2：为对象分配内存空间；</strong></p>
<p><strong>3：为对象字段设置零值；</strong></p>
<p><strong>4：设置对象头；</strong></p>
<p><strong>5：执行构造方法。</strong></p>
<p>第一步，当程序遇到new 关键字时，首先会去运行时常量池中查找该引用所指向的类有没有被虚拟机加载，如果没有被加载，那么会进行类的加载过程，如果已经被加载，那么进行下一步，为对象分配内存空间；</p>
<p>第二步，加载完类之后，需要在堆内存中为该对象分配一定的空间，该空间的大小在类加载完成时就已经确定下来了，这里多说一点，为对象分配内存空间有两种方式：</p>
<p>（1）第一种是jvm将堆区抽象为两块区域，一块是已经被其他对象占用的区域，另一块是空白区域，中间通过一个指针进行标注，这时只需要将指针向空白区域移动相应大小空间，就完成了内存的分配，当然这种划分的方式要求虚拟机的对内存是地址连续的，且虚拟机带有内存压缩机制，可以在内存分配完成时压缩内存，形成连续地址空间，这种分配内存方式成为“指针碰撞”，但是很明显，这种方式也存在一个比较严重的问题，那就是多线程创建对象时，会导致指针划分不一致的问题，例如A线程刚刚将指针移动到新位置，但是B线程之前读取到的是指针之前的位置，这样划分内存时就出现不一致的问题，解决这种问题，虚拟机采用了循环CAS操作来保证内存的正确划分；</p>
<p>（2）第二种也是为了解决第一种分配方式的不足而创建的方式，多线程分配内存时，虚拟机为每个线程分配了不同的空间，这样每个线程在分配内存时只是在自己的空间中操作，从而避免了上述问题，不需要同步。当然，当线程自己的空间用完了才需要需申请空间，这时候需要进行同步锁定。为每个线程分配的空间称为“本地线程分配缓冲（TLAB）”,是否启用TLAB需要通过 -XX:+/-UseTLAB参数来设定。</p>
<p>第三步，分配完内存后，需要对对象的字段进行零值初始化，对象头除外，零值初始化意思就是对对象的字段赋0值，或者null值，这也就解释了为什么这些字段在不需要进程初始化时候就能直接使用；</p>
<p>第四步，这里，虚拟机需要对这个将要创建出来的对象，进行信息标记，包括是否为新生代/老年代，对象的哈希码，元数据信息，这些标记存放在对象头信息中，对象头非常复杂，这里不作解释，可以另行百度；</p>
<p>第五步，也就是最后一步，执行对象的构造方法，也就是执行我们在构造函数中写的代码。</p>
<h2 id="7-如何判断一个对象是否存活？"><a href="#7-如何判断一个对象是否存活？" class="headerlink" title="7. 如何判断一个对象是否存活？"></a>7. 如何判断一个对象是否存活？</h2><p>判断一个对象是否存活，分为两种算法1：引用计数法；2：可达性分析法； </p>
<p><strong>引用计数法</strong>： 给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收； </p>
<p>缺点：无法解决<strong>循环引用</strong>的问题，当A引用B，B也引用A的时候，此时A、B对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环引用的例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buidDog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    a.b = b;</span><br><span class="line">    b.a = a;    <span class="comment">//a、b相互引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可达性分析法</strong>： 从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可达，被判定为不可达的对象不一定就会被回收，还需要进行两次标记过程；如果在这两次标记过程中仍然没有成为可达对象，则基本上就要被回收了。</p>
<p><strong>可以作为GC Roots的对象有以下几种：</strong> （作为GC Root，它在当下一定是存活的）</p>
<ul>
<li><p>虚拟机栈中引用的对象 （栈帧中的变量表）</p>
</li>
<li><p>方法区静态变量和常量引用的对象</p>
</li>
<li><p>本地方法栈中native方法引用的对象 </p>
</li>
</ul>
<h2 id="8-强引用、软引用、弱引用、虚引用是什么，有什么区别？"><a href="#8-强引用、软引用、弱引用、虚引用是什么，有什么区别？" class="headerlink" title="8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？"></a>8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？</h2><ul>
<li><p>强引用，最常见的引用，例如使用 new 创建对象。只要对象有强引用指向且 GC Roots 可达，即使濒将要内存耗尽也不会回收。</p>
</li>
<li><p>软引用，弱于强引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象。SoftReference 实现 </p>
</li>
<li><p>弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会被回收。WeakReference 实现 </p>
</li>
<li><p>虚引用，最弱的引用，无法通过引用获取对象。唯一目的是在对象被回收时收到一个系统通知，必须与引用队列配合。PhantomReference 实现 </p>
</li>
</ul>
<h2 id="9-被引用的对象就一定能存活吗？"><a href="#9-被引用的对象就一定能存活吗？" class="headerlink" title="9. 被引用的对象就一定能存活吗？"></a>9. 被引用的对象就一定能存活吗？</h2><p>不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。 </p>
<h2 id="10-Java中的垃圾回收算法有哪些？"><a href="#10-Java中的垃圾回收算法有哪些？" class="headerlink" title="10. Java中的垃圾回收算法有哪些？"></a>10. Java中的垃圾回收算法有哪些？</h2><p>二、典型的垃圾收集算法<br>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。</p>
<p>1.<strong>Mark-Sweep（标记-清除）算法</strong></p>
<p>这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。</p>
<p>标记-清除算法分为两个阶段：标记阶段和清除阶段。在标记阶段标记出哪些对象是需要回收的，在清除阶段回收被标记的对象。具体过程如下图所示：</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211010222847683.png" alt="标记-清除算法"></p>
<p>标记-清除算法容易实现，缺点是容易产生<strong>内存碎片</strong>，当碎片太多时，如果后续过程中需要为大对象分配空间，就无法找到足够的空间，会提前触发新的一轮垃圾回收。</p>
<p>2.<strong>Copying（复制）算法</strong></p>
<p>　　为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211010222858465.png" alt="复制算法"></p>
<p>这种算法虽然实现简单，不容易产生内存碎片；但是我们能使用的内存是原来的一半，并且复制算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，我们需要复制的操作次数就很多，那么Copying算法的效率将会大大降低</p>
<p>3.<strong>Mark-Compact（标记-整理）算法（压缩法）</strong></p>
<p>标记哪些对象是存活的，将这些存活对象向一端移动，然后清理掉端边界以外的内存。</p>
<p>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和标记-清除法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211010222911142.png" alt="标记-整理算法"></p>
<p>4.<strong>Generational Collection（分代收集）算法</strong></p>
<p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是<strong>根据对象存活周期的不同将内存划分为几块</strong>。一般是把堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以<strong>根据各个年代的特点采用最适合的垃圾回收算法</strong>。在新生代中，每次垃圾收集只有少量对象存活，那就选用复制算法；而老年代中对象存活率高，一般使用“标记-清除”或者“标记-整理”法来进行回收。</p>
<p><strong>新生代和老年代介绍：</strong></p>
<p>在Java虚拟机分代垃圾回收机制中，应用程序的堆空间可以分为新生代与老年代，然后新生代被分为Eden区，From区与To区（比例为8:1:1）</p>
<p>目前大部分垃圾收集器对于新生代都采取复制算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p>
<hr>
<p><strong>分代收集算法的具体步骤：</strong></p>
<p>在JVM分代垃圾回收机制中，将应用程序可用的堆空间分为新生代（Young Generation）和老年代（Old Generation），又将新生代分为Eden区（Eden Space），From区和To区，<strong>新建对象总是在Eden区中被创建</strong>，当Eden区空间已满，就触发一次<strong>Minor GC</strong>，将还未被使用的对象复制到From区，这样整个Eden区都是未被使用的空间，可供继续创建对象。当Eden区再次用完，再触发一次Minor GC，将Eden区和From区还在被使用的对象复制到To区，下一次的Minor GC则是将Eden区和To区还被使用的对象复制到From区。因此，经过多次Young GC，某些对象会在From区和To区多次复制，对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加超过一个阈值时，就会被移动到年老代中。如果老年空间也已用完，那么就会触发Full GC，Full GC会对系统性能产生较大影响，因此应根据系统业务特点和对象生命周期，合理设置新生代和老年大小，尽量减少Full GC。</p>
<p>在JVM垃圾回收机制中，应用程序可用的堆空间可以分为年轻代与老年代，然后年轻代有被分为Eden区，From区与To区。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200335693.png" alt="这里写图片描述"></p>
<p>当系统创建一个对象的时候，总是在Eden区操作，当这个区满了，那么就会触发一次youngGC，也就是年轻代的垃圾回收。</p>
<p>一般来说这时候不是所有的对象都没用了，所以就会把还能用的对象复制到From区。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200530361.png" alt="这里写图片描述"></p>
<p>这样整个Eden区就被清理干净了，可以继续创建新的对象，当Eden区再次被用完，就再触发一次YoungGC，然后呢，注意，这个时候跟刚才稍稍有点区别。这次触发YoungGC后，会将Eden区与From区还在被使用的对象复制到To区，</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200709299.png" alt="这里写图片描述"></p>
<p>再下一次YoungGC的时候，则是将Eden区与To区中的还在被使用的对象复制到From区。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101200920951.png" alt="这里写图片描述"></p>
<p>经过若干次YoungGC后，有些对象在From与To之间来回游荡，这时候From区与To区亮出了底线（阈值），这些家伙要是到现在还没挂掉，对不起，一起滚到（复制）老年代吧。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/20161101201239084.png" alt="这里写图片描述"></p>
<p>老年代经过这么几次折腾，也就扛不住了（空间被用完），好，那就来次集体大扫除（Full GC），也就是全量回收，一起滚蛋吧。</p>
<p>全量回收呢，就好比我们刚才比作的大扫除，毕竟动做比较大，成本高，不能跟平时的小型值日（Young GC）相比，所以如果Full GC使用太频繁的话，无疑会对系统性能产生很大的影响。</p>
<p>所以要合理设置年轻代与老年代的大小，尽量减少Full GC的操作</p>
<p>而由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记-整理算法（压缩法）。</p>
<hr>
<blockquote>
<p><strong>为什么要将java 堆分为新生代和老年代？</strong></p>
<p>对堆空间分代的目的就是优化GC性能。</p>
<p>不分代同样可以完成GC，如果没有分代，那我们所有的对象都在一块，GC的时候我们会对堆的所有区域进行扫描，找到哪些对象没用。但是我们的很多对象生命周期都比较短，如果分代的话，我们把这些新创建的对象放到某一块区域，当GC的时候先把这块区域进行回收，能优化GC性能</p>
</blockquote>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p> <strong>对象优先在 Eden 区分配</strong> </p>
<p> 大多数情况下对象在新生代 Eden 区分配，当 Eden 空间不足时将发起一次 Minor GC。 </p>
<p> <strong>大对象直接进入老年代</strong> </p>
<p> 大对象指<strong>需要大量连续内存空间的对象</strong>，例如<strong>很长的字符串</strong>或<strong>大数组</strong>，容易导致内存还有不少空间就提前触发 GC 以获得足够连续空间。 </p>
<p> HotSpot 提供了 -XX:PretenureSizeThreshold 参数，大于该值的对象直接在老年代分配，避免在 Eden 和 Survivor 间来回复制。 </p>
<p> <strong>长期存活对象进入老年代</strong> </p>
<p> 虚拟机给每个对象定义了一个<strong>对象年龄计数器</strong>，存储在<strong>对象头</strong>。如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1。对象在 Survivor 中每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。对象晋升老年代的阈值可通过 -XX:MaxTenuringThreshold 设置。 </p>
<p> <strong>动态对象年龄判定</strong> </p>
<p> 为了适应不同内存状况，虚拟机不要求对象年龄达到阈值才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。 </p>
<p> <strong>空间分配担保</strong> </p>
<p> MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。 </p>
<p> 如果不满足，虚拟机会查看 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将冒险尝试一次 Minor GC，否则改成一次 FullGC。 </p>
<p> 冒险是因为新生代使用复制<a href="">算法</a>，只用一个 Survivor，大量对象在 Minor GC 后仍然存活时需要老年代接收 Survivor 无法容纳的对象。</p>
<h2 id="15-Minor-GC（Young-GC）-和-Full-GC-有什么不同呢？"><a href="#15-Minor-GC（Young-GC）-和-Full-GC-有什么不同呢？" class="headerlink" title="15. Minor GC（Young GC） 和 Full GC 有什么不同呢？"></a>15. Minor GC（Young GC） 和 Full GC 有什么不同呢？</h2><p><strong>Minor GC触发条件：</strong>当Eden区满时，触发Minor GC。 </p>
<p><strong>Full GC触发条件</strong>： 当老年代空间不足时，触发Full GC。</p>
<h2 id="对象进入老年代的四种情况"><a href="#对象进入老年代的四种情况" class="headerlink" title="对象进入老年代的四种情况"></a>对象进入老年代的四种情况</h2><p>(1) <strong>假如进行Minor GC时发现，存活的对象在To区中存不下，那么把存活的对象存入老年代</strong></p>
<p>(2) <strong>大对象直接进入老年代</strong></p>
<p>假设新创建的对象很大，比如为5M(这个值可以通过PretenureSizeThreshold这个参数进行设置，默认3M)，那么即使Eden区有足够的空间来存放，也不会存放在Eden区，而是直接存入老年代</p>
<p>(3) <strong>长期存活的对象将进入老年代</strong></p>
<p>此外，如果对象在Eden出生并且经过1次Minor GC后仍然存活，并且能被To区容纳，那么将被移动到To区，并且把对象的年龄设置为1，对象没”熬过”一次Minor GC(没有被回收，也没有因为To区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数-XX:MaxTenuringThreshold)，就会被晋升到老年代中</p>
<p>(4) <strong>动态对象年龄判定</strong></p>
<p>还有一种情况，如果在From空间中，相同年龄所有对象的大小总和大于Survivor空间的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到15岁(默认)：</p>
<h2 id="11-有哪几种垃圾回收器，各自的优缺点是什么？"><a href="#11-有哪几种垃圾回收器，各自的优缺点是什么？" class="headerlink" title="11. 有哪几种垃圾回收器，各自的优缺点是什么？"></a>11. 有哪几种垃圾回收器，各自的优缺点是什么？</h2><p>适用于新生代：serial（单线程、STW）、ParNew（多线程、STW）、Parallel Scavenge（多线程、NO STW）、G1（）</p>
<p>适用于老年代：serial old（单线程、STW）、CMS（多线程、最短回收停顿时间）、Parallel old（并行、NOSTW）、 G1 （）</p>
<p>垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。</p>
<p>1.Serial/Serial Old收集器 是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p>
<p>2.ParNew收集器 是Serial收集器的多线程版本，也会暂停正在执行的线程，使用多个线程进行垃圾收集。</p>
<p>3.Parallel Scavenge收集器 是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p>
<p>4.Parallel Old收集器 是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p>
<p>5.CMS（Concurrent Mark Sweep）收集器 是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器，它是一种并发收集器，采用的是标记清除算法。</p>
<p>6.G1收集器 是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p>
<p><strong>垃圾回收器间的配合使用图：</strong> </p>
<p><img src="https://pic4.zhimg.com/80/v2-25cb5804757e48387305cb1501739623_1440w.jpg" alt="img"></p>
<h2 id="12-CMS垃圾收集器"><a href="#12-CMS垃圾收集器" class="headerlink" title="12. CMS垃圾收集器"></a>12. CMS垃圾收集器</h2><p><strong>STW介绍：</strong></p>
<p>Stop-The-World机制简称STW，是指除了垃圾回收线程外的其他线程都被挂起，在GC时我们希望尽可能减少STW的时间。</p>
<p><strong>CMS收集器介绍</strong>：</p>
<p>CMS(Concurrent Mark Sweep，并发标记清除) 收集器主要目的<strong>是想获取最短的STW的时间</strong>，即便会牺牲一些应用程序的吞吐量，对于要求服务器<strong>响应速度</strong>的应用上，这种垃圾回收器非常适合。因为CMS在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。 </p>
<blockquote>
<p> 注意：“标记”是指将存活的对象和要回收的对象都给标记出来，而“清除”是指清除掉将要回收的对象。</p>
</blockquote>
<p>从名字就可以知道，CMS是基于“<strong>标记-清除</strong>”算法实现的。<strong>CMS</strong>（老年代）默认与<strong>ParNew</strong>（新生代）搭配使用</p>
<p><strong>CMS 回收过程</strong>： </p>
<ul>
<li><p><strong>初始标记</strong> ：标记与GC Root直接关联到的对象，这一步跟 GC Root 直接关联的对象不会很多，这个过程其实很快。（有STW）</p>
</li>
<li><p><strong>并发标记</strong> ：对第一步中初始标记过的对象，向下继续追踪，标记哪些关联的对象。用户线程和并发标记的线程是并发执行的。（没有STW）</p>
</li>
<li><p><strong>重新标记</strong> ：为了修正并发标记阶段用户线程继续运行而带来的垃圾，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，但远远比并发标记阶段时间短。（有STW）重新标记是标记前两个阶段新产生的对象？</p>
</li>
<li><p><strong>并发清理</strong> ：清理垃圾对象，这个阶段GC线程和应用程序线程并发执行。（没有STW）</p>
</li>
<li><p><strong>并发重置</strong> ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。</p>
</li>
</ul>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/a8445398-e010-4864-82e2-41e2095c2b33.jpg" alt="CMS垃圾回收过程"></p>
<p><strong>CMS主要优点</strong>：<strong>并发收集、低停顿。</strong></p>
<p><strong>CMS 的问题：</strong> </p>
<p><strong>1. 并发回收导致CPU资源紧张：</strong> </p>
<p>在并发阶段，垃圾回收线程会和用户线程一起抢占CPU，降低程序总吞吐量。</p>
<p><strong>2. 无法清理浮动垃圾：</strong></p>
<p>在并发的阶段用户线程仍会产生垃圾，这些垃圾被称为浮动垃圾，直到下一次垃圾回收时才被清理。</p>
<p>浮动垃圾还是理解的不够透彻</p>
<p>在CMS的并发标记和并发清理阶段，用户线程还在继续运行，在这个过程中，一些对象开始被判定为非垃圾，但之后变成了垃圾，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。 </p>
<p>思考一个问题：<strong>浮动垃圾是怎么产生的？</strong></p>
<p><strong>3.内存碎片问题：</strong> </p>
<p>CMS是一款基于“<strong>标记-清除</strong>”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦。</p>
<h2 id="13-G1垃圾收集器"><a href="#13-G1垃圾收集器" class="headerlink" title="13. G1垃圾收集器"></a>13. G1垃圾收集器</h2><p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/image-20211011160511149.png" alt="image-20211011160511149"></p>
<p>G1（Garbage First）回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。在新生代和老年代都可以进行使用</p>
<p>以往对于Java堆区域的划分为：<strong>新生代和老年代，新生代又划分为 Eden区和from和to区</strong>，而G1是把连续的Java堆空间划分为多个大小相等的独立区域，每个独立区域称为Region，每个Region都可以成为 Eden空间、Survivor空间、老年代空间。</p>
<p>基于这种划分方式，G1在回收时以Region作为最小的回收单位，它首先会衡量哪块Region中垃圾最多，回收带来的收益最大，<strong>每次回收时优先处理回收价值最大的Region</strong>，这也是G1(Garabage First)名字的由来</p>
<p><strong>G1 回收过程</strong>：</p>
<p>除了并发标记，其他阶段都会STW</p>
<ol>
<li><strong>初始标记</strong>（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。 </li>
<li><strong>并发标记</strong>：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。 </li>
<li><strong>最终标记</strong>（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。 </li>
<li><strong>清理阶段</strong>（会STW）：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。 </li>
</ol>
<h2 id="G1和CMS的区别（3个）"><a href="#G1和CMS的区别（3个）" class="headerlink" title="G1和CMS的区别（3个）"></a>G1和CMS的区别（3个）</h2><p>从GC算法、堆内存划分方式、适用于新生代还是老年代</p>
<ul>
<li>G1从整体上来看是 标记-整理 算法，但从局部（两个Region之间）是复制算法。而CMS是 标记-清除算法 。因此，G1不会产生内存碎片，而CMS会产生内存碎片</li>
<li>CMS对Java堆内存使用的是传统的新生代和老年代划分方法，而G1对堆内存按照Region进行划分。</li>
<li>CMS收集器是老年代收集器，可以配合新生代的Serial和ParNew收集器一起使用。G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用</li>
</ul>
<h2 id="14-JVM中一次完整的GC是什么样子的？"><a href="#14-JVM中一次完整的GC是什么样子的？" class="headerlink" title="14. JVM中一次完整的GC是什么样子的？"></a>14. JVM中一次完整的GC是什么样子的？</h2><p>先描述一下Java堆内存划分。 </p>
<p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的 1/3，老年代默认占 2/3。 新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。 </p>
<p>新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。 </p>
<p>老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。 </p>
<p><img src="https://pic2.zhimg.com/80/v2-f2a086e09f8bb950b63381145f6f16c2_1440w.jpg" alt="img"></p>
<p>再描述它们之间转化流程。 </p>
<ul>
<li>对象优先在Eden分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。<ul>
<li>在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；</li>
<li>Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制 到 to 区； </li>
<li>移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。GC年龄的阀值可以 通过参数 -XX:MaxTenuringThreshold 设置，默认为 15；</li>
<li>动态对象年龄判定：Survivor 区相同年龄所有对象大小的总和 &gt; (Survivor 区内存大小 * 这个 目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 - XX:TargetSurvivorRatio 指定，默认为 50%； </li>
<li>Survivor 区内存不足会发生担保分配，超过指定大小的对象可以直接进入老年代。 </li>
</ul>
</li>
<li>大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 </li>
<li>老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – <strong>包括年轻代和老年代</strong>。</li>
</ul>
<h2 id="16-介绍下空间分配担保原则？"><a href="#16-介绍下空间分配担保原则？" class="headerlink" title="16. 介绍下空间分配担保原则？"></a>16. 介绍下空间分配担保原则？</h2><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlerPromotionFailure这个参数设置的值(true或flase)是否允许担保失败(如果这个值为true，代表着JVM说，我允许在这种条件下尝试执行Minor GC，出了事我负责)。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlerPromotionFailure为false，那么这次Minor GC将升级为Full GC</p>
<p>如果老年代最大可用的连续空间大于历次晋升到老年代对象的平均大小，那么在HandlerPromotionFailure为true的情况下，可以尝试进行一次Minor GC，但这是有风险的，如果本次将要晋升到老年代的对象很多，那么Minor GC还是无法执行，此时还得改为Full GC。</p>
<hr>
<p>如果YougGC时新生代有大量对象存活下来，而 survivor 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。 </p>
<p>在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 survivor 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。 </p>
<p>在允许担保失败并尝试进行YoungGC后，可能会出现三种情况： </p>
<ul>
<li><p>① YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中 </p>
</li>
<li><p>② YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。 </p>
</li>
<li><p>③ YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。 </p>
</li>
</ul>
<p>通过下图来了解空间分配担保原则： </p>
<p><img src="https://pic2.zhimg.com/80/v2-230afbe3d56d81be16ec7cd9b4d126d9_1440w.jpg" alt="img"></p>
<h2 id="17-什么是类加载？类加载的过程？"><a href="#17-什么是类加载？类加载的过程？" class="headerlink" title="17. 什么是类加载？类加载的过程？"></a>17. 什么是类加载？类加载的过程？</h2><p>在类加载之前，人们把.java文件通过java编译器（javac.exe）编译成.class文件，这个就是所说的字节码文件。</p>
<p>接着进行类加载。</p>
<p>我们知道，我们编写的java程序首先被java编译器（javac.exe）编译成.class文件，而类加载过程</p>
<p><strong>类的加载</strong>指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆中创建这个类的Class对象，这就是类的加载过程，也就是说<strong>类的加载的最终产品是位于堆区中的Class对象，而Class对象相当于一个接口，可以用来访问方法区内的数据</strong></p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/331425-20160621125941772-1913742708.png" alt="类加载"></p>
<p>类加载的五个过程：<strong>加载、验证、准备、解析、初始化</strong></p>
<p>为支持运行时绑定，解析过程在某些情况下可在初始化之后再开始，除解析过程外的其他加载过程必须按照如图顺序开始。如图所示：</p>
<p><img src="https://pica.zhimg.com/v2-428183fb231daeaf4571dabf2a19af8c_b.jpg" alt="img"></p>
<p><strong>加载</strong><br>在加载阶段，虚拟机主要完成三件事：</p>
<ul>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
</ul>
<ul>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区数据的访问入口。</li>
</ul>
<p><strong>验证</strong><br><strong>验证阶段是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，不会对虚拟机造成危害</strong>。验证过程分为四个阶段：</p>
<ul>
<li><p>文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。</p>
</li>
<li><p>元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范要求</p>
</li>
<li><p>字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。</p>
</li>
<li><p>符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。</p>
</li>
</ul>
<p><strong>准备</strong><br><strong>准备阶段为类的静态变量分配内存，并将其初始化为默认值</strong>。假设一个类变量的定义为：public static int value = 3； 那么变量value在准备阶段过后的初始值为0，而不是3，但final修饰的类变量将会赋值成真实的值。</p>
<p><strong>解析</strong><br><strong>解析过程是把类中的符号引用转换为直接引用。</strong>主要包括四种类型引用的解析。类或接口的解析、字段解析、方法解析、接口方法解析。</p>
<p><strong>初始化</strong><br><strong>对类的静态变量进行初始化赋值，静态代码块执行初始化操作</strong>，赋予真正的初值。在准备阶段，类变量被初始化为零值。</p>
<p>至于使用和卸载阶段阶段，这里不再过多说明，使用过程就是根据程序定义的行为执行，卸载由GC完成。</p>
<h2 id="18-什么是类加载器，常见的类加载器有哪些？"><a href="#18-什么是类加载器，常见的类加载器有哪些？" class="headerlink" title="18. 什么是类加载器，常见的类加载器有哪些？"></a>18. 什么是类加载器，常见的类加载器有哪些？</h2><p>类加载器：把实现类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作的代码模块称为“类加载器”。</p>
<p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分</li>
<li>所有其它类的加载器，使用 Java 实现，独立于虚拟机，并且全部继承自抽象类 java.lang.ClassLoader。</li>
</ul>
<p><strong>类加载器分为以下四种：</strong> </p>
<ul>
<li>启动类加载器（BootStrapClassLoader）：用来加载java核心类库，无法被java程序直接引用； </li>
<li>扩展类加载器（Extension ClassLoader）：用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类； </li>
<li>应用程序类加载器（AppClassLoader）：它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的； </li>
<li>自定义类加载器：由java语言实现，继承自ClassLoader； </li>
</ul>
<p>类加载器按照层次，从顶层到底层的顺序（<strong>如图只是类加载的层次顺序，和类继承无关</strong>）：</p>
<img src="https://pic4.zhimg.com/v2-64c33143d2d28029df7e6ea37659dce0_b.jpg" alt="img" style="zoom: 80%;" />

<h2 id="19-什么是双亲委派模型？为什么需要双亲委派模型？"><a href="#19-什么是双亲委派模型？为什么需要双亲委派模型？" class="headerlink" title="19. 什么是双亲委派模型？为什么需要双亲委派模型？"></a>19. 什么是双亲委派模型？为什么需要双亲委派模型？</h2><p><strong>运行流程：</strong></p>
<p>当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，一层一层向上，请求最终到达顶层的启动类加载器，只如果父类加载器可以完成类加载任务，就<strong>成功返回</strong>，倘若父类加载器无法完成此加载任务，<strong>子加载器才会尝试自己去加载</strong>，如果都没找到则会抛出ClassNotFound异常，这就是双亲委派模型。</p>
<p><img src="/images/7-30jvm%E5%AD%A6%E4%B9%A0/src=http%253A%252F%252Fwww.west.cn%252Finfo%252Fupload%252F20191016%252F4wjcrsxfmj0.jpg&refer=http%253A%252F%252Fwww.west.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="双亲委派模型"></p>
<p>为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。 </p>
<p><strong>类的唯一性：</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在JVM中的唯一性。</p>
<p>即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。</p>
<p><strong>双亲委派模型的好处（为什么需要双亲委派模型）</strong>：</p>
<ul>
<li>Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>，通过这种层级关可以<strong>避免类的重复加载</strong>，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>
<li>其次是考虑到安全因素，<strong>防止核心API库被随意篡改</strong>。假设通过网络传递一个名java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以<strong>防止核心API库被随意篡改</strong>。</li>
</ul>
<p><strong>怎么打破双亲委派模型</strong>？ </p>
<p>自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。 </p>
<h2 id="20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？"><a href="#20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？" class="headerlink" title="20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？"></a>20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</h2><ul>
<li><p>JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。 </p>
</li>
<li><p>Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。<br>  tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的： </p>
</li>
</ul>
<ul>
<li><ul>
<li><p>对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。 </p>
</li>
<li><p>与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏； </p>
</li>
<li><p>热部署。 </p>
</li>
</ul>
</li>
</ul>
<p>tomcat类加载器如下图： </p>
<p><img src="https://pic2.zhimg.com/80/v2-0f8b46ab0eef7d30938798eebb401dbb_1440w.jpg" alt="img"></p>
<ul>
<li><p>OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。 </p>
</li>
<li><p>JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。 </p>
</li>
</ul>
<h2 id="21-说一下-JVM-调优的命令？"><a href="#21-说一下-JVM-调优的命令？" class="headerlink" title="21.说一下 JVM 调优的命令？"></a>21.说一下 JVM 调优的命令？</h2><ul>
<li><p>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 </p>
</li>
<li><p>jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 </p>
</li>
<li><p>jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。 </p>
</li>
<li><p>jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。 </p>
</li>
<li><p>jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">pb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/30/7-30jvm学习/">http://example.com/2021/07/30/7-30jvm学习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">pb</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="social-share pull-right" data-disabled="google,twitter,facebook,douban,instagram,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/07/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"><i class="fa fa-chevron-left">  </i><span>十大经典排序算法</span></a></div><div class="next-post pull-right"><a href="/2021/07/28/cpu%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/"><span>cpu、寄存器、缓存、内存概念</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '52a38b388c08f769c0fe',
  clientSecret: '5428c9a58faaa3488201c1791496427b41deb385',
  repo: 'jiubukaiji.github.io',
  owner: 'jiubukaiji',
  admin: 'jiubukaiji',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By pb</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>