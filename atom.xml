<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pb</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-07T03:49:21.807Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafka相关</title>
    <link href="http://example.com/2021/11/07/kafka%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/11/07/kafka%E7%9B%B8%E5%85%B3/</id>
    <published>2021-11-07T02:26:32.000Z</published>
    <updated>2021-11-07T03:49:21.807Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一点kafka相关面试题</p><p>guide哥、3y哥，敖丙哥，入门必看，接着再看其他文章深入理解</p></blockquote><a id="more"></a><p>kafka起初的角色是一个消息系统，由LinkedIn公司开发，现在已经捐献给Apache软件基金会，目前的定位应该是一个分布式的流处理平台，不过最流行的还是作为一个消息系统的角色，</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录一点kafka相关面试题&lt;/p&gt;
&lt;p&gt;guide哥、3y哥，敖丙哥，入门必看，接着再看其他文章深入理解&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>11.01</title>
    <link href="http://example.com/2021/11/01/11-01/"/>
    <id>http://example.com/2021/11/01/11-01/</id>
    <published>2021-11-01T13:26:39.000Z</published>
    <updated>2021-11-07T02:31:25.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>呱呱呱</p></blockquote><p>down了down了。</p><p>其实也很正常，你个非科班的花俩月时间（而且还是断断续续的），就能找到好实习，如果有这么简单，要么你就是神仙，要么你当那些科班的学了好几年的是傻子呀~</p><p>不过话说回来，这段时间对于一些基础的知识认识更加清晰了，也积累了一些面试的经验（被面试毒打），总归是很不错的。</p><p>不免有一丝丝动摇了我未来的职业规划。</p><p>以后再说吧，总之还没有结束呢，还有一堆简历在池子里，看能不能被捞吧。。。</p><hr><p>虽然但是，为什么字节一面还给我过了。迷。。</p><p>准备接受第二顿毒打</p><hr><p>当你犹豫不决不知道要不要学这个东西的时候就去做，</p><p>多学点东西，不寒碜。</p><p>直接去做，少想少说话多做事</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;呱呱呱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;down了down了。&lt;/p&gt;
&lt;p&gt;其实也很正常，你个非科班的花俩月时间（而且还是断断续续的），就能找到好实习，如果有这么简单，要么你就是神仙，要么你当那些科班的学了好几年的是傻子呀~&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis相关</title>
    <link href="http://example.com/2021/10/30/Redis%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/30/Redis%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-30T01:52:52.000Z</published>
    <updated>2021-11-07T07:17:27.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一点Redis相关面试题</p></blockquote><a id="more"></a><p><a href="https://www.nowcoder.com/discuss/780303?type=post&amp;order=time&amp;pos=&amp;page=0&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack">https://www.nowcoder.com/discuss/780303?type=post&amp;order=time&amp;pos=&amp;page=0&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</a> </p><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><p>Redis（<code>Remote Dictionary Server</code>）是一个使用 C 语言编写的，高性能的、非关系型数据库，与mysql这种传统数据库不同的是，Redis存取的是键值对，并且Redis 的数据是存在内存中的，所以读写速度非常快，被广泛应用于缓存方向。同时，Redis可以将数据写入磁盘中，保证了数据的安全，也就是数据持久化。</p><p>Redis中存储的是键值对，可以存储键和五种不同类型的值，键的类型只能为字符串，值支持五种数据类型：String、List、Hash、Set、SortedSet。</p><p>Redis还可以用来作<strong>缓存</strong>、<strong>分布式锁</strong>、<strong>消息队列</strong>，支持不同的业务场景。</p><p><strong>分布式缓存</strong>：</p><p><strong>分布式锁：</strong></p><p><strong>消息队列：</strong></p><ul><li>通过List类型中的lpush、rpop命令实现 </li></ul><p>但使用 List 同样存在一定的问题，比如消息不支持重复消费、没有按照主题订阅的功能、不支持消费消息确认等。</p><ul><li><p>通过发布-订阅模式，可以让一个消费者订阅多个生产者</p><p>发布消息，publish channel “message”</p><p>订阅消息，subscribe channel</p></li></ul><h2 id="Redis优缺点？（Redis的功能和不足）"><a href="#Redis优缺点？（Redis的功能和不足）" class="headerlink" title="Redis优缺点？（Redis的功能和不足）"></a>Redis优缺点？（Redis的功能和不足）</h2><p><strong>优点</strong>：</p><ol><li><strong>基于内存操作</strong>，内存读写速度很快。 </li><li>Redis是<strong>单线程</strong>的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，即一个线程处理所有网络请求，Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。 </li><li>有一套<strong>过期数据的删除策略和内存淘汰机制</strong>保证不会发生内存不足。</li><li><strong>支持多种数据类型</strong>，包括String、List、Hash、Set、SortedSet等。 </li><li><strong>支持持久化</strong>。Redis支持<strong>RDB</strong>和<strong>AOF</strong>两种持久化机制，可以有效地避免数据丢失问题。 </li><li><strong>支持事务</strong>。Redis的所有操作命令都是原子性的， Redis的事务不支持原子性。</li><li><strong>支持主从复制</strong>。主节点会自动将数据同步到从节点，可以进行读写分离。 </li></ol><p><strong>缺点</strong>：</p><ol><li>对结构化查询的支持比较差。 </li><li>数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。 </li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ol><h2 id="为什么Redis这么快？"><a href="#为什么Redis这么快？" class="headerlink" title="为什么Redis这么快？"></a>为什么Redis这么快？</h2><ul><li><p><strong>基于内存</strong>：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</p></li><li><p><strong>单线程实现</strong>（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。</p></li><li><p><strong>IO多路复用模型</strong>：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。</p></li><li><p><strong>高效的数据结构</strong>：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</p></li></ul><h2 id="Redis单线程模型介绍（完成未理解）"><a href="#Redis单线程模型介绍（完成未理解）" class="headerlink" title="Redis单线程模型介绍（完成未理解）"></a>Redis单线程模型介绍（完成未理解）</h2><p><strong>为什么说Redis是单线程模型呢？</strong></p><p>我们说Redis是单线程的，指的是执行 <strong>Redis 命令的核心模块</strong>是单线程的，而不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。</p><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为<strong>文件事件处理器</strong>。它的组成结构为4部分：<strong>多个套接字、IO多路复用程序、文件事件分派器、事件处理器</strong>。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型”</p><p><code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当被监听的<code>socket</code>准备好执行<code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code>等操作时，与这些操作相对应的文件事件就会产生。<code>IO</code>多路复用程序会把所有产生事件的<code>socket</code>压入一个队列中，然后有序地每次仅一个<code>socket</code>的方式传送给文件事件分派器，文件事件分派器接收到<code>socket</code>之后会根据<code>socket</code>产生的事件类型调用对应的事件处理器进行处理。</p><p> Redis通过socket与客户端进行连接，并将服务器对socket的操作抽象为文件事件。redis通过单线程，并通过I/O多路复用来处理来自客户端的多个连接请求，当产生连接后，i/o多路复用程序，会将产生事件的套接字放置一个队列，通过队列以有序、同步的、每次一个套接字的方式向文件事件分派发器传送套接字。当上一个套接字的事件被处理完毕后，I/O多路复用才会向文件分派器传送下一个套接字。服务端通过监听这些事件，并完成相应的处理。被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作，与操作相关的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p>可以看出，文件事件处理器（file event handler）主要是包含4个部分：</p><ul><li>多个 socket（客户端连接）  <strong>socket是什么东东？</strong></li><li>IO多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket关联到相应的事件处理器）</li><li>·事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><img src="/images/Redis%E7%9B%B8%E5%85%B3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jldml2ZWRzdW4=,size_16,color_FFFFFF,t_70.png" alt="https://img-blog.csdnimg.cn/20190822004147554.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jldml2ZWRzdW4=,size_16,color_FFFFFF,t_70" style="zoom: 50%;" /><p><strong>为什么Redis选择单线程模型呢？</strong></p><p>Redis 选择使用单线程模型处理客户端的请求，主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，而且多线程就会存在死锁、线程上下文切换等问题。</p><p>而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p><p><strong>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</strong></p><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <strong>I/O 多路复用</strong>就是为了解决这个问题而出现的。</p><p><strong>IO多路复用技术的理解</strong></p><p>IO 多路复用机制是指一个线程处理多个 IO 流，简单来说就是<code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当哪个socket执行操作后会将其交给相应的事件处理器。</p><h2 id="为什么又说Redis中有多线程呢？"><a href="#为什么又说Redis中有多线程呢？" class="headerlink" title="为什么又说Redis中有多线程呢？"></a>为什么又说Redis中有多线程呢？</h2><p>在Redis 4.0 版本开始就有多线程的概念了，比如 Redis 通过<strong>多线程方式在后台删除一些比较大的键值对</strong></p><p>在Redis 6.0 版本 里的多线程主要是为了提高网络IO读写性能， 执行命令的核心模块还是单线程的，因为Redis性能主要受限于内存和网络IO。</p><p>IO 多线程处理模式默认是不开启的，需要去配置文件中开启并配置线程数</p><p><strong>为什么网络处理要引入多线程？</strong></p><p>前面有提到过，<strong>Redis 的瓶颈并不在 CPU，而在内存和网络。</strong></p><p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p><h2 id="Redis的数据结构和应用场景"><a href="#Redis的数据结构和应用场景" class="headerlink" title="Redis的数据结构和应用场景"></a>Redis的数据结构和应用场景</h2><p>Redis有5种数据类型：String 、List（双向链表）、Hash（键值对）、Set（不重复）、SortedSet（排序不重复）</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/1289934-20190621163930814-1395015700.png" alt="img"></p><p><strong>String</strong></p><p>String是最简单的Key-value类型，存储的是字符串。一个字符串类型的值能存储最大容量是<strong>512M</strong>。</p><p>底层是一个简单的动态字符串，和C语言的字符串有区别，空间不足会自动扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line">exists key</span><br><span class="line">strlen key</span><br><span class="line">del key</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong>：一般用在需要计数的场景，比如用户的访问次数、文章的点赞数等等</p><p><strong>List</strong></p><p>List是一个双向链表</p><p><strong>应用场景</strong>：发布与订阅</p><p><strong>rpush 和 lpop 实现队列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush key value1 value2 Value3 从右边添加</span><br><span class="line">lpop key     从左边取出</span><br><span class="line">&quot;value&quot; </span><br><span class="line">lrange key 0 1  从左到右查看  ,0 是开始， 1是结束</span><br><span class="line">&quot;value2&quot; &quot;value3&quot; </span><br><span class="line">lrange key 0 -1 查看列表中所有元素  -1是倒数第一个</span><br></pre></td></tr></table></figure><p><strong>rpush 和 rpop实现栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpush myList2 value1 value2 value3</span><br><span class="line">rpop myList2  # 将 list的头部(最右边)元素取出</span><br><span class="line">&quot;value3&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105165407904.png" alt="image-20211105165407904"></p><p><strong>Hash</strong></p><p>Hash 它的 value 是一个键值对。适用于存储对象，方便修改对象的某个属性值。</p><p><strong>应用场景</strong>：存储对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset userInfoKey name &quot;guide&quot; description &quot;dev&quot; age &quot;24&quot; </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存 在。 (integer) 1 </span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name # 获取存储在哈希表中指定字段的值。 </span><br><span class="line">&quot;guide&quot; </span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age </span><br><span class="line">&quot;24&quot; </span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey # 获取在哈希表中指定 key 的所有字段和值</span><br></pre></td></tr></table></figure><p>**Set **</p><p>set主要存取不重复的元素。还提供了<strong>取交集、并集、差集</strong>的操作。</p><p><strong>使用场景</strong>：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 # 添加元素进去</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 # 不允许有重复元素</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet # 查看 set 中所有的元素</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard mySet # 查看 set 的⻓度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并</span><br><span class="line">存放在 mySet3 中</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>Sorted Set</strong></p><p>和 set 相比，sorted set 增加了⼀个权重参数 score，使得集合中的元素能够按 score 进行排序，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 的TreeSet 。</p><p><strong>适用场景</strong>：适用于排行榜这个场景，比如玩家游戏分数排行，微博热搜排行，最新评论按时间排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 # ⼀次添加多个元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset # 查看 sorted set 中的元素数量</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 # 查看某个 value 的权重</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange myZset 0 -1 # 顺序输出某个范围区间的元素，0 -1 表示输出所有元</span><br><span class="line">素</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange myZset 0 1 # 顺序输出某个范围区间的元素，0 为 start 1 为</span><br><span class="line">stop</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure><p><strong>sorted set 的底层实现</strong></p><p>SortedSet底层使用到了<strong>skipList跳跃表</strong>这种数据结构</p><p>跳表是为了让链表的查找更快而诞生的一种数据结构，最底层链表包括全部的元素，在底层链表的基础上向上抽取出一些节点形成一个多层的链表，可以提高我们的查找效率。</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/151152187209308.jpg" alt="img"></p><p>当我们查找时，从最上层开始查找，如果发现当前值比目标值大就往下一层并往后搜索，平均的时间复杂度是O（logn），与红黑树相比，逻辑更加简单，实现和维护起来也更加方便。</p><h2 id="Redis为什么要给数据设置过期时间？"><a href="#Redis为什么要给数据设置过期时间？" class="headerlink" title="Redis为什么要给数据设置过期时间？"></a>Redis为什么要给数据设置过期时间？</h2><p><strong>如何设置过期时间</strong>？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set aa bb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire aa 60  # 设置过期时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl aa   # 查看过期时间</span><br><span class="line">(integer) 58</span><br><span class="line">127.0.0.1:6379&gt; persist aa  # 移除过期时间，设为永不过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex aa 100 bb  # set 和 expire 的合并操作</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li>内存有限，如果缓存中的所有数据都是一直保存的话，内存会不足</li><li>用于一些要求数据有时效性的场景，比如验证码功能，我们希望它只是在一段时间内有效</li></ul><p><strong>Redis如何判断数据是否过期呢？</strong></p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105182448638.png" alt="image-20211105182448638"></p><p>从图可知，在redis的数据库中，redisDb结构中的expires字典中保存了数据库中所有键的过期时间，所以叫过期字典。</p><ul><li>过期字典的key是一个指针，指向键空间的某个键对象（就是数据库键）</li><li>过期字典的value是一个long类型的整数，这个整数保存了键所指向的数据库键的过期时间，一个毫秒精度的UNIX时间戳</li></ul><p>通过过期字典，我们可以得到一个key是否过期：</p><ul><li>判断key是否存在于过期字典中</li><li>通过过期字典拿到key的过期时间，判断当前UNIX时间戳是否大于key时间</li></ul><h2 id="过期数据的删除策略是怎样的？"><a href="#过期数据的删除策略是怎样的？" class="headerlink" title="过期数据的删除策略是怎样的？"></a>过期数据的删除策略是怎样的？</h2><p>主要有两种：</p><ul><li><strong>惰性删除</strong>：每次获取key时才会对key进行判断是否存活，如果已经过期了则删除。这样对CPU最友好，但是如果有key过期了没有被取到就会被遗漏，累积下来可能会造成太多过期key没有被删除</li><li><strong>定期删除</strong>：每隔一段时间随机抽取一批设置了过期时间的key，如果已经过期则删除。<br><strong>为什么是随机抽取？</strong> 因为如果存储了大量数据，全部遍历一遍是非常影响性能的！</li></ul><p>redis中使用的是<strong>惰性删除+定期删除</strong>的策略</p><p>但是这样的删除策略还是有问题的，因为无论是惰性删除还是定期删除，都会发生漏掉过期 key 的情况。这样就导致大量过期 key 堆积在内存里，导致内存不足，这时候我们就需要用<strong>Redis内存淘汰机制</strong>。</p><h2 id="Redis内存淘汰机制（8种）"><a href="#Redis内存淘汰机制（8种）" class="headerlink" title="Redis内存淘汰机制（8种）"></a>Redis内存淘汰机制（8种）</h2><p><strong>当MySQL里有2000W数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</strong></p><p>答：redis内存数据集大小上升到一定大小的时候，就会施行<strong>数据淘汰策略。</strong></p><p>当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略。（4种volatile开头的，3种allkeys开头的，还有一种拒绝写入）</p><p>没有配置时，默认为no-eviction</p><ul><li><p>volatile-lru    从<strong>已设置过期时间</strong>的数据集中挑选<strong>最近最少使用</strong>的数据淘汰</p></li><li><p>volatile-lfu    从<strong>已设置过期时间</strong>的数据集中挑选<strong>最不经常使用</strong>的数据淘汰</p></li><li><p>volatile-ttl    从<strong>已设置过期时间</strong>的数据集中挑选<strong>将要过期</strong>的数据淘汰</p></li><li><p>volatile-random    从<strong>已设置过期时间</strong>的数据集中挑选<strong>任意</strong>数据淘汰</p></li><li><p>allkeys-lru    从所有key中淘汰<strong>最近最少</strong>使用的Key（最常用的）</p></li><li><p>allkeys-lfu    从所有key中淘汰<strong>最不经常使用</strong>的Key</p></li><li><p>allkeys-random    从所有key中<strong>随机</strong>选择key淘汰</p></li><li><p>no-eviction    当内存不足以写入新数据时，新写入操作会报错</p></li></ul><p>volatile为前缀的策略都是从 <strong>已设置过期的数据集</strong> 中进行淘汰。<br>allkeys为前缀的策略都是 <strong>面向所有key</strong> 进行淘汰。<br>LRU（least recently used）最近最少用到的。<br>LFU（Least Frequently Used）最不常用的。<br>它们的触发条件都是Redis使用的内存达到阈值时。</p><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><p>持久化就是把<strong>内存的数据写到磁盘中</strong>，防止Redis服务器发生故障导致内存数据丢失。</p><p>Redis 的持久化机制有两种，第一种是<strong>RDB快照</strong>，第二种是 <strong>AOF 日志</strong>。</p><ul><li><p>RDB快照就是将<strong>内存中的数据</strong>以快照的方式写入到二进制文件中，并保存到磁盘。</p></li><li><p>AOF日志就是以日志的方式将<strong>每个操作指令</strong>记录到文件中，并保存到磁盘。</p></li></ul><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><p>RDB快照是某个时间点的一次全量数据备份，是二进制文件，在存储上非常紧凑。</p><p><code>RDB</code>是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个<code>dump.rdb</code>文件。Redis 重启会加载<code>dump.rdb</code>文件恢复数据。</p><img src="/images/Redis%E7%9B%B8%E5%85%B3/rdb%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="img" style="zoom:80%;" /><p><strong>RDB执行流程</strong></p><ul><li><p>执行<code>BGSAVE</code>命令 ，Redis 父进程判断当前<strong>是否子进程正在执行持久化任务</strong>，如果存在，<code>BGSAVE</code>命令直接返回。 </p></li><li><p>父进程执行<code>fork</code>操作<strong>创建子进程</strong>，fork操作过程中父进程会阻塞。 （仅仅只创建子进程的这个过程，不影响后续操作）</p></li><li><p>父进程<code>fork</code>完成后，<strong>父进程继续接收并处理客户端的请求</strong>，而<strong>子进程开始将内存中的数据写进硬盘的临时文件</strong>； </p></li><li><p>当子进程写完所有数据后会<strong>用该临时文件替换旧的 RDB 文件</strong>。</p></li></ul><p><strong>触发机制</strong></p><p>RDB持久化触发机制分为：<strong>手动触发</strong>和<strong>自动触发</strong> </p><p><strong>手动触发</strong></p><p>用户执行<code>SAVE</code>或<code>BGSAVE</code>命令。</p><p><code>SAVE</code>命令的执行过程会阻塞所有客户端的请求，我们一般不采用这种方式。</p><p><code>BGSAVE</code>命令可以在后台异步操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用<code>BGSAVE</code>命令。</p><p><strong>自动触发</strong></p><p>有以下情况会自动触发RDB快照：</p><ul><li>我们可以在redis.conf这个配置文件中配置，比如SAVE 100 10，100秒内至少有10个键被修改则进行快照。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作</span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br><span class="line"># 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、</span><br><span class="line"># 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave</span><br></pre></td></tr></table></figure><ul><li><p>执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，那么会自动执行一次bgsave</p></li><li><p>主从同步的时候，如果从节点执行复制操作，主节点会自动执行BGSAVE生成 RDB 文件并发送给从节点。</p></li></ul><p><strong>RDB的优缺点</strong></p><p><strong>优点</strong></p><ul><li>Redis加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的是内存数据，而AOF文件中存储的是一条条命令，需要重演命令。</li><li>使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，<strong>保证了 Redis 的高性能</strong>。</li></ul><p><strong>缺点</strong></p><ul><li>RDB<strong>无法做到实时持久化</strong>，若在两次bgsave持久化操作间宕机，则会丢失增量数据，不适用于实时性要求较高的场景</li><li>bgsave命令每次都要执行fork操作创建子进程，fork子进程属于重量级操作，并且会阻塞redis主进程</li><li>RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，<strong>存在老版本 Redis 无法兼容新版 RDB 格式的问题</strong>。</li></ul><h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>AOF日志就是以日志的方式将<strong>每个操作指令</strong>记录到文件中，并保存到磁盘。Redis 重启后会根据日志文件的内容重新执行这些指令。与RDB快照的方式相比，AOF<strong>解决了数据持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p><p><strong>默认情况下Redis没有开启AOF方式的持久化</strong>，可以通过<code>appendonly</code>参数启用：<code>appendonly yes</code></p><p><strong>AOF执行流程：</strong></p><ul><li><p>AOF并不会每次都把命令直接写入文件中，因为这样会导致磁盘IO负担加重，它会首先将写入命令会追加到 AOP 缓冲区中。 </p></li><li><p>AOF 缓冲区到达一定容量后会根据<strong>对应的策略</strong>向硬盘同步。 （这里有三种策略将缓存区中的命令同步到硬盘中）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always  &#x2F;&#x2F;每次发生数据变更会被立即记录到磁盘，数据完整性好但性能差，不建议配置</span><br><span class="line">appendfsync everysec  &#x2F;&#x2F;每秒同步一次，这样最多丢失1s的记录，建议配置</span><br><span class="line">appendfsync no   &#x2F;&#x2F;Redis不直接调用文件同步，而是让操作系统来决定何时同步磁盘</span><br></pre></td></tr></table></figure><ul><li>当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。</li></ul><p><strong>AOF日志重写机制：</strong></p><p>随着 AOF 文件保存的数据越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。</p><p>Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的AOF文件。</p><p><strong>AOF的优缺点</strong></p><p><strong>优点：</strong></p><ul><li>AOF可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据。</li></ul><p><strong>缺点：</strong></p><ul><li>AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。</li><li>数据恢复与RDB相比要慢。</li></ul><h2 id="RDB和AOF如何选择？"><a href="#RDB和AOF如何选择？" class="headerlink" title="RDB和AOF如何选择？"></a>RDB和AOF如何选择？</h2><p>通常来说，应该<strong>同时使用两种持久化方案，以保证数据安全。</strong></p><ul><li>如果数据不敏感，且可以从其他地方重新生成，可以关闭持久化。 </li><li>如果数据比较重要，且能够承受几分钟的数据丢失，比如缓存等，只需要使用RDB即可。 </li><li>如果是用做内存数据，要使用Redis的持久化，建议是RDB和AOF都开启。 </li><li>如果只用AOF，优先使用everysec的配置选择，因为它在可靠性和性能之间取了一个平衡。 </li></ul><p><strong>当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。</strong></p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="Redis-事务介绍"><a href="#Redis-事务介绍" class="headerlink" title="Redis 事务介绍"></a>Redis 事务介绍</h3><p>1）Redis 的事务是通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 这四个命令来完成的。</p><p>2）Redis 的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</p><p>3）<strong>Redis不支持回滚操作，因此Redis事务不满足原子性</strong></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>使用MULT命令后开启事务可以输入多个命令。Redis不会立即执行这些命令，而是将这些命令放入队列中，当调用了EXEC命令将执行所有命令，使用discard命令会清楚掉队列中的命令。</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-6c4bb09d4f8596d3e6c8ab86d35a721d_1440w.jpg" alt="img"></p><p>1）MULTI：用于标记事务块的开始。Redis 会将后续的命令逐个放入队列中，然后使用 EXEC 命令原子化地执行这个命令序列。</p><blockquote><p>127.0.0.1:6379&gt; multi # 开启事务<br>OK<br>127.0.0.1:6379&gt; set k1 alan # 设置 k1<br>QUEUED # k1 加入队列<br>127.0.0.1:6379&gt; set k2 tom # 设置 k2<br>QUEUED # k2 加入队列</p></blockquote><p>2）EXEC：在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。</p><blockquote><p>127.0.0.1:6379&gt; exec<br>\1) OK<br>\2) OK</p></blockquote><p>使用 EXEC 命令原子化地执行这个命令序列，刚刚我们设置了 k1 和 k2 两条命令，执行EXEC 命令后，给我们反馈了两个 OK，说明上述两条命令全部执行成功。</p><p>3）DISCARD：清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</p><blockquote><p>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; set k3 lucy<br>QUEUED<br>127.0.0.1:6379&gt; set k4 jack<br>QUEUED<br>127.0.0.1:6379&gt; discard<br>OK</p></blockquote><p>4）WATCH：可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行EXEC命令之后，就会自动取消监控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set gender 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get gender</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>比如上面的代码中：</p><ol><li><code>watch name</code>开启了对<code>name</code>这个<code>key</code>的监控 </li><li>修改<code>name</code>的值 </li><li>开启事务a </li><li>在事务a中设置了<code>name</code>和<code>gender</code>的值 </li><li>使用<code>EXEC</code>命令进提交事务 </li><li>使用命令<code>get gender</code>发现不存在，即事务a没有执行 </li></ol><p>5）UNWATCH：可以取消WATCH命令对key的监控，所有监控锁将会被取消。</p><h3 id="事务失败处理（两种错误处理）"><a href="#事务失败处理（两种错误处理）" class="headerlink" title="事务失败处理（两种错误处理）"></a>事务失败处理（两种错误处理）</h3><p><strong>1）Redis 格式错误（语法错误）</strong> ：那么事务中的命令都会被回滚</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-3dc3673aa2e049602c211ab8d6df666b_1440w.jpg" alt="img"></p><p>在一个事务中，当命令出现错误时，后续命令正确依旧是可以添加到命令队列中去得，但是使用 EXEC 命令执行命令队列的时候，就会报错，并且队列中正确的命令也不会被执行。</p><p><strong>2）Redis 格式正确，类型错误</strong>  ：除了错误的那一句，其他的命令都会正常执行，不满足回滚操作</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-341eb047ef02f8013c4a5b33aacbb9aa_1440w.jpg" alt="img"></p><p>这种错误不是命令错误，而是因为对命令理解不透彻出现的使用错误，在执行过程中会报错，因为 username1 不是 list 类型，它只是一个 string 类型。有一点需要注意，从结果可以看出，第一条命令是执行成功了的，所有我们使用”get username1”命令，返回了”alan”结果，<strong>这也证明了 Redis 是不支持事务回滚的</strong>。</p><p><strong>3）为什么 Redis 不支持事务回滚？</strong></p><p>（1）Redis为了性能更好就是忽略了事务回滚</p><p>（2）大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，应该在开发阶段就应该被发现而不是在生产过          程中。</p><h2 id="缓存穿透（未完成）"><a href="#缓存穿透（未完成）" class="headerlink" title="缓存穿透（未完成）"></a>缓存穿透（未完成）</h2><p><strong>获取缓存的流程：</strong></p><p>前台请求数据，后台先从缓存中取数据，如果缓存中有直接返回结果，如果没有就从数据库中取，数据库取到后会更新缓存，并返回结果，如果数据库也没取到，那直接返回空结果。</p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105205040220.png" alt="image-20211105205040220" style="zoom:67%;" /><p><strong>缓存穿透：</strong>用户发起大量请求，发现缓存中没有，并且数据库中也没有，也就是说没有经过缓存这一层，导致数据库压力过大。</p><p><strong>解决方案：</strong></p><p>1.布隆过滤器</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>：我们对缓存设置了相同的过期时间，导致缓存在某一时刻同时失效，请求在短时间内全部转发到数据库上。</p><p><strong>解决方案：</strong></p><p>1.我们可以设置不同的缓存失效时间，比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低。</p><p>2.</p><h2 id="Redis高可用（未完成）"><a href="#Redis高可用（未完成）" class="headerlink" title="Redis高可用（未完成）"></a>Redis高可用（未完成）</h2><p>高可用通常是指，<strong>通过设计减少系统不能提供服务的时间。</strong>（让系统尽可能处于可用的状态）</p><p>如果在实际生产中，如果redis只部署一个节点，当机器故障时，整个服务都不能提供服务了。这就是我们常说的单点故障。</p><p>如果redis部署了多台，当一台或几台故障时，整个系统依然可以对外提供服务，这样就提高了服务的可用性。</p><p>redis高可用的三种模式：<strong>主从模式，哨兵模式，集群模式。</strong></p><h3 id="Redis主从模式"><a href="#Redis主从模式" class="headerlink" title="Redis主从模式"></a>Redis主从模式</h3><p><strong>主从复制介绍：</strong></p><p>Redis为了保证系统的高可用，避免单点故障，一般需要部署多台机器。</p><p>因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。redis提供了Redis提供了主从复制的(replication)功能，当一台redis主数据库中的数据发生了变化，这个变化会被自动的同步到其他的redis从数据库中。</p><p>redis多机器部署时，这些机器节点会被分成两类，一类是主数据库（master），一类是从数据库（slave）。</p><p>主数据库可以进行读写操作，<strong>当主数据库的数据发生变化时会自动将数据同步到从数据库</strong>。从数据库一般是只读的，它会接收主数据库同步过来的数据。一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。也就是所谓的<strong>一主多从</strong>结构。<br><img src="/images/Redis%E7%9B%B8%E5%85%B3/format,png.png" alt="一主多从"></p><p><strong>主从复制过程：</strong>（没看懂）</p><p>1.当启动一个从节点时，它会发送一个 <code>PSYNC</code> 命令给主节点； </p><p>2.如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件； </p><p>3.同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， 主节点会将<code>RDB</code>文件发送给从节点，从节点会先将<code>RDB</code>文件<strong>写入本地磁盘，然后再从本地磁盘加载到内存中</strong>； </p><p>4.接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据； </p><p>5.如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。</p><h3 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h3><p><strong>哨兵模式介绍：</strong></p><p>主从模式下要是发生了故障主节点宕机了，哨兵机制会自动选举主节点并将其他的从节点指向新的主节点。</p><p>客户端连接Redis的时候，先连接哨兵，哨兵会告诉客户端Redis主节点的地址，然后客户端连接上Redis并进行后续的操作。当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。</p><p><strong>哨兵模式过程：</strong></p><h3 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h3><p>哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是存在主节点的写能力、容量受限于单机配置的问题。而cluster模式实现了Redis的分布式存储，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。</p><p>Redis cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><h2 id="Redis如何保证缓存和数据库的一致性"><a href="#Redis如何保证缓存和数据库的一致性" class="headerlink" title="Redis如何保证缓存和数据库的一致性"></a>Redis如何保证缓存和数据库的一致性</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录一点Redis相关面试题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B8%85%E6%A5%9A%E7%9A%84%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2021/10/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B8%85%E6%A5%9A%E7%9A%84%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE/</id>
    <published>2021-10-27T07:33:11.850Z</published>
    <updated>2021-11-04T12:54:34.865Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JVM：</strong></p><p><strong>java基础：</strong></p><p>concurrenthashmap  </p><p><strong>底层结构方面</strong></p><p>JDK1.7底层是Segment数组 + HashEntry数组+链表</p><p>JDK1.8底层是Node数组+链表+红黑树</p><p><strong>并发安全方面</strong></p><p>JDK1.7采用的是分段锁，锁的是一个个segment，segment 继承了 ReentrantLock。</p><p>JDK1.8采用的是CAS+synchronized，锁的是Node节点，只要没有发生哈希冲突，就不会产生锁的竞争。</p><p>所以JDK1.8相比于JDK1.7提供了一种粒度更小的锁，减少了锁的竞争，提高了concurrentHashMap的并发能力。</p><p><strong>mysql：</strong></p><p><strong>java并发：</strong></p><p>两个线程交替打印奇数和偶数：</p><p>采用synchronized + wait + notify</p><p>在一个循环中，先打印，再唤醒另一个线程，再wait当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Process</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">               <span class="keyword">while</span>(num &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印&quot;</span> + num++);</span><br><span class="line">                   lock.notify();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       lock.wait();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintThread thread = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>threadlocal有了解吗？</p><p><strong>框架相关</strong>：</p><p><strong>算法：</strong></p><p>查找数组中第k大的数（快排思想，每次求得一个）</p><p>另一棵树的子树</p><p>递归实现冒泡排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;JVM：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;java基础：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;concurrenthashmap  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;底层结构方面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK1.7底层是Segment数组</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/26/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E4%B8%80%E9%9D%A2/"/>
    <id>http://example.com/2021/10/26/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E4%B8%80%E9%9D%A2/</id>
    <published>2021-10-26T09:07:41.735Z</published>
    <updated>2021-11-01T04:00:41.461Z</updated>
    
    <content type="html"><![CDATA[<p>京东零售java后台开发一面     1h   10月26日16:00~17:00</p><ol><li>自我介绍</li><li>java基本数据类型（8种）</li><li>String是基本数据类型吗？</li><li>介绍一下final（变量、方法、类）</li><li><strong>输入3X0.1，返回的是什么类型（不会。。）</strong></li><li>instanceof有什么作用？</li><li>枚举类中的两个对象作比较，用equals还是== ？（不是很懂，）</li><li><strong>java中创建对象有几种方式？（new、反射（两种）、clone方法、反序列化）</strong></li><li><strong>介绍一下java的异常体系</strong></li><li><strong>自定义异常如何实现？继承Exception和继承RuntimeException有什么区别？</strong></li><li>对java集合类的理解</li><li>HashMap数组下标如何计算？（三步）</li><li>为什么不直接用Object的HashCode方法，还要右移和取模？</li><li>解决哈希冲突有哪些方法？HashMap中如何解决哈希冲突？（答了拉链法和开放定址法）</li><li>为什么HashMap选择拉链法而不选择开放定址法？</li><li>对HashMap的key有什么要求吗？（我答的通常使用不变的对象作为key）</li><li>java中实现多线程的方法（4种，面试官说线程池不算一种方法）</li><li>线程池怎么创建？（不是很熟悉，）</li><li>有三个线程ABC按顺序执行。比如说A-》B-》C（面试官提到用join方法）</li><li>线程通信和调度方法有哪些？</li><li>wait和sleep方法的区别？</li><li>线程有哪些状态？（我答的6个）</li><li>调用wait和sleep是进入哪个状态？</li><li>MySQL的索引作用？</li><li>主键索引是唯一索引吗？</li><li><strong>我们怎么创建索引？（创建表时加索引，创建完表后再加索引语句create index index_name on student(字段名)）</strong></li><li><strong>怎么知道索引是否创建成功（当时忘了，使用explain）</strong></li><li>数据库事务的四大特性</li><li>谈谈你对隔离性的理解</li><li>谈谈脏读、不可重复读、幻读的区别</li><li>说一下Spring的IOC和AOP</li><li>Spring里面注入的几种方式（）通过成员变量和构造器注入</li><li>@Autowired（有了解过在构造器上用@Autowired吗？）</li><li>Mybatis里面有哪些常用标签？</li><li>MySQL的联合查询如何实现？</li><li>知道Union和UnionAll有什么区别？（将两个表查询的结果集合并在一起）</li><li>去重的标准是什么？</li><li>MyBatis的的$和#有什么区别？</li><li>估计你的实习周期有多长？</li><li>反问</li></ol><p>把一些语气词去掉，不要显得自己不是很确认的样子。。</p><p>比如说 吧，应该是这样的，大概，就按照自己的理解去说就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;京东零售java后台开发一面     1h   10月26日16:00~17:00&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;java基本数据类型（8种）&lt;/li&gt;
&lt;li&gt;String是基本数据类型吗？&lt;/li&gt;
&lt;li&gt;介绍一下final（变量、方法、类）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/25/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/"/>
    <id>http://example.com/2021/10/25/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/</id>
    <published>2021-10-25T08:54:32.276Z</published>
    <updated>2021-10-31T14:40:39.803Z</updated>
    
    <content type="html"><![CDATA[<p>小米java后台开发一面  1h   10月25日15:30~16:30</p><p>结果：一面挂（其实我感觉答的还可以。。除了最后的算法题没完全写对，我也不晓得为啥会挂）</p><ol><li>自我介绍</li><li>介绍一下面向对象的特点（封装、继承、多态）</li><li>Object类的常用方法（只知道hashcode equals hashCode）</li></ol><p>getClass、clone、hashCode equals finalize wait notify notifyall toString </p><ol><li><p>String对象为什么不可变（不清楚，只回答了源码用final修饰）</p></li><li><p>equals方法和hashCode方法</p></li><li><p>有重写过equals方法吗？重写了equals方法一定要重写hashCode方法吗？</p></li><li><p>讲一下java接口</p></li><li><p>讲一下java集合中的Collection和Map两个接口（要按照什么样的思路来讲的话比较好呢？讲List、Set、Queue这三个子接口。我是先介绍特点再介绍下面的子接口或者子类</p></li><li><p>讲ArrayList和LinkedList（先从宏观上讲一遍，也就是那三个区别，再从底层讲一下）</p><p>ArrayList 的底层存储、构造函数、扩容过程。LinkedList底层</p></li><li><p>java中创建多线程的方法（4种，可以详细 讲一讲每种是怎么创建的。用线程池创建线程的方法、自定义的忘了怎么说了）</p></li><li><p>有哪些方法可以解决多线程并发安全问题？（我答的synchronized、volatile、锁机制、JUC包下的原子操作类和一些线程安全的并发集合类）</p></li><li><p>介绍一下ReentrantLock和synchronized的区别（中断方式没讲明白、）</p></li><li><p><strong>介绍一下ReentrantLock的底层实现</strong></p></li><li><p><strong>AQS讲一下</strong></p></li><li><p>线程池的参数</p></li><li><p>MySQL引擎介绍一下</p></li><li><p>MySQl引擎的数据结构（B+树）</p></li><li><p>还有哪些数据结构，为什么不用这些数据结构（<strong>为什么不用哈希表</strong>，而用B+树）</p></li><li><p>MySQL的事务隔离</p></li><li><p>MySQL的默认级别是可重复读，但为什么可以解决幻读问题？（MVCC+临键锁）</p></li><li><p><strong>讲一下临键锁</strong></p></li><li><p>意向锁（流程讲一下）</p></li><li><p>JVM的内存结构（讲一下流程和5个区域的作用）</p></li><li><p><strong>讲一下OOM，什么情况下会发生OOM</strong></p></li><li><p>讲一下Spring（这个框架有什么用，核心思想IOC和AOP，先答解耦，再详细答每个思想）</p></li><li><p><strong>Spring事务</strong>（不会）</p></li><li><p>算法题–反转链表Ⅱ</p></li><li><p>反问（1.面试哪些地方不足   2.面试官介绍部门是做什么的，说是小米商城的交易中台服务）</p></li></ol><p>总结：口头禅太多，知识点大概都答上来了，但是总结的有点凌乱。</p><p><strong>有这些口头禅</strong>：就是 、额 、可能、如果。。。的话、然后还有一个、好像</p><p><strong>解决方法</strong>：</p><p>额-》回答问题使先思考一会儿再答，不用着急</p><p>xxx就是-》xxx，他的意思是  或者   xxx的意思是</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小米java后台开发一面  1h   10月25日15:30~16:30&lt;/p&gt;
&lt;p&gt;结果：一面挂（其实我感觉答的还可以。。除了最后的算法题没完全写对，我也不晓得为啥会挂）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;介绍一下面向对象的特点（封装、继承、多态）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/25/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/25/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-25T04:11:13.609Z</published>
    <updated>2021-11-03T10:21:48.935Z</updated>
    
    <content type="html"><![CDATA[<p>面试官，您好！我叫彭博。来自北京邮电大学，我的专业是信息工程 ，目前大四，专业排名10%，保研到本校计算机学院，想要应聘贵公司java开发实习生的岗位。</p><p>在校期间，我学习了   Java、    MySQL   、数据结构算法等必备知识，在技能方面还是符合这个岗位的。我也参加过一些比赛并取得一定的成绩，像美国大学生数学建模竞赛等，让我明白了团结和分工的重要性，在获奖的同时也锻炼了自己的实践能力。像平时我也会写一些博客整理记录下自己所学的知识。</p><p>通过自身的努力，我也获得了很多次的奖学金，担任过大班体育委员、团支书等职务，这也让我认识到付出就有收获，对我将来的工作也有很大的激励作用。在生活上我是一个比较积极乐观的人，一般会通过运动唱歌的的方式来放松自己。如果有幸能够进入到贵公司，   <strong>在工作中我也会积极主动地迎难而上，认真地完成每一项任务。</strong>以上就是我的自我介绍，面试官好，我介绍完了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试官，您好！我叫彭博。来自北京邮电大学，我的专业是信息工程 ，目前大四，专业排名10%，保研到本校计算机学院，想要应聘贵公司java开发实习生的岗位。&lt;/p&gt;
&lt;p&gt;在校期间，我学习了   Java、    MySQL   、数据结构算法等必备知识，在技能方面还是符合这个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git、Maven、postman的理解</title>
    <link href="http://example.com/2021/10/24/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/24/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-24T12:49:40.000Z</published>
    <updated>2021-10-24T13:14:51.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>几个开发中常用工具的使用</p></blockquote><a id="more"></a><h2 id="git简要介绍"><a href="#git简要介绍" class="headerlink" title="git简要介绍"></a>git简要介绍</h2><p>Git官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>Git图标：<img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/Git%E5%9B%BE%E6%A0%87.jpeg" alt="Git图标" style="zoom:80%;" /></p><p>Git 是一个<strong>开源的分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git版本控制</p><ul><li>个人操作</li><li>团队协作：记录每次修改的情况。</li></ul><p><strong>什么是版本控制呢？</strong></p><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3-1610510235263.jpg" alt="版本迭代" style="zoom:50%;" /><h2 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h2><p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/%E6%B5%81%E7%A8%8B.png" alt="git工作流程"></p><p>名词解释：</p><ul><li>workspace：工作区</li><li>staging area：暂存区/缓存区</li><li>local repository：或本地仓库</li><li>remote repository：远程仓库</li></ul><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><h3 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Adding files&quot;</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone</span><br></pre></td></tr></table></figure><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">注：一个^表示后退一步，n 个表示后退 n 步</span><br></pre></td></tr></table></figure><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>一般我们在pom.xml文件中导入jar包的，只要我们确定maven坐标，就可以从远程残酷</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/915951-20161205142602226-1306419231.png" alt="maven仓库"></p><p><strong>本地仓库</strong>是指存在于我们本机的仓库，在我们加入依赖时候，首先会跑到我们的本地仓库去找，如果找不到则会跑到远程仓库中去找。</p><p><strong>远程仓库</strong>是指其他服务器上的仓库，包括全球中央仓库，公司内部的私服，又或者其他公司提供的公共库。</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>而Postman就是一个能够产生各种类型http请求的工具，并能设置请求的参数。</p><p>比如我们能发送我们常用的Post请求和Get请求。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;几个开发中常用工具的使用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql基础知识</title>
    <link href="http://example.com/2021/10/23/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/10/23/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-10-23T09:53:17.000Z</published>
    <updated>2021-10-30T02:50:18.879Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记一下常见的MySQL语句</p></blockquote><a id="more"></a><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160254539-1309074983.png" alt="img"></p><p>语法格式：</p><p>select 字段 from 表名 where 条件 group by 分组字段 having 分组条件 order by 排序字段 排序规则 limit 分页参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表  from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><h3 id="创建数据库（Create）"><a href="#创建数据库（Create）" class="headerlink" title="创建数据库（Create）"></a>创建数据库（Create）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database db_name;  -- 创建数据库</span><br><span class="line">mysql&gt; show databases;           -- 显示所有的数据库</span><br><span class="line">mysql&gt; drop database db_name;    -- 删除数据库</span><br><span class="line">mysql&gt; use db_name;              -- 选择数据库</span><br><span class="line">mysql&gt; create table tb_name (字段名 varchar(20), 字段名 char(1));   -- 创建数据表模板</span><br><span class="line">mysql&gt; show tables;              -- 显示数据表</span><br><span class="line">mysql&gt; desc tb_name；            -- 显示表结构</span><br><span class="line">mysql&gt; drop table tb_name；      -- 删除表</span><br></pre></td></tr></table></figure><p>​    例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建学生表*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">     Sno <span class="built_in">char</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</span><br><span class="line">     Sname <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">     Ssex <span class="built_in">char</span>(<span class="number">2</span>),</span><br><span class="line">     Sage <span class="built_in">smallint</span>,</span><br><span class="line">     Sdept <span class="built_in">char</span>(<span class="number">20</span>)</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><h3 id="插入数据（Insert）"><a href="#插入数据（Insert）" class="headerlink" title="插入数据（Insert）"></a>插入数据（Insert）</h3><p> insert into 表名 values （值1，值2）语句用于向表格中插入新的行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：*/</span></span><br><span class="line">mysql&gt; insert into tb_name values (value1,value2,value3,...);</span><br><span class="line"><span class="comment">/*第二种形式需要指定列名及被插入的值：*/</span></span><br><span class="line">mysql&gt; insert into tb_name (column1,column2,column3,...) values (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>​     例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*插入数据*&#x2F;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student values ( 20180001,张三,男,20,CS）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student values ( 20180002,李四,男,19,CS）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180003,王五,男,18,MA）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180004,赵六,男,20,IS）;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>update 表名 set 字段1=值1，字段值2=值2，where 条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 将id为2的age改为22，sex改为男</span><br><span class="line">update stu set age&#x3D;22,sex&#x3D;&#39;男&#39; where id&#x3D;2;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>delete from 表名 [where 条件]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 删除stu表中id值为11的数据</span><br><span class="line">delete from stu where id&#x3D;11;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值为12到17的数据</span><br><span class="line">delete from stu where id between 12 and 17;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值大于10的数据</span><br><span class="line">delete from stu where id&gt;10;</span><br></pre></td></tr></table></figure><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表  from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><h3 id="where-查询"><a href="#where-查询" class="headerlink" title="where 查询"></a><strong>where 查询</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 查询stu表中 age &gt; 22的数据</span><br><span class="line">select * from stu where age&gt;22;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 name&#x3D;某个条件值 的数据</span><br><span class="line">select * from stu where name&#x3D;&#39;yyx&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的数据</span><br><span class="line">select * from stu where age between 22 and 25;</span><br><span class="line">select * from stu where age &gt;&#x3D; 22 and age&lt;&#x3D; 25;</span><br><span class="line">-- 查询 stu 表中 年龄不在22到25之间的数据</span><br><span class="line">select * from stu where age not between 22 and 25;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的女生信息</span><br><span class="line">select * from stu where age between 22 and 25 and sex&#x3D;&#39;女&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 users 表中 年龄为22或者25 的女生信息，必须要加小括号，因为and的优先级高于or</span><br><span class="line">select * from users where (age&#x3D;22 or age &#x3D; 25) and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><h3 id="like查询"><a href="#like查询" class="headerlink" title="like查询"></a>like查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- like 语句  like某个确定的值 和。where name &#x3D; &#39;王五&#39; 是一样</span><br><span class="line">select * from stu where name like &#39;yyx&#39;;</span><br><span class="line"></span><br><span class="line">-- % 代表任意个字符  _ 代表单个字符</span><br><span class="line"></span><br><span class="line">-- 使用 % 模糊搜索。%代表任意个任意字符</span><br><span class="line">    -- 查询name字段中包含x的</span><br><span class="line">    select * from stu where name like &#39;%x%&#39;;</span><br><span class="line">    -- 查询name字段中最后一个字符 为 u的</span><br><span class="line">    select * from stu where name like &#39;%u&#39;;</span><br><span class="line">    -- 查询name字段中第一个字符 为 q 的</span><br><span class="line">    select * from stu where name like &#39;q%&#39;;</span><br><span class="line">-- 使用 _ 单个的下划线。表示一个任意字符，使用和%类似</span><br><span class="line">    -- 查询表中 name 字段为两个字符的数据</span><br><span class="line">    select * from users where name like &#39;__&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 name 字段最后为j，的两个字符的数据</span><br><span class="line">select * from users where name like &#39;_j&#39;;</span><br></pre></td></tr></table></figure><h3 id="Mysql中的统计函数（聚合函数）"><a href="#Mysql中的统计函数（聚合函数）" class="headerlink" title="Mysql中的统计函数（聚合函数）"></a>Mysql中的统计函数（聚合函数）</h3><p>可以使用like语句进行某个字段的模糊搜索，</p><p>例如： 查询 name字段中包含五的数据</p><p><strong>count(),max(),min(),sum(),avg()</strong></p><h3 id="count统计数量"><a href="#count统计数量" class="headerlink" title="count统计数量"></a>count统计数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 计算 users 表中 最大年龄，最小年龄，年龄和及平均年龄</span><br><span class="line">select max(age),min(age),sum(age),avg(age) from stu;</span><br><span class="line">-- 上面数据中的列都是在查询时使用的函数名，不方便阅读和后期的调用，可以通过别名方式 美化</span><br><span class="line">select max(age) as max_age,min(age) as min_age,</span><br><span class="line">sum(age) as sum_age,avg(age) as avg_age from stu;</span><br><span class="line">-- 统计 stu 表中的数据量</span><br><span class="line">select count(*) from stu;</span><br><span class="line">select count(id) from stu;</span><br><span class="line">-- 上面的两个统计，分别使用了 count(*) 和 count(id),结果目前都一样，有什么区别？</span><br><span class="line">-- count(*) 是按照 users表中所有的列进行数据的统计，只要其中一列上有数据，就可以计算</span><br><span class="line">-- count(id) 是按照指定的 id 字段进行统计，也可以使用别的字段进行统计，</span><br><span class="line">-- 但是注意，如果指定的列上出现了NULL值，那么为NULL的这个数据不会被统计</span><br><span class="line">-- 假设有下面这样的一张表需要统计</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line">| id | name     | age | sex  | classid |</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line">|  1 | zhangsan |  20 | 男   |       1 |</span><br><span class="line">|  2 | yyx      |  22 | 男   |       1 |</span><br><span class="line">|  3 | lj       |  20 | 男   |       1 |</span><br><span class="line">|  4 | zhaoliu  |  25 | 女   |       1 |</span><br><span class="line">|  5 | uu01     |  26 | 男   |       1 |</span><br><span class="line">|  6 | uu02     |  28 | 男   |       2 |</span><br><span class="line">|  7 | qq02     |  24 | 男   |       2 |</span><br><span class="line">|  8 | uu03     |  32 | 女   |       2 |</span><br><span class="line">|  9 | qq03     |  23 | 女   |       2 |</span><br><span class="line">| 10 | aa       |  19 | 男   |       2 |</span><br><span class="line">| 25 | bb       |  20 | NULL |       2 |</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line"></span><br><span class="line">-- 如果按照sex这一列进行统计，结果就是10个而不是11个，因为sex这一列中有NULL值存在</span><br><span class="line">select count(sex) from stu;</span><br><span class="line">+------------+</span><br><span class="line">| count(sex) |</span><br><span class="line">+------------+</span><br><span class="line">|         10 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>*<em>count(1)  count(</em>)  count(列名) 三者的区别**</p><p>都是返回结果集的行数</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，<strong>不会忽略为NULL的值。</strong>  把null所在行也计算</li><li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略为NULL的值</strong>。</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li></ul><p>结论：使用count(1)和count(*)在性能上是差不多的，而count(字段)会判断一下字段是否为空，性能差，结果不一样</p><p>MySQL对count(*)做了优化，</p><p><strong>count(可空字段) &lt; count(非空字段) = count(主键 id) &lt; count(1) ≈ count(*)</strong></p><h3 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h3><p> group by 语句根据一个或多个列对结果集进行分组</p><p>一般情况下，是用与数据的统计或计算，配合聚合函数使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 统计 stu 表中 男女生人数,</span><br><span class="line">-- 很明显按照上面的需要，可以写出两个语句进行分别统计</span><br><span class="line">select count(*) from stu where sex&#x3D;&#39;女&#39;;</span><br><span class="line">select count(*) from stu where sex&#x3D;&#39;男&#39;;</span><br><span class="line">-- 可以使用分组进行统计，更方便</span><br><span class="line">select sex,count(*) from stu group by sex;</span><br><span class="line">+------+----------+</span><br><span class="line">| sex  | count(*) |</span><br><span class="line">+------+----------+</span><br><span class="line">| NULL |        1 |</span><br><span class="line">| 男   |        7 |</span><br><span class="line">| 女   |        3 |</span><br><span class="line">+------+----------+</span><br><span class="line">-- 统计1班和2班的人数</span><br><span class="line">select classid as &#39;班级&#39;,count(*) from stu group by classid;</span><br><span class="line">+--------+----------+</span><br><span class="line">| 班级   | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      1 |        5 |</span><br><span class="line">|      2 |        6 |</span><br><span class="line">+--------+----------+</span><br><span class="line">-- 分别统计每个班级的男女生人数</span><br><span class="line">select classid,sex,count(*) from stu group by classid,sex;</span><br><span class="line">+---------+------+----------+</span><br><span class="line">| classid | sex  | count(*) |</span><br><span class="line">+---------+------+----------+</span><br><span class="line">|       1 | 男   |        4 |</span><br><span class="line">|       1 | 女   |        1 |</span><br><span class="line">|       2 | NULL |        1 |</span><br><span class="line">|       2 | 男   |        3 |</span><br><span class="line">|       2 | 女   |        2 |</span><br><span class="line">+---------+------+----------+</span><br><span class="line"># 注意，在使用。group by分组时，一般除了聚合函数，其它在select后面出现的字段都需要出现在grouop by后面</span><br></pre></td></tr></table></figure><h3 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h3><p> having时在分组聚合计算后，对结果再一次进行过滤，类似于where。 </p><p>where过滤的是行数据，having过滤的是分组数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 要统计班级人数</span><br><span class="line">select classid,count(*) from stu group by classid;</span><br><span class="line"></span><br><span class="line">-- 统计班级人数，并且要人数达到5人及以上</span><br><span class="line">select classid,count(*) as num from stu group by classid having num &gt;&#x3D;5;</span><br></pre></td></tr></table></figure><h3 id="orded-by"><a href="#orded-by" class="headerlink" title="orded by"></a>orded by</h3><p>ORDER BY 语句用于根据指定的列对结果集进行排序。ORDER BY 语句默认按照升序对记录进行排序。</p><p>如您希望按照降序对记录进行排序，可以使用 ASC（升序）、DESC(降序) 关键字。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>查询数据表前几条或者后几条记录，LIMIT可以很好的满足需求。</p><p>limit子句用于限制查询结果返回的数量，常用于分页查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询10条数据，索引从0到9，第1条记录到第10条记录   </span><br><span class="line"># 第一个数类似于数组的下标，从0开始计数，第二个数为记录总条数</span><br><span class="line">select * from t_user limit 10;</span><br><span class="line">select * from t_user limit 0,10;    # 从第1条开始，一共有10条</span><br><span class="line"></span><br><span class="line"># 查询8条数据，索引从5到12，第6条记录到第13条记录</span><br><span class="line">select * from t_user limit 5,8;     # 从第6条开始，一共有8条</span><br></pre></td></tr></table></figure><p><strong>分页需求：</strong></p><p>通过传递<strong>页码（curPage）</strong>和<strong>每页记录条数（pageSize）</strong>两个参数去<strong>分页查询</strong>数据库表中的数据。</p><p>比如：</p><p>查询第1条到第10条的数据的sql是：<code>select * from table limit 0,10</code>;  -&gt;对应我们的需求就是查询第一页的数据：<code>select * from table limit (1-1)*10,10;</code></p><p>查询第11条到第20条的数据的sql是：<code>select * from table limit 10,10</code>; -&gt;对应我们的需求就是查询第二页的数据：<code>select * from table limit (2-1)*10,10</code>;</p><p>查询第21条到第30条的数据的sql是：<code>select * from table limit 20,10</code>; -&gt;对应我们的需求就是查询第三页的数据：<code>select * from table limit (3-1)*10,10</code>;</p><p>这样可以按页去查询数据，比如说查询哪一页的数据，指定页码和每页容纳多少条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curPage是当前第几页；pageSize是一页多少条记录</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">limit</span>(curPage<span class="number">-1</span>)*pageSize,pageSize;</span><br></pre></td></tr></table></figure><h3 id="课后练习题（-分割线-）"><a href="#课后练习题（-分割线-）" class="headerlink" title="课后练习题（***分割线*****）"></a>课后练习题（*<strong>**</strong>分割线*<strong>****</strong>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 统计班级 classid为2的男女生人数？</span><br><span class="line">select sex,count(*) where classid&#x3D;2 group by sex;</span><br><span class="line"></span><br><span class="line">-- 2. 获取每个班级的 平均年龄，并按照平均年龄从大到小排序</span><br><span class="line">select classid,avg(age) as avg_age from stu group by classid order by avg_age desc;</span><br><span class="line"></span><br><span class="line">-- 3. 统计每个班级的人数，按照从大到小排序</span><br><span class="line">select classid,count(*) as &#39;人数&#39; from stu group by classid order by count(*) desc;</span><br></pre></td></tr></table></figure><h3 id="varchar和char的区别？"><a href="#varchar和char的区别？" class="headerlink" title="varchar和char的区别？"></a>varchar和char的区别？</h3><ul><li>varchar表示变长，char表示长度固定。如char（5），无论插入的字符长度是多少，长度都是5，插入字符长度小于5，则<strong>用空格补充。</strong>对于varchar（5），如果插入的字符长度小于5，则存储的字符长度就是插入字符的长度，<strong>不会填充</strong>。</li><li>存储容量不同，对于char来说，最多能存放的字符个数为255，对于varchar，最多能存放的字符个数是65532存储速度不同</li><li>char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而varchar空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。</li></ul><h3 id="查询表的字段属性"><a href="#查询表的字段属性" class="headerlink" title="查询表的字段属性"></a>查询表的字段属性</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">desc table_name     <span class="comment">-- 这里的desc是describe的意思，就是描述表的字段信息</span></span><br><span class="line">creat index nameIndex on student(name);</span><br><span class="line">creat unique index ageIndex on student(age);</span><br><span class="line">desc student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出字段类型、是否为空、Key的类型</span></span><br><span class="line">Field   Type            Null  Key</span><br><span class="line">id    int(11)        NO  PRI</span><br><span class="line">namevarchar(255)Yes  MUL(可以重复)</span><br><span class="line">age    int(11)        YES  UNI(不可重复)</span><br><span class="line">gendervarchar(255)YES</span><br></pre></td></tr></table></figure><h3 id="什么是子查询？"><a href="#什么是子查询？" class="headerlink" title="什么是子查询？"></a>什么是子查询？</h3><p>把一个查询的结果在另一个查询中使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询年纪最大的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age=(<span class="keyword">SELECT</span> <span class="keyword">max</span>(age)<span class="keyword">from</span> <span class="keyword">user</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age, sex) = (<span class="keyword">SELECT</span> age, sex <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&quot;zhangsan&quot;</span>）                               </span><br></pre></td></tr></table></figure><h3 id="MySQL的几种连接查询"><a href="#MySQL的几种连接查询" class="headerlink" title="MySQL的几种连接查询"></a>MySQL的几种连接查询</h3><p>MySQL的连接查询主要可以分为<strong>外连接</strong>，<strong>内连接</strong>，<strong>交叉连接</strong></p><p><strong>表测试数据：</strong></p><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027113245206.png" alt="image-20211027113245206"></p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>从左表中取出每一条记录，去右表中与所有的记录进行匹配，保留匹配成功的记录，并将两份记录拼接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内连接</span></span><br><span class="line"><span class="comment">-- select * from student inner join class; --结果与交叉连接相同</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">class</span> <span class="keyword">on</span> student.cid = class.cid;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160249740-1441543214.png" alt="image"></p><p>说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p><p><img src="/images/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/3.png" alt="img"></p><h4 id="外连接（左外连接和右外连接）"><a href="#外连接（左外连接和右外连接）" class="headerlink" title="外连接（左外连接和右外连接）"></a>外连接（左外连接和右外连接）</h4><p>与内连接不同的是主表记录不管匹配符不符合都保留，方式有<strong>左外连接、右外连接,左外连接是保留左表，右外连接是保留右表</strong></p><ul><li><p>语法：</p></li><li><ul><li>左外连接：<code>select 字段列表 from 左表 left join 右表 on 左表.字段 = 右表.字段;</code></li><li>右外连接：<code>select 字段列表 from 左表 right join 右表 on 左表.字段 = 右表.字段;</code></li></ul></li><li><p><strong>左外连接</strong></p></li><li><pre><code class="sql">select * from student left join class on student.cid = class.cid;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ![image](&#x2F;images&#x2F;mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&#x2F;1053079-20180411160252239-1394678105.png)</span><br><span class="line"></span><br><span class="line">- **右外连接**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sql</span><br><span class="line">  select * from student right join class on student.cid &#x3D; class.cid;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160254539-1309074969.png" alt="image"></p></li></ul><h3 id="Union和Union-All的区别（联合查询语句）"><a href="#Union和Union-All的区别（联合查询语句）" class="headerlink" title="Union和Union All的区别（联合查询语句）"></a>Union和Union All的区别（联合查询语句）</h3><p><strong>作用：</strong></p><p>union和union all的作用都是<strong>将两个结果集合并到一起。</strong>但要注意用于选择的两个语句选择的字段数要相等（否则无法连接），字段类型可以不相等。</p><p><strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">column</span>,......from table1   <span class="keyword">UNION</span> [<span class="keyword">all</span>]   <span class="keyword">select</span>  <span class="keyword">column</span>,...... <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027112104524.png" alt="image-20211027112104524"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,gender <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">class</span>;</span><br><span class="line"><span class="comment">-- 因为class就两个字段，所以第一个只选出两个字段</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027112145964.png" alt="image-20211027112145964" style="zoom: 67%;" /><p><strong>区别：</strong></p><ul><li>union会对结果<strong>去重并排序</strong>，union all直接直接返回合并后的结果，不去重也不进行排序。</li><li>union all的性能比union性能好。</li></ul><h3 id="如何优化Limit分页？"><a href="#如何优化Limit分页？" class="headerlink" title="如何优化Limit分页？"></a>如何优化Limit分页？</h3><p><strong>数据量大的时候limit分页速度为什么会变慢？</strong></p><p><strong>如何优化？</strong></p><h3 id="SQL语句执行的很慢的原因"><a href="#SQL语句执行的很慢的原因" class="headerlink" title="SQL语句执行的很慢的原因"></a>SQL语句执行的很慢的原因</h3><ul><li>可能是执行的时候遇到了锁</li><li>可能是字段上没有索引或者字段有索引但是没用上索引（比如不满足最左匹配准则）</li></ul><h3 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h3><p>查询中用到的关键词主要包含六个，并且他们的顺序依次为</p><p>select–from–where–group by–having–order by </p><p><strong>这六个关键词的执行顺序 与sql语句的书写顺序并不是一样</strong>的，其中select和from是必须的，其他关键词是可选的，按照下面的顺序来执行：</p><p>from–where–group by–having–select–order by,</p><p>from:需要从哪个数据表检索数据</p><p>where:过滤表中数据的条件</p><p>group by:如何将上面过滤出的数据分组</p><p>having:对上面已经分组的数据进行过滤的条件 （对分组后的数据进行统计）</p><p>select:查看结果集中的哪个列，或列的计算结果</p><p>order by :按照什么样的顺序来查看返回的数据</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>sql是一种网络攻击方式，攻击者可以通过SQL语句，欺骗数据库服务器执行非授权的查询，从而进一步得到相应的数据信息。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记一下常见的MySQL语句&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>linux常用指令</title>
    <link href="http://example.com/2021/10/23/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2021/10/23/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2021-10-23T08:50:29.000Z</published>
    <updated>2021-10-23T09:53:39.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些linux常用指令</p></blockquote><a id="more"></a><p><strong>查看运行的进程</strong>： ps    </p><ul><li><p>ps -ef  查看所有进程信息</p><p>-e 显示所有进程。<br>-f 全格式。</p></li><li><p>ps -ef | grep java    查看java进程信息</p></li></ul><p><strong>结束进程</strong>：kill   pid     </p><ul><li><p>kill -9 pid 强制结束进程   </p></li><li><p>kill -15 pid 默认方式，正常结束进程</p></li></ul><p>kill原理：kill 命令会向操作系统发送一个信号（多是终止信号）和目标进程的 PID，然后系统根据收到的信号类型，对指定进程进行相应的操作。我们的 -9 -15 都是信号类型</p><p><strong>查看与某台机器的连接情况</strong> ：ping</p><p>命令：ping ip</p><p><strong>查看每个进程的运行情况</strong>：top</p><p>类似于windows的资源管理器</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>目录切换：cd       cd / 切换到根目录    、  cd ../ 切换到上一级目录 或者  cd ..</p><p>目录查看：ls        ls -a查看当前目录下的所有目录和文件（包括隐藏的文件）</p><p>创建目录：mkdir     mkdir   aaa 在当前目录下创建一个名为aaa的目录</p><p>删除目录：rm     rm 文件名   删除当前目录下的文件  、   rm -r aaa   递归删除当前目录下的aaa目录   </p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>新建文件：touch       touch  aa.txt   在当前目录创建一个名为aa.txt的文件    </p><p>删除文件：rm</p><p>修改文件：vi  进入文件    按 i 进入编辑模式   按wq保存并退出</p><p>查看文件：more</p><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><p>命令：tar -zcvf  打包压缩后的文件名  要打包的文件</p><p>例子：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar</p><p>tar -zcvf ab.tar  *</p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>grep：匹配文件中的文本</p><p> grep  ‘test’  file    匹配file文件中 含有 text 的文本</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些linux常用指令&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/21/%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/10/21/%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/</id>
    <published>2021-10-21T01:30:23.489Z</published>
    <updated>2021-10-26T14:31:44.291Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">网址</th><th>公司名称</th><th>投递时间</th><th>面试时间</th><th>面试状态</th><th>一面</th></tr></thead><tbody><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_d6gl0x8oliko?pcm=pc_SearchList%EF%BC%88%E5%AE%9E%E4%B9%A0%E5%83%A7%EF%BC%89">https://www.shixiseng.com/intern/inn_d6gl0x8oliko?pcm=pc_SearchList（实习僧）</a></td><td>猿辅导</td><td>10月21日 9:32</td><td></td><td>被拒</td><td>无</td></tr><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_lpevnzwllesy?pcm=pc_SearchList">https://www.shixiseng.com/intern/inn_lpevnzwllesy?pcm=pc_SearchList</a> （实习僧）</td><td>小米</td><td>10月21日9:42</td><td></td><td>等待约面</td><td>一面挂</td></tr><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_pzv2tkpt7pxv?pcm=pc_SearchList">https://www.shixiseng.com/intern/inn_pzv2tkpt7pxv?pcm=pc_SearchList</a> （实习僧）</td><td>京东</td><td>10月21日9:45</td><td></td><td>等待约面</td><td>等消息</td></tr><tr><td align="left"><a href="https://nowpick.nowcoder.com/w/intern/detail?jobId=61053&amp;deliverSource=2&amp;pageSource=5004%EF%BC%88%E7%89%9B%E5%AE%A2%EF%BC%89%E6%B2%A1%E6%9C%89%E5%9B%9E%E5%93%8D">https://nowpick.nowcoder.com/w/intern/detail?jobId=61053&amp;deliverSource=2&amp;pageSource=5004（牛客）没有回响</a></td><td>滴滴</td><td>10月21日 9:54</td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">学长内推</td><td>字节</td><td>10月22日10:00</td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">实习僧</td><td>百度</td><td></td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">实习僧</td><td>快手</td><td></td><td></td><td>等待约面</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;网址&lt;/th&gt;
&lt;th&gt;公司名称&lt;/th&gt;
&lt;th&gt;投递时间&lt;/th&gt;
&lt;th&gt;面试时间&lt;/th&gt;
&lt;th&gt;面试状态&lt;/th&gt;
&lt;th&gt;一面&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10.18</title>
    <link href="http://example.com/2021/10/18/10-18/"/>
    <id>http://example.com/2021/10/18/10-18/</id>
    <published>2021-10-18T12:58:44.000Z</published>
    <updated>2021-10-24T02:06:19.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕叽咕叽</p><p>看了几篇字节的面经，有那么点感觉好像面试题都答得上来了，至少题目都还见过，只是记得熟不熟的问题。</p><p>我飘了，快来骂醒我！！</p><p>许愿许愿，搞定了就来还愿</p></blockquote><a id="more"></a><p>10.24更</p><p>笑死，根本学不完，飘不起来。</p><hr><p>看到一个帖子，其实感触还蛮深。。。</p><p>想要说点什么</p><p><img src="/images/10-18/image-20211024100435602.png" alt="image-20211024100435602"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕叽咕叽&lt;/p&gt;
&lt;p&gt;看了几篇字节的面经，有那么点感觉好像面试题都答得上来了，至少题目都还见过，只是记得熟不熟的问题。&lt;/p&gt;
&lt;p&gt;我飘了，快来骂醒我！！&lt;/p&gt;
&lt;p&gt;许愿许愿，搞定了就来还愿&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock介绍</title>
    <link href="http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T08:50:25.000Z</published>
    <updated>2021-10-28T03:36:10.778Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下</p></blockquote><a id="more"></a><p>Lock是一个接口，Reentrantlock是Lock的一个主要实现类。</p><p><strong>ReentrantLock</strong> 类内部总共存在<strong>Sync</strong>、<strong>NonfairSync</strong>、<strong>FairSync</strong>三个类，<strong>NonfairSync</strong>与 <strong>FairSync</strong>类继承自 <strong>Sync</strong>类，<strong>Sync</strong>类继承自 <strong>AbstractQueuedSynchronizer</strong>抽象类</p><h1 id="synchronized与ReentrantLock的区别（5点）"><a href="#synchronized与ReentrantLock的区别（5点）" class="headerlink" title="synchronized与ReentrantLock的区别（5点）"></a>synchronized与ReentrantLock的区别（5点）</h1><p>共同点：都是可重入锁、都是排它锁。</p><p>可重入锁：当前线程获取该锁后还可以再次获取，不会发生阻塞。</p><p>独占锁：一个锁只能被一个线程所占有。</p><p>在性能上ReentrantLock和synchronized差不多，但ReentrantLock相比synchronized而言<strong>功能更加丰富，使用起来更为灵活。</strong></p><p>① <strong>底层实现上来说</strong></p><p>​    synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来实现</p><p>​    ReentrantLock 是JUC.lock包下的一个类，是<strong>API层面</strong>的锁。</p><p>② <strong>是否可手动释放：</strong></p><p>​    synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用；</p><p>​    ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。</p><p>③ <strong>是否公平锁</strong></p><p>​    公平锁介绍：多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁</p><p>​    synchronized为非公平锁 </p><p>​    ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空<strong>默认false非公平锁</strong>，true为公平锁。</p><p>④ <strong>是否可中断</strong></p><p>​    可中断介绍：</p><p>​    线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，</p><p>   如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断</p><p>   如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p><p>​    synchronized是不可中断类型的锁。</p><p>​    ReentrantLock可以中断，可通过<strong>tryLock</strong>(long timeout,TimeUnit unit)设置超时方法（超时没有获得锁就中断）或者将<strong>lockInterruptibly</strong>()放到代码块中，调用<strong>interrupt</strong>方法进行中断。</p><p>⑤ <strong>锁是否可绑定条件Condition</strong></p><p>​    synchronized不能绑定；     </p><p>​    ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的<strong>精确唤醒</strong>，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。</p><h2 id="Reentrantlock的底层实现"><a href="#Reentrantlock的底层实现" class="headerlink" title="Reentrantlock的底层实现"></a>Reentrantlock的底层实现</h2><p><strong>ReentrantLock</strong> 类内部总共存在<strong>Sync</strong>、<strong>NonfairSync</strong>、<strong>FairSync</strong>三个类，<strong>NonfairSync</strong>与 <strong>FairSync</strong>类继承自 <strong>Sync</strong>类，<strong>Sync</strong>类继承自 <strong>AbstractQueuedSynchronizer</strong>抽象类</p><p><strong>底层主要是AQS+CAS操作，AQS=双向链表+volatile类型的state状态量</strong></p><p>先讲一下AQS，AQS（AbstractQueuedSynchronizer）抽象队列同步器，是一个双向链表+volatile类型的state状态量所构成。</p><p>双向链表是由一个个Node组成的，没有抢到锁的线程被封装成Node节点放入队列中，每个Node节点有两个指针，叫做分别指向前驱结点和后继结点，同时还存有一个Thread的变量，代表封装的线程，需要注意的是，这些变量也都是Volatile类型的，主要是为了保证对其他线程课件。</p><p>state主要是表示是否有线程获取到锁了，当有线程获取到锁时，state=1，如果获取到锁的线程再次加锁，state加一；同理当释放锁时，state减一。当state=0时，会唤醒队列中的下一个节点。</p><p><strong>底层排队过程如下：</strong></p><p>主要分为抢到锁的线程，和没有抢到锁在队列里面排队的线程</p><p>首先A抢到锁了，state=1，当前线程改为A线程。</p><p>如果B线程再来抢锁，通过CAS操作先去判断state的值，发现state!=0; 去队列里面排队，排队之前并不会直接用头指针指向B线程所在的节点，而是先创建一个空节点，我们称这个空间点叫做哨兵节点，在哨兵节点创建完毕后，再把自己连接在哨兵结点之后。即先设置哨兵节点，再设置B节点</p><p>如果C再来抢锁，通过CAS，发现state!=0;去队列里面排队，发现头结点已经指向了一个哨兵节点，就不用再设置哨兵节点了，去B节点后面排队。</p><p>（排队的过程还涉及再次抢锁，如果没有进入park状态，等待A线程释放锁唤醒）</p><p>接着A线程释放锁，将state设为0，将B线程唤醒，同时受理窗口改为B线程，队列中的B节点Thread设置为null，并用头结点指向，那么开始的哨兵节点由于没有对象指向就变成了垃圾被GC掉。</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026103743409.png" alt="image-20211026103743409"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104027910.png" alt="image-20211026104027910"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104154035.png" alt="image-20211026104154035"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104257380.png" alt="image-20211026104257380"></p><p>第一次排队的节点是一个空节点</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026110225172.png" alt="image-20211026110225172"></p><p>如果队列中再来一个节点</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026110508921.png" alt="image-20211026110508921">    </p><p>B节点出队后，设置成了null，相当于是新的哨兵节点。而原来得哨兵节点没有任何引用指向它，就被GC掉</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026112122771.png" alt="image-20211026112122771"></p><p>按照自己理解的Reentrantlock的加锁和解锁过程：</p><p><strong>底层主要是AQS+CAS操作，AQS=双向链表+state状态量</strong></p><p>主要分为抢到锁的线程，和没有抢到锁在队列里面排队的线程</p><p>首先A抢到锁了，state=1，受理窗口改为A线程。</p><p>如果B线程再来抢锁，通过CAS，发现state!=0;去队列里面排队，排队之前先设置哨兵节点，在设置B节点</p><p>如果C再来抢锁，通过CAS，发现state!=0;去队列里面排队，发现头结点已经指向了一个哨兵节点，就不用再设置哨兵节点了，去B节点后面排队。</p><p>（排队的过程还涉及再次抢锁，如果没有进入park状态，等待A线程释放锁唤醒）</p><p>接着A线程释放锁，将state设为0，将B线程唤醒，同时受理窗口改为B线程，队列中的B节点Thread设置为null，并用头结点指向，那么开始的哨兵节点由于没有对象指向就变成了垃圾被GC掉。</p><p>。。。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java中几种锁的介绍</title>
    <link href="http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T07:25:38.000Z</published>
    <updated>2021-10-24T09:12:48.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中一些锁的介绍</p></blockquote><a id="more"></a><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当第二个线程想拿这个数据的时候，第二个线程会一直堵塞，直到第一个释放锁，他拿到锁后才可以访问。传统的数据库里面就用到了这种锁机制，例如：行锁，表锁，读锁，写锁，都是在操作前先上锁。<strong>java中的synchronized的实现也是一种悲观锁。</strong></p><p><strong>乐观锁</strong>：乐观锁概念为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有修改过数据，乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。在Java中java.util.concurrent.<strong>atomic包下面的Atomic操作类就是使用了乐观锁</strong>，<strong>而Atomic操作类的底层正是用到了“CAS机制”。</strong></p><p>采用悲观锁的一些问题（采用synchronized的一些问题）：</p><ul><li>在多线程竞争下，多次加锁释放锁会造成性能损耗</li><li>如果一个线程持有锁，其他的线程就都会阻塞，等待持有锁的线程释放锁。</li></ul><p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。</p><p>乐观锁就是：每次不加锁而是假设没有并发冲突去操作同一变量，如果有并发冲突导致失败，则重试直至成功。</p><p>主要就是两个步骤：<strong>冲突检测和数据更新</strong>。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，先来后到。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><p>简单来说就是：</p><p><strong>公平锁</strong> ：是指多个线程按照申请锁的顺序来获取锁，类回排队打饭先来后到。<br><strong>非公平锁</strong> ：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</p><p><strong>什么是饥饿？</strong></p><p>优先级高的线程能够插队并优先执行，这样如果<strong>优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。</strong>当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源。</p><p>ReentrantLock中就有相关公平锁，非公平锁的实现。默认是非公平锁，如果为设置为true就是公平锁。更深入的需要探寻其中的源码实现原理</p><h2 id="可重入锁和非重入锁"><a href="#可重入锁和非重入锁" class="headerlink" title="可重入锁和非重入锁"></a>可重入锁和非重入锁</h2><p>可重入锁：当前线程获取该锁后还可以再次获取，不会发生阻塞。</p><p>用一个简单的例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说A和B都是两个synchronized修饰的方法，在方法A中调用了方法B；有一个线程获取到了锁执行方法A，然后在执行方法B的时候就自动获取锁，去执行方法B；</p><p><strong>可重入锁可以避免线程死锁</strong>：</p><p>假如Synchronized不是可重入锁；那么该线程获取到执行A方法所需要的锁之后开始执行A方法；但是在执行过程中遇到了方法B；由于是不可重入锁；B方法也是被Synchronized关键字修饰；所以执行B方法也需要获取锁；但是此时A方法代码还未执行完成，继续占有锁；B方法就获取不到锁，被阻塞；A方法迟迟执行不完成，所以也就一直不释放锁；因此；就产生了死锁</p><p>synchronized和ReentrantLock都是可重入锁；当然ReentrantLock还可以设置成为公平锁，也就是不可重入锁；</p><p>不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;java中一些锁的介绍&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CAS和Atomic相关</title>
    <link href="http://example.com/2021/10/16/CAS%E5%92%8CAtomic%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/16/CAS%E5%92%8CAtomic%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-16T01:05:18.000Z</published>
    <updated>2021-11-05T02:42:44.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java.util.concurrent.atomic 和 java.util.concurrent.locks 是两个很重要的包</p></blockquote><a id="more"></a><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><p>这篇文章通俗易懂的解释了CAS操作  <a href="https://www.sohu.com/a/314272265_120104204">什么是CAS机制，通俗易懂大白话版</a></p><h3 id="什么是乐观锁与悲观锁？"><a href="#什么是乐观锁与悲观锁？" class="headerlink" title="什么是乐观锁与悲观锁？"></a><strong>什么是乐观锁与悲观锁？</strong></h3><p><strong>乐观锁</strong>：乐观锁概念为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有修改过数据。乐观锁的实现方式一般有两种：<strong>版本号机制</strong>和<strong>CAS操作</strong>。在Java中java.util.concurrent.<strong>atomic包下面的Atomic操作类就是使用了乐观锁</strong>，<strong>而Atomic操作类的底层正是用到了“CAS机制”。</strong></p><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当第二个线程想拿这个数据的时候，第二个线程会一直堵塞，直到第一个释放锁，他拿到锁后才可以访问。传统的数据库里面就用到了这种锁机制，例如：行锁，表锁，读锁，写锁，都是在操作前先上锁。<strong>java中的synchronized的实现也是一种悲观锁。</strong></p><p><strong>乐观锁与悲观锁的适用场景：</strong></p><p>总结：两种所各有优缺点，读取操作比较频繁使用乐观锁，写入操作比较频繁使用悲观锁。</p><p>因为写入操作比较频繁用乐观锁的话，发生冲突的可能性就会增大，就会不断自旋尝试</p><p>读取操作比较频繁的话，每次读取都需要加锁，开销太大，推荐使用乐观锁。</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般在数据表中加一个数据版本号version字段，每次对数据修改时,version加一；当有线程要更新数据时，在读取数据的同时还会读取version值，再提交更新的时候会再次读取version值，然后判断当前version值和之前的version值是否相同，如果相同则提交成功，如果失败则重复上述操作直到成功为止。</p><p><strong>流程示意：</strong></p><p>当线程要更新数据了-》读取数据同时读取版本号-》更新提交时再次读取版本号-》对照两次版本号是否相同</p><p>-》若版本号相同说明没有其他线程更改数据，更新成功 ；若不相同则更改失败再次重复上述操作。</p><h3 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h3><p><strong>乐观锁是一种思想，CAS是这种思想的一种实现方式。</strong></p><p>相比于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以在性能上有了很大的提升。</p><p><strong>CAS是乐观锁技术，当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋</strong>。Java中的自旋锁就是利用CAS来实现的。</p><p>CAS即Compare And Swap，翻译成中文即比较并替换。Java中可以通过CAS操作来保证原子性，原子性就是一系列操作，要么全部完成，要么失败，不能被中断。</p><p>CAS操作包括三个操作数：需要读写的内存值(V)、预期原值(A)、新值(B)。</p><p><strong>算法流程</strong>：比较A和V的值，如果相等，将B值赋值给A，如果不相等说明有其他线程对该变量做了更新，自旋或者不做操作</p><h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><ul><li><p><strong>ABA问题</strong></p><p>如果一个变量V初次读取时是A的值，在再次被读取的期间，先被其他线程修改成B又被修改成A，则CAS操作会认为它从来没有被修改过，显示这是错误的。</p><p><strong>ABA问题解决方案：加上版本号</strong></p><p>JUC的atomic包里提供了一个类<strong>AtomicStampedReference</strong>来解决ABA问题。</p><p>给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使内存V中的值从A-&gt;B-&gt;A，但是版本号也发生了变化。基于CAS的乐观锁也是这个实现原理。</p></li><li><p><strong>循环时间过长导致开销太大</strong></p><p>CAS自旋不成功，就一直循环执行，如果长时间不成功，会给CPU带来非常大的执行开销</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>但如果对多个共享变量进行操作时，CAS则无法保证操作的原子性，这时候就需要用锁了。</p></li></ul><h3 id="CAS和synchronized对比"><a href="#CAS和synchronized对比" class="headerlink" title="CAS和synchronized对比"></a>CAS和synchronized对比</h3><p>1.对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p><p>2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><h3 id="分析atomic包下的原子操作类AtomicInteger（待解决）"><a href="#分析atomic包下的原子操作类AtomicInteger（待解决）" class="headerlink" title="分析atomic包下的原子操作类AtomicInteger（待解决）"></a>分析atomic包下的原子操作类AtomicInteger（待解决）</h3><p>我们看一下AtomicInteger类中常用的自增方法incrementAndGet，相当于i++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">int</span> current = get();  </span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line">                <span class="keyword">return</span> current;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/JUC%E5%8C%85%E4%B8%8Batomic%E5%92%8Clocks%E7%9B%B8%E5%85%B3/webp.webp" alt="img"></p><p>实现CAS操作的应该是getAndAddInt（）方法，</p><p>核心实现是先获取当前值和目标值（也就是value+1），如果<code>compareAndSet(current, next)</code> 返回成功则该方法返回目标值。那么compareAndSet是做什么的呢？理解这个方法我们需要引入CAS操作。</p><p>AtomicInteger 中的CAS操作就是<code>compareAndSet()</code>，其作用是每次从<strong>内存中根据内存偏移量（<code>valueOffset</code>）取出数据</strong>，将取出的值跟expect 比较，如果数据一致就把内存中的值改为update。</p><p>这样使用CAS就保证了原子操作。其余几个方法的原理跟这个相同，在此不再过多的解释。</p><p>没看AtomicInteger 源码之前，我认为其内部是用<code>synchronized</code> 来实现的原子操作。查阅资料后发现<code>synchronized</code> 会影响性能，因为Java中的<code>synchronized</code> 锁是独占锁，虽然可以实现原子操作，但是这种实现方式的并发性能很差。</p><p><strong>1. java语言CAS底层如何实现？</strong></p><p><strong>利用unsafe提供的原子性操作方法。</strong></p><p>总结一下，AtomicInteger 中主要实现了整型的原子操作，防止并发情况下出现异常结果，其内部主要依靠JDK 中的unsafe 类操作内存中的数据来实现的。volatile 修饰符保证了value在内存中其他线程可以看到其值得改变。CAS操作保证了AtomicInteger 可以安全的修改value 的值。</p><h2 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h2><p>Atomic原子类位于java.util.concurrent.atomic包下，<strong>原子类就是具有原子操作特征的类</strong>。原子操作特征是指：多个操作要么都成功要么都失败，不会被其他线程干扰。</p><p>四种原子类：基本类型（3个）、数组类型（3个）、引用类型、原子更新字段类</p><p><img src="/images/JUC%E5%8C%85%E4%B8%8Batomic%E5%92%8Clocks%E7%9B%B8%E5%85%B3/image-20211016113025301.png" alt="image-20211016113025301"></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>也简单介绍一下</p><p>AQS的全称是AbstractQueuedsynchronizer，抽象队列同步器，它是Java并发用来构建锁和其他同步组件的基础框架。</p><p>变量+一个队列</p><p>ReentrantLock<br>CountDownLatch<br>ReentrantReadWriteLock<br>Semaphore                                   这四个是什么意思？</p><p>锁和同步器区别？</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>简单介绍一下</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent.atomic 和 java.util.concurrent.locks 是两个很重要的包&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>volatile深入理解</title>
    <link href="http://example.com/2021/10/15/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/15/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-15T11:47:13.000Z</published>
    <updated>2021-10-26T07:01:42.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>volatile</p></blockquote><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>介绍并发编程的三大特性：原子性、可见性、有序性</p><p>volatile不具有原子性，具有可见性和有序性</p><p>其底层实现原理也是围绕这两点来展开的</p><p>volatile主要的作用包括两点：</p><p>1.<strong>保证线程间共享变量的可见性。</strong>（可见性）</p><p>2.<strong>禁止CPU进行指令重排序。</strong>（有序性）使用内存屏障禁止指令重排</p><h2 id="volatile实现可见性原理"><a href="#volatile实现可见性原理" class="headerlink" title="volatile实现可见性原理"></a>volatile实现可见性原理</h2><p>首先介绍一下JMM模型</p><p>可见性问题是由Java内存模型中的工作内存和主内存之间的值不一致所导致</p><p>例如上面所说线程1访问自己工作内存A中的值时，但此时主内存的该值已经被线程2所修改，所以线程1所访问到的值是一个脏数据。</p><p>那如何解决这种问题呢？用volatile修饰共享变量</p><p>可以发现通过volatile修饰的变量，生成汇编指令时会比普通的变量多出一个Lock指令，这个Lock指令就是volatile关键字可以保证内存可见性的关键，它主要有两个作用：</p><ul><li>将当前处理器缓存的数据刷新到主内存。</li><li>刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效。</li></ul><p>因此其他线程会直接从主内存中读取数据，</p><h2 id="volatile实现有序性原理（内存屏障没看懂）"><a href="#volatile实现有序性原理（内存屏障没看懂）" class="headerlink" title="volatile实现有序性原理（内存屏障没看懂）"></a>volatile实现有序性原理（内存屏障没看懂）</h2><blockquote><p>前面提到的指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但在多线程程序中可能导致程序的运行结果不正确，那volatile是如何解决这一问题的呢？</p></blockquote><p>为了实现volatile的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。</p><p>内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p><p>java虚拟机把内存屏障分为4类：</p><img src="/images/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211015223529379.png" alt="内存屏障" style="zoom:80%;" /><p>Java内存模型对编译器指定的volatile重排序规则为：</p><ul><li><p>当第一个操作是volatile读时，无论第二个操作是什么都不能进行重排序。</p></li><li><p>当第二个操作是volatile写时，无论第一个操作是什么都不能进行重排序。</p></li><li><p>当第一个操作是volatile写，第二个操作为volatile读时，不能进行重排序。</p></li></ul><p>根据volatile重排序规则，Java内存模型采取的是保守的屏障插入策略，volatile写是在前面和后面分别插入内存屏障，volatile读是在后面插入两个内存屏障，具体如下：</p><h2 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h2><ul><li><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。</p></li><li><p>volatile 关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。</p></li><li><p>volatile关键字只能用于变量，synchronized关键字用来修饰方法以及代码块。</p></li><li><p>volatile 关键字不能保证原子性，synchronized关键字能保证原子性</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;volatile&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java线程池相关</title>
    <link href="http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-15T03:38:17.000Z</published>
    <updated>2021-11-03T01:24:16.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程池相关</p></blockquote><a id="more"></a><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a><strong>什么是线程池？</strong></h2><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>有了线程池后，如果我们要处理多线程的任务，直接从线程池中去取线程即可，而不用每个请求任务都创建和销毁线程，提高服务器的性能。</p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a><strong>为什么要使用线程池？</strong></h2><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程太耗费性能，于是我们可以使用线程池技术把创建和销毁的线程的过程去掉，直接从线程池中取出线程</p><h2 id="线程池有什么作用？"><a href="#线程池有什么作用？" class="headerlink" title="线程池有什么作用？"></a><strong>线程池有什么作用？</strong></h2><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><h2 id="创建线程池的方法"><a href="#创建线程池的方法" class="headerlink" title="创建线程池的方法"></a>创建线程池的方法</h2><p>创建出来的线程池都实现了ExecutorService接口。常用方法有以下几个：</p><p>1、<strong>使用自定义的ThreadPoolExecutor类</strong></p><p>2、<strong>使用Executors类（四种线程池）</strong></p><p>Executors类为我们提供了四种常见的线程池，但本质上都是调用ThreadPoolExecutor的构造函数，只是构造函数的参数不同。使用Executors类创建线程池可能会造成OOM，比如说我们使用Exexutors类中的newFixedThreadPool，意思是创建一个固定大小的线程池，超过了这个大小就要在等待队列中排队，而等待队列的最大值是Integer.Max_Value，相当于无穷大，当我们不断创建线程执行的时候就会超出堆空间的内存，导致OOM的发生，所以我们建议使用自定义的ThreadPoolExecutors类，并设置等待队列的大小。</p><p>所以我们推荐使用ThreadPoolExecutors的方法，根据我们的需要自定线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.调用ThreadPoolExecutos的构造函数创建一个对象</span></span><br><span class="line"><span class="comment">//2.调用这个对象的execute方法，execute方法中一般是一个实现了runnable接口的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">            ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">60</span>, TimeUnit.MICROSECONDS, <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">                Runnable task = <span class="keyword">new</span> CustomTask(i);</span><br><span class="line">                <span class="comment">//将runnable对象作为参数传入pool.execute中。</span></span><br><span class="line">                pool.execute(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说几种常见的线程池及使用场景"><a href="#说说几种常见的线程池及使用场景" class="headerlink" title="说说几种常见的线程池及使用场景"></a><strong>说说几种常见的线程池及使用场景</strong></h2><p><strong>java.util.concurrent.Executors类为我们提供了创建线程池的简便方法。</strong></p><p>使用Executors可以创建我们常用的四种线程池：</p><p>（1）newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。不设上限，提交的任务将立即执行。</p><p>（2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>（3）newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>（4）newSingleThreadExecutor 创建一个单线程化的线程池执行任务。</p><blockquote><p>这几种线程池的源码都调用了ThreadPoolExecutor的构造函数</p></blockquote><p><strong>Executors的坏处</strong></p><p>正常来说，我们<strong>不应该使用这种方式创建线程池</strong>，应该使用<strong>ThreadPoolExecutor</strong>来创建线程池。Executors创建的线程池也是调用的ThreadPoolExcutor的构造函数。通过源码可以看出：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015164333196.png" alt="newFixedThreadPool"></p><p>我们也看到了这里面的LinkedBlockingQueue并没有指定队列的大小，是一个无界队列，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致OOM。所以我们一般要使用ThreadPoolExecutor这种方式来创建线程池。</p><p><strong>创建线程池的正确姿势：</strong></p><p>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>或者是使用开源类库：开源类库，如apache和guava等。</p><p><strong>五种线程池的使用场景</strong></p><p>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</p><p>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</p><p>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</p><p>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h2 id="线程池中的几种重要的参数（7个）"><a href="#线程池中的几种重要的参数（7个）" class="headerlink" title="线程池中的几种重要的参数（7个）"></a><strong>线程池中的几种重要的参数</strong>（7个）</h2><p><strong>ThreadPoolExecutors构造函数中7个重要的参数：</strong></p><ul><li><p>corePoolSize就是线程池中的核心线程数量，即使这些线程处理空闲状态，他们也不会被销毁</p></li><li><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p></li><li><p>keepAliveTime，非核心线程在空闲状态下的最大存活时间，超过这个时间，非核心线程就会被销毁</p></li><li><p>util，表示最长存活时间的单位。</p></li><li><p>workQueue，就是等待队列，当核心线程数满了后其他请求就储存在任务队列中，等待被执行，按照FIFIO原则（先进先出）。</p></li><li><p>threadFactory，就是创建线程的线程工厂。</p></li><li><p>handler,是一种拒绝策略，当线程池中线程数量满了后，拒绝执行某些任务。（4种内置的拒绝策略）</p></li></ul><p><strong>线程池提交任务时的执行流程：</strong></p><p>当我们创建好线程池后，要向线程池提交任务时：</p><p>会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</p><p>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</p><p>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</p><p>如果已经达到了最大线程数，则执行指定的拒绝策略。</p><p><strong>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</strong></p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015180107031.png" alt="线程池提交任务时的执行流程"></p><p>举个例子：corePoolSize为2，maximumPoolSize为6，workQueue大小为5；</p><p><strong>第一步</strong>，任务0、1提交时，创建核心线程并执行<br><strong>第二步</strong>，任务2、3、4、5、6提交时，将其放在工作队列（工作队列能容纳5个线程）<br><strong>第三步</strong>，任务7、8、9、10提交时，创建线程并执行，直到池子满了（工作队列也满了，多一个线程就创建一个新线程，但总线程数不能大于maximumPoolSize）<br><strong>第四步</strong>，任务11、12、13、14、15被拒绝策略拒绝（什么时候被拒绝策略拒绝呢？当请求线程数&gt;工作队列容量+ maximumPoolSize时）<br><strong>第五步</strong>，执行缓存队列中的任务2、3、4、5、6</p><h2 id="线程池常用的阻塞队列（没有很理解）"><a href="#线程池常用的阻塞队列（没有很理解）" class="headerlink" title="线程池常用的阻塞队列（没有很理解）"></a>线程池常用的阻塞队列（没有很理解）</h2><ol><li><p><strong>LinkedBlockingQueue</strong></p><p>LinkedBlockingQueue，它的容量是 Integer.MAX_VALUE，为 2^31 -1 ，是一个非常大的值，可以认为是无界队列。</p><p>这里需要注意，FixedThreadPool 和 SingleThreadExecutor 线程池的线程数是固定的，其中maximumPoolSize这个参数是没有用的，因为阻塞队列根本就放不满，所以线程池只会创建核心线程数量的线程</p></li><li><p><strong>SynchronousQueue</strong><br> 第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。<br> 我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p></li><li><p><strong>DelayedWorkQueue</strong><br> 第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p></li></ol><p>下面是四种线程池对应的阻塞队列：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015181738391.png" alt="image-20211015181738391"></p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a><strong>线程池的拒绝策略</strong></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当线程池中最大线程数满了后，我们需要采取拒绝策略。</span><br><span class="line">在ThreadPoolExecutor中已经包含四种处理策略，默认为AbortPolicy策略，即丢弃任务并抛出异常。</span><br></pre></td></tr></table></figure><ul><li><p>AbortPolicy策略：丢弃任务并抛出RejectedExecutionException异常。</p></li><li><p>DiscardPolicy策略：丢弃任务，但是不抛出异常。</p></li><li><p>DiscardOlddestPolicy策略： 该策略将丢弃最老的一个请求，也就是工作队列中最前面的一个请求，并再次提交当前任务。</p></li><li><p>CallerRunsPolicy 策略：如果线程池未关闭，由调用线程（即提交任务的线程）执行此该请求</p></li></ul><p><strong>自定义拒绝策略</strong>：除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，只需实现RejectedExecutionHandler接口即可。</p><h2 id="线程池的执行任务和关闭"><a href="#线程池的执行任务和关闭" class="headerlink" title="线程池的执行任务和关闭"></a>线程池的执行任务和关闭</h2><p><strong>execute和submit用来执行线程池中的任务</strong></p><ul><li>execute（）方法用于不需要提交返回值的任务</li><li>submit（）方法用于需要提交返回值的任务。</li></ul><p><strong>线程池的关闭</strong></p><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><ul><li><p>shutdownNow（）方法的解释是：线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。</p></li><li><p>shutdown（）方法的解释是：线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。</p></li></ul><p><strong>初始化线程池时线程数的选择</strong></p><p>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</p><p>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</p><p>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线程池相关&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized深入理解</title>
    <link href="http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-13T01:55:05.000Z</published>
    <updated>2021-11-03T08:55:17.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>synchronized </p></blockquote><a id="more"></a><h2 id="线程安全问题和线程同步"><a href="#线程安全问题和线程同步" class="headerlink" title="线程安全问题和线程同步"></a>线程安全问题和线程同步</h2><p><strong>线程安全问题</strong>：多个线程共同操作共享数据。使用线程同步来解决线程安全问题。</p><p><strong>线程同步</strong>：当存在多个线程操作共享数据时，需要保证同一时刻只有一个线程在操作共享数据，其他线程必须等到该线程处理完共享数据后，才能进行操作</p><p>面试题：<strong>线程有哪些同步的方法？</strong></p><ul><li>synchronized修饰代码块或者方法</li><li>volatile修饰共享变量</li><li>juc包下的锁（比如Reentrantlock重入锁）</li><li>Atomic原子类（比如AutomicInteger）</li><li>线程安全的并发集合（ConcurrentHashMap）</li></ul><h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><ul><li> synchronized可以保证<strong>在同一个时刻</strong>，<strong>只有一个线程</strong>可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)</li><li>synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能） </li></ul><p><strong>具体用法：</strong></p><ul><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ul><p>具体如下：</p><ul><li>对于实例方法，锁是当前<strong>类的实例对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于静态方法，锁是当前<strong>类的Class对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 对于同步方法块，锁是<strong>synchonized括号里配置的对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对当前实例对象this加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对class对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized修饰方法和修饰代码块的区别？</strong></p><p>从宏观层面上看有两点：</p><ul><li>锁的范围不同。一个是整个方法中的方法体，一个是一部分代码块，相对来说用代码块的方式更加灵活</li><li>锁的对象不同。修饰方法时，对于静态方法，是把类的class对象作为锁；对于非静态方法，是把类的实例对象作为锁；修饰代码块时，是把括号中传入的对象作为锁。</li></ul><p>从底层原理上来看：</p><ul><li><h2 id="java对象在JVM中的构成"><a href="#java对象在JVM中的构成" class="headerlink" title="java对象在JVM中的构成"></a>java对象在JVM中的构成</h2></li></ul><p>在JVM中，java对象由三部分构成：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。如下图所示：</p><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/SouthEast.png" alt="这里写图片描述"></p><p><strong>对象头：</strong></p><p>HotSpot虚拟机的对象头包括两部分信息：</p><ol><li><strong>Mark Word</strong><br>会记录<strong>对象和锁的有关信息</strong>，比如：<strong>对象的hashCode、分代年龄和锁标记位</strong>，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。</li><li><strong>klass 指针</strong><br>它是一个指向类的数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.</li><li><strong>数组长度（只有数组对象有）</strong><br>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.</li></ol><p><strong>实例数据：</strong>对象真正存储的有效信息，比如我们在java代码中定义对象一些属性值</p><p><strong>对齐填充：</strong>对齐填充并不是必然存在的，相当于是占位符的作用，JVM要求对象的大小必须是8字节的整数倍。而对象头这部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="MarkWord中记录了对象中锁相关信息"><a href="#MarkWord中记录了对象中锁相关信息" class="headerlink" title="MarkWord中记录了对象中锁相关信息"></a>MarkWord中记录了对象中锁相关信息</h3><p>在jdk1.6之前，synchronized被称为<strong>重量锁</strong>，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了<strong>偏向锁和轻量级锁</strong>。</p><p>前面介绍了java对象的构成，我们重点关注对象头中的MarkWord，它记录了锁相关的信息。</p><p>在程序运行期间，MarkWord中存储的数据会随着锁标志位的变化而变化，在64位虚拟机中，不同状态下的组成如下：</p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211014220803850.png" alt="image-20211014220803850" style="zoom:80%;" /><p>其中线程ID表示持有偏向锁线程的ID，Epoch表示偏向锁的时间戳，偏向锁和轻量级锁是在jdk1.6中引入的。</p><h3 id="重量级锁的底部实现原理：Monitor"><a href="#重量级锁的底部实现原理：Monitor" class="headerlink" title="重量级锁的底部实现原理：Monitor"></a>重量级锁的底部实现原理：Monitor</h3><p><strong>synchronized底层原理 = java对象头markword + 操作系统对象monitor：</strong></p><p>在jdk1.6之前，synchronized只能实现重量级锁，synchronized是基于<strong>Monitor对象</strong>来实现重量级锁的，Monitor是操作系统底层的一个对象，使用c++语言编写的，<strong>每个锁都关联一个Monitor对象</strong>，synchronized的加锁释放锁也就是获取和释放Monitor对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分重要的属性</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">//锁计数器</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//锁的重入次数</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">//指向拥有该Monitor的线程地址，即哪个线程拥有Monitor</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzY0NDY4,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><strong>获取Monitor和释放Monitor的流程如下：</strong></p><p>关键字：WaitSet、Owner、EntryList阻塞队列</p><p>我们把synchronized代码中的代码称为临界区代码。</p><ul><li>当多个线程访问同步代码块时，线程t1要执行临界区的代码时，首先会通过synchronized括号中的obj对象的markword指向一个monitor锁对象</li><li>当Thread-1线程持有monitor对象后，就会把monitor中的owner变量设置为当前线程Thread-1，同时count+1，recursions+1</li><li>当另一个线程Thread-2想要执行临界区的代码时，要判断monitor对象的属性Owner是否为null，如果为null，Thread-2线程就获得了锁，可以执行临界区的代码；如果不为null，Thread-2线程就会放入monitor的EntryList阻塞队列中，并处于阻塞状态Blocked。</li><li>当获取锁的线程调用wait（）方法时，则会将owner设置为null，同时count减1，recursions减1，当前线程加入到WaitSet中，等待被唤醒。</li><li>当前线程执行完同步代码块时，会释放monitor(锁)并将owner置为null，同时count-1，recursions-1，当recursions = 0 时，说明当前线程已经释放完了锁，这时会通知EntryList阻塞队列中的线程，唤醒里面阻塞的线程。</li></ul><h3 id="JVM指令分析同步代码块和同步方法"><a href="#JVM指令分析同步代码块和同步方法" class="headerlink" title="JVM指令分析同步代码块和同步方法"></a><strong>JVM指令分析同步代码块和同步方法</strong></h3><p><strong>JVM是如何实现同步代码块和同步方法的呢？</strong></p><p>JVM是通过<strong>获取和释放Monitor对象</strong>来实现代码块同步和方法同步的</p><ul><li><p>同步代码块是通过<strong>monitorenter **指令（获取锁）和</strong>monitorexit**（释放锁）指令来实现的；</p></li><li><p>而同步方法是通过<strong>ACC_SYNCHRONIZED标识符</strong>来隐式的调用monitorenter（获取锁）和monitorexit（释放锁）来实现的。</p></li></ul><p>synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块时，计数器的数量会1，直到计数器的数量为0，就释放这个锁。</p><p>synchronized不可中断性：</p><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会—直阻塞或等待，不可被中断。</p><h2 id="JDK6后对synchronized的优化（还有一篇文章找时间看看）-java中锁升级的过程"><a href="#JDK6后对synchronized的优化（还有一篇文章找时间看看）-java中锁升级的过程" class="headerlink" title="JDK6后对synchronized的优化（还有一篇文章找时间看看）/ java中锁升级的过程"></a>JDK6后对synchronized的优化（还有一篇文章找时间看看）/ java中锁升级的过程</h2><p>看看这篇文章对synchronized几种锁的介绍</p><p><a href="https://blog.csdn.net/qq_42764468/article/details/106603249">https://blog.csdn.net/qq_42764468/article/details/106603249</a></p><h3 id="为什么要优化？"><a href="#为什么要优化？" class="headerlink" title="为什么要优化？"></a><strong>为什么要优化？</strong></h3><p>因为Java虚拟机是通过获得和释放Monitor对象来实现代码块同步和方法同步的，而这个过程需要操作系统从用户态切换到内核态，这个切换成本比较高。</p><p>因此，在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，对synchronized锁的实现进行了大量的优化，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术。锁的状态变成了四种，<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，锁的状态会随着竞争激烈逐渐升级，并且升级方向是不可逆的（<strong>弄明白什么时候会升级？</strong>）</p><p><strong>用户态和内核态是什么？</strong></p><p>用户态和内核态是操作系统的两种cpu状态</p><p>用户态：不能直接调用底层的硬件资源，访问资源受到限制，需要系统调用。</p><p>内核态：操作系统直接操作硬件资源。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><strong>为什么要引入自旋锁？</strong></p><p>线程的阻塞和唤醒需要CPU从用户态转为内核态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。而且很多情况下，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p><strong>自旋锁原理？</strong></p><p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换，从而进入阻塞状态，它们只需要等一等，这个等待的过程我们就叫做自旋，等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户态和内核态切换的消耗</strong>。</p><p>但是我们的线程自旋是需要消耗cpu的，说白了就是让cpu在做无用功，如果一直获取不到锁，那线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果在自旋等待的最大时间内持有锁的线程仍没有释放锁，那么线程就会停止自旋进入阻塞状态</p><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；<br>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><p>适应自旋锁是对自旋锁的改进。它自旋的次数不再是固定的，由上一个线程在这个锁上的自旋时间以及是否获取到了锁来决定的。上一个线程如果自旋成功了，那么下次自旋的次数会更多。因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待的次数更多。反之，如果对于某个锁，很少有线程能够自旋成功的，那么允许自旋等待的次数就会更少甚至会不让自旋。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JVM编译器在运行时分析发现有些数据不存在竞争，所以就不用加锁浪费性能，于是就通过JVM编译器优化将锁消除。所以锁消除可以介绍毫无意义的请求锁的时间。</p><p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候<strong>会存在隐形的加锁操作</strong>。比如<strong>StringBuffer的append()方法，Vector的add()方法：</strong></p><p>比如StringBuffer的append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sBuf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sBuf.append(str1);<span class="comment">// append方法是同步操作</span></span><br><span class="line">        sBuf.append(str2);</span><br><span class="line">        <span class="keyword">return</span> sBuf.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源，这时我们可以通过编译器将其优化，将锁消除</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>大部分情况下我们是要让锁的粒度最小化，这样可以减少锁的竞争，增加并发度。</p><p><strong>锁的粗化则是要增大锁的粒度，</strong>因为一系列连续地加锁释放锁操作，可能会导致不必要的性能损耗，为了避免性能损耗，所以引入锁粗化的概念。</p><p>一个例子：比如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把锁放到循环的外面</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>为什么要引入偏向锁？</strong></p><p>很多情况下，锁不存在多线程竞争，总是由同一线程获得，为了让线程获得锁的代价更低，引进了偏向锁。</p><p><strong>概述：</strong></p><p>偏向锁会在对象头MarkWord中存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，以及 ThreadID（代表锁偏向的线程）,就不用反复获取锁释放锁，减轻了性能消耗。</p><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211024153708430.png" alt="image-20211024153708430"></p><p><strong>获取锁的过程</strong></p><ol><li>检测Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li><li>如果为可偏向状态，检测线程ID是否为当前线程ID，如果是就执行同步代码块。</li><li>如果线程ID不为当前线程ID，则通过CAS操作来竞争锁，竞争成功，就将Mark Word的线程ID替换为当前线程ID，执行同步块。</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点时，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li></ol><blockquote><p>通过CAS操作竞争锁是什么意思？</p></blockquote><p><strong>释放锁的过程</strong><br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，<strong>线程是不会主动去释放偏向锁</strong>，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211015104403000.png" alt="64位markword"></p><h3 id="轻量级锁（有点没弄懂和偏向锁的关系）"><a href="#轻量级锁（有点没弄懂和偏向锁的关系）" class="headerlink" title="轻量级锁（有点没弄懂和偏向锁的关系）"></a>轻量级锁（有点没弄懂和偏向锁的关系）</h3><p>轻量级锁是由偏向所升级来的，当一个线程获得偏向锁，另一个线程竞争这把偏向锁，偏向锁就会升级为轻量级锁；</p><p><strong>获取锁的过程</strong></p><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><p><strong>释放锁的过程</strong><br>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>见前面</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;synchronized &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java并发基础知识</title>
    <link href="http://example.com/2021/10/12/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/10/12/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-10-12T01:20:10.000Z</published>
    <updated>2021-10-29T03:34:11.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前写过好几篇多线程相关的，不过总差点意思</p></blockquote><a id="more"></a><p><strong>进程与线程相关</strong></p><p>1.什么是进程（操作系统资源分配的基本单位）？什么是线程（处理器任务调度的基本单位）（从1.两个基本单位 2.轻量级进程、包含多个线程 3.JVM内存结构共享资源方面）</p><p>面试题：<strong>进程和线程的区别</strong></p><ul><li>进程（操作系统资源分配的基本单位，线程（处理器任务调度的基本单位）</li><li>一个进程包含多个线程，线程又被称为轻量级进程，线程的切换开销小于进程</li><li>每个线程的程序计数器、虚拟机栈、本地方法栈是私有的，而堆和方法区是共享的。</li></ul><p>面试题：<strong>为什么有了进程还要有线程呢？</strong></p><p>从进程的缺点出发，进程在同一时刻只能做一件事，如果执行的过程中被阻塞，那么有些资源就得不到执行，</p><p>线程可以将进程的任务更细粒化，提高并发性。</p><p>面试题：<strong>浏览器开一个标签页是创建进程还是线程？</strong></p><p>进程，可以从任务管理器上面看到。主要是进程不共享资源，线程之间共享资源。如果标签页是一个个线程，那么很可能会一个标签页崩溃而影响到其他标签页。</p><p>什么是协程？</p><p>一个线程也可以包含多个协程，<strong>线程是操作系统调度，协程是用户调度</strong>，协程是一个函数</p><hr><p>2.并发（一个时间段多个进程时间片轮转）和并行（一个时刻多个）的区别</p><p>3.多线程的优缺点（为什么使用多线程、多线程会引发什么问题）</p><p>（优点提高cpu的利用率，缺点上下文切换影响多线程执行速度、死锁、）</p><p>线程上下文切换</p><h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><p>java中线程分为两种类型：<strong>用户线程</strong>和<strong>守护线程</strong>。通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。</p><p>用户线程：平时创建的线程均为用户线程。<br>守护线程：用来服务用户线程的线程，例如垃圾回收线程。</p><p>用户线程和守护线程的区别：</p><p>1.主线程结束后用户线程还会继续运行，JVM存活；</p><p>2.如果没有用户线程，都是守护线程，那么JVM结束，进而守护线程也会退出</p><p><strong>总结：</strong></p><ul><li>java中的线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li><li>程序中的所有的用户线程结束之后，不管守护线程处于什么状态，java虚拟机都会自动退出</li><li>调用线程的实例方法setDaemon()来设置线程是否是守护线程（true为守护线程，false为用户线程）</li><li>setDaemon()方法必须在线程的start()方法之前调用，在后面调用会报异常，并且不起效</li><li>线程的daemon默认值和其父线程一样</li></ul><h2 id="线程的生命周期和状态（6个）"><a href="#线程的生命周期和状态（6个）" class="headerlink" title="线程的生命周期和状态（6个）"></a>线程的生命周期和状态（6个）</h2><p>六个状态：新建(new)、运行(runnable)、阻塞(block)、等待(waiting)、超时等待(time_waiting)、终止(terminated)。</p><p><strong>新建</strong>：线程被创建</p><p><strong>运行</strong>：调用了线程的start()方法，可能正在运行也可能处于就绪状态，当拿到cpu轮转时间片后，就绪状态会变为正在运行</p><p><strong>阻塞</strong>：线程没有抢到锁进入阻塞状态</p><p><strong>等待</strong>：由于线程调度而等待，需要其他线程唤醒。wait()、join()</p><p><strong>超时等待</strong>：在等待的基础上增加了超时限制，限定等待的时间。sleep()</p><p><strong>终止</strong>：线程执行完毕</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110744753.png" alt="image-20211012110744753"></p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110853349.png" alt="image-20211012110853349"></p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110906205.png" alt="image-20211012110906205"></p><h2 id="创建线程有哪几种方法？（3个）"><a href="#创建线程有哪几种方法？（3个）" class="headerlink" title="创建线程有哪几种方法？（3个）"></a>创建线程有哪几种方法？（3个）</h2><p>创建多线程常见的四种方法：</p><ul><li>继承Thread类创建线程</li><li>实现Runnable接口创建线程</li><li>实现callable接口创建线程</li></ul><p><strong>继承Thread类创建线程</strong>，1.首先继承Thread类，重写run()方法，2.创建Thread类子类对象  3.调用子类对象start()方法。</p><p><strong>实现Runnable接口创建线程</strong>：1.实现Runnable接口，重写run()方法；2.创建这个类的对象，作为参数传入Thread类的构造方法中  3.调用Thread对象的start()方法。</p><p><strong>使用Callable和Future创建线程</strong>：1.实现Callable接口，重写call()方法  2.创建这个类的对象，作为参数传入FutureTask构造函数中。3.将FutureTask对象作为参数，创建Thread构造函数中。4.调用Thread对象的start()方法。</p><h2 id="Runnable和callable的区别"><a href="#Runnable和callable的区别" class="headerlink" title="Runnable和callable的区别"></a>Runnable和callable的区别</h2><p>相同点：两者都需要调用Thread.start()启动线程；</p><p>不同点：是否有返回值、是否能抛出异常</p><p>1、两者最大的不同点是：实现Callable接口的任务线程有返回值；Runnable接口的任务线程不能返回结果；<br>2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的不可以</p><h2 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h2><p>1.线程中的具体任务的执行是通过run（）来实现的，而线程的启动是通过start（）方法执行的。<br>2.run（）方法可以重复调用，start（）方法只能调用一次</p><h2 id="为什么调用start-方法时会执行run-方法，而不直接执行run-方法？"><a href="#为什么调用start-方法时会执行run-方法，而不直接执行run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，而不直接执行run()方法？"></a>为什么调用start()方法时会执行run()方法，而不直接执行run()方法？</h2><p>总结：调用start（）方法方可启动一个线程，并使线程进入就绪状态，等分配到时间片会自动调用其中的run（）方法；如果我们直接执行run（）方法时，只会把它看成是main（）线程中一个普通方法去执行，并不会在其他的线程中执行，所以不是多线程。</p><h2 id="线程是怎么进行通信的？（待解决）"><a href="#线程是怎么进行通信的？（待解决）" class="headerlink" title="线程是怎么进行通信的？（待解决）"></a>线程是怎么进行通信的？（待解决）</h2><h2 id="线程安全问题和线程同步"><a href="#线程安全问题和线程同步" class="headerlink" title="线程安全问题和线程同步"></a>线程安全问题和线程同步</h2><p>线程安全问题：多个线程共同操作共享数据</p><p>线程同步：当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完共享数据后，才能进行操作</p><p>面试题：线程有哪些同步的方法？</p><ul><li>synchronized修饰代码块或者方法</li><li>volatile修饰共享变量</li><li>juc包下的锁（比如Reentrantlock重入锁）</li><li>juc包下的并发集合类（比如ConcurrentHashMap）</li><li>Atomic原子类（比如AutomicInteger）</li></ul><h2 id="线程调度的一些方法"><a href="#线程调度的一些方法" class="headerlink" title="线程调度的一些方法"></a>线程调度的一些方法</h2><ul><li><p>wait():</p></li><li><p>sleep():</p></li><li><p>join():执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队列，直到join结束或中断线程B才开始进入阻塞队列。</p><p>将join理解为插队，比如说A.join() ，那么在当前运行的线程进入阻塞队列，A插入进去。</p><p><a href="https://blog.csdn.net/u013425438/article/details/80205693">https://blog.csdn.net/u013425438/article/details/80205693</a>  对join方法的理解</p></li><li><p>yield():</p></li><li><p>notify():</p></li></ul><h2 id="sleep-方法和wait-方法的区别"><a href="#sleep-方法和wait-方法的区别" class="headerlink" title="sleep()方法和wait()方法的区别"></a>sleep()方法和wait()方法的区别</h2><p>两者都可以使当前线程进入阻塞状态</p><ul><li>sleep是Thread类中的方法，但是wait是Object类中的方法。</li><li>sleep方法在任何地方使用都可以，但是wait需要放在同步方法或者同步代码块中</li><li>sleep方法不会释放锁，但是wait会释放锁，而且会加入到等待队列中。也就是说，一个线程如果抢到锁执行sleep方法，只是会暂时休眠，其他线程不能进入这个同步方法；而如果一个线程执行的是wait方法，则会被放入等待队列中，其他线程可以进入同步代码块中。</li><li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）</li></ul><h2 id="交替轮流打印数字（待完成）"><a href="#交替轮流打印数字（待完成）" class="headerlink" title="交替轮流打印数字（待完成）"></a>交替轮流打印数字（待完成）</h2><p>下面看第二个问题，两个线程交替打印1-100的奇偶数，为了减少输入所占篇幅，这里将100改成了10。基本思路上面类似，线程odd先拿到锁―—打印数字――唤醒线程even——阻塞线程odd，以此循环。</p><h2 id="并发编程的三个特性：原子性、可见性、有序性"><a href="#并发编程的三个特性：原子性、可见性、有序性" class="headerlink" title="并发编程的三个特性：原子性、可见性、有序性"></a>并发编程的三个特性：原子性、可见性、有序性</h2><p><strong>原子性</strong>：一个或多个操作要么全部执行成功，要么全部执行失败，是不可分割的</p><blockquote><p>i++操作不满足原子性，对i++反汇编（javap xx.class文件）操作，发现i++是由3步组成：（1）读取i的值。（2）对i加1。（3）赋值给i</p></blockquote><p>int i = 2;</p><p>int j = i;</p><p>i++;</p><p>i = i + 1;</p><p>第一句是基本类型赋值操作，必定是原子性操作。</p><p>第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。</p><p>第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</p><p>JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p><p><strong>可见性</strong>：当一个线程修改共享变量的值时，其他线程立马能够直到被修改了</p><p>线程1从主内存中拿到true到自己的工作内存中，并不断循环，在此期间线程2从主内存中拿到true到自己的工作内存中，并修改为false更新到主内存；但这个操作对于线程1是不可见的，线程1自己的工作内存中还是true。</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211013122255816.png" alt="image-20211013122255816"></p><p><strong>实现可见性的方法：</strong></p><p>synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</p><p>volatile:被volatile修饰的变量，一个线程修改后直接把值写入主内存，其他线程直接从主内存中读取。</p><p><strong>有序性</strong>：指的是程序按照代码的先后顺序执行</p><p> 为了性能优化，编译器和处理器可能会进行指令重排序，但是它会保证在单线程情况下，语句最终执行结果和代码按顺序执行的结果是一致的。</p><p><strong>那么它是如何保证在单线程下，语句最终执行结果和代码按顺序执行的结果是一致的呢？</strong></p><p>答：指令重排遵循了 <strong>as-if-serial 语义</strong></p><p>如果遵循了 as-if-serial语义，在单线程情况下，指令重排和按代码顺序先后执行的结果是一致的，因为处理器在进行指令重排时会考虑指令之间的<strong>数据依赖性</strong>，如果一个指令2必须用到指令1的结果，那么处理器会保证指令1会在指令2之前执行。</p><p>as-if-serial语义只能保证在单线程情况下不会发生错误，在多线程情况下可能会有安全性问题。</p><p>要解决这个问题就需要用到happens-before规则。</p><p><strong>happens-before规则是什么？</strong></p><p><a href="https://blog.csdn.net/zwx900102/article/details/106320017/">https://blog.csdn.net/zwx900102/article/details/106320017/</a></p><p>1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。      注意：这一点仅仅是JVM对程序员的保证，我们写代码时要这样做</p><p>2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序的后的执行结果与按happens-before关系执行的结果一致，Java虚拟机也会允许重排序的发生。</p><p><strong>实现有序性的方法：</strong></p><ul><li>synchronized或者Lock</li><li>volatile(禁止指令重排序)</li></ul><p><strong>相同点：</strong></p><p>happens-before关系保证了同步的多线程程序的执行结果不被改变，</p><p>as-if-serial保证了单线程内程序的执行结果不被改变。</p><p><strong>下面是例子：</strong></p><p>比如说我们看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span> ;</span><br><span class="line">i = <span class="number">1</span> ;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span> ;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p> 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生<strong>指令重排序（Instruction Reorder）。</strong></p><p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;</span><br><span class="line">a = a + <span class="number">3</span>;</span><br><span class="line">r = a * a;</span><br></pre></td></tr></table></figure><p> 　这段代码有4个语句，那么可能的一个执行顺序是：</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Center.jpeg" alt="img"></p><p>那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3</p><p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p><p>　</p><p>再看多线程的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volatile boolean inited = false;</span></span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>; <span class="comment">//语句2</span></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>详解：上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以前写过好几篇多线程相关的，不过总差点意思&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>员工管理系统的疑难点</title>
    <link href="http://example.com/2021/10/08/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/"/>
    <id>http://example.com/2021/10/08/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/</id>
    <published>2021-10-08T07:21:35.000Z</published>
    <updated>2021-10-26T07:48:00.239Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringBoot+Layui项目实战【神盾局特工管理系统】，只实现了初级的增删改查功能 </p></blockquote><a id="more"></a><p>关于项目的说明：</p><p><strong>数据库有几张表：</strong></p><p>用户表：用户登录，用户id，账号、密码</p><p>员工表：存储员工信息，员工号、部门号、姓名、年龄、生日、工资、地址</p><p>部门表：存储部门信息，部门号、部门名</p><p><strong>项目结构：</strong></p><p>springmvc后端项目中，我们常常分为为Entity层（实体类）、Dao层（数据库操作）、Controller层（控制层，返回数据给前台页面）、Service层（处理业务）。</p><p>便于维护</p><p><strong>验证码校验：</strong></p><p>easy-captcha第三方库</p><p>生成验证码图片，将验证码字符串写入到session中</p><p>验证输入的验证码是否正确，只需要取出session中原来的的验证码字符串与我们自己输入的验证码比对即可。</p><p>如果验证码输入正确，进入登录操作</p><p>错误则重新返回登录页面</p><p><strong>登录密码加密保存在数据库中</strong></p><p>登录密码不加密则是明文保存在数据库中，不安全。</p><p>简单的md5加密方式很容易破解，因此需要加密加盐，加盐就是给密码拼接一些字符串之类的。</p><p>利用spring安全框架里面提供的一些类给写入的密码加密，并保存在数据库中</p><p><strong>员工信息增删改查</strong></p><p><strong>员工信息搜索：</strong></p><p>按照员工姓名搜索，支持like语句模糊搜索</p><p>按照员工生日进行搜索，选择起始日期和终止日期，搜索生日在这两个日期之间的员工。</p><p><strong>日志：</strong></p><p>slf4j</p><hr><p>关于templates文件夹的说明</p><h3 id="templates目录"><a href="#templates目录" class="headerlink" title="templates目录"></a><strong>templates目录</strong></h3><p>template目录是用来保存动态模版文件的目录, 比如Freemarker, JSP, Thymeleaf等需要服务器动态渲染数据的文件.<br>由于页面渲染需要服务器中的数据, 所以该文件必须经过Controller控制器进行Model数据绑定后, 由服务器进行跳转. 所以直接访问是无意义的, 也访问不到.<br>模板文件夹，该文件下的页面不能通过地址栏地址直接访问，需要经过Controller类来访问，需要在application.properties中配置对应的模板引擎</p><p>原文链接：<a href="https://blog.csdn.net/qq_44866153/article/details/117184752">https://blog.csdn.net/qq_44866153/article/details/117184752</a></p><h3 id="在前端中引入themeleaf的语法："><a href="#在前端中引入themeleaf的语法：" class="headerlink" title="在前端中引入themeleaf的语法："></a><strong>在前端中引入themeleaf的语法：</strong></h3><p>注意静态资源的引入路径是从static目录的下一级开始算的</p><p><img src="/images/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/image-20211008215606377.png" alt="image-20211008215606377"></p><h3 id="密码在数据库中加密存储"><a href="#密码在数据库中加密存储" class="headerlink" title="密码在数据库中加密存储"></a>密码在数据库中加密存储</h3><p>随机盐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BCryptPasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br></pre></td></tr></table></figure><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>原理就是生成一个随机的字符串展示到页面上，并写入session中。</p><p>引入一个简单的验证码库easy-captcha。</p><p>三个功能：部署验证码，判断输入的验证码是否正确，点击验证码框能够更换验证码图片（前端实现）。</p><h3 id="增加登录拦截器（interceptor）"><a href="#增加登录拦截器（interceptor）" class="headerlink" title="增加登录拦截器（interceptor）"></a>增加登录拦截器（interceptor）</h3><p>防止没有登陆的用户也有权限直接访问后台</p><p>本案例比较简单，用户已登录就需要把信息写入进session中。所以<strong>只需要判断session里面用户信息是否存在</strong>，如果存在就不用拦截，不存在说明用户还没登录就需要拦截</p><p>需要一个拦截器和一个拦截器配置类。</p><p><strong>1.编写拦截器实现类，实现接口  HandlerInterceptor，</strong></p><p><strong>重写里面需要的三个比较常用的方法，实现自己的业务逻辑代码</strong></p><p><strong>(就是自己拦截器拦截时做什么处理)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  逻辑代码，返回<span class="keyword">false</span>进行拦截，返回<span class="keyword">true</span>放行&#125;</span><br></pre></td></tr></table></figure><p><strong>2.编写拦截器配置文件类并继承 WebMvcConfigurer类，并重写其中的方法 addInterceptors并且在主类上加上注解 @Configuration</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    InterceptorRegistration registration</span><br><span class="line">               = registry.addInterceptor(handlerInterceptor);</span><br><span class="line">    <span class="comment">// 拦截请求</span></span><br><span class="line">    registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    <span class="comment">// 放行请求</span></span><br><span class="line">    registration.excludePathPatterns(一般是静态资源和登陆请求);</span><br></pre></td></tr></table></figure><p>一个login是跳转到登录页面，一个login是登陆请求</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SpringBoot+Layui项目实战【神盾局特工管理系统】，只实现了初级的增删改查功能 &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
