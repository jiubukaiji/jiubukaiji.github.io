<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pb</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-14T13:33:29.298Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>synchronized深入理解</title>
    <link href="http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-13T01:55:05.000Z</published>
    <updated>2021-10-14T13:33:29.298Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>synchronized </p></blockquote><a id="more"></a><h2 id="线程安全问题和线程同步"><a href="#线程安全问题和线程同步" class="headerlink" title="线程安全问题和线程同步"></a>线程安全问题和线程同步</h2><p>线程安全问题：多个线程共同操作共享数据</p><p>线程同步：当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行</p><h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><ul><li> synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)</li><li>synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能） </li></ul><p><strong>具体用法：</strong></p><ul><li>修饰实例方法和静态方法</li><li>修饰代码块</li></ul><h2 id="在JVM中java对象的构成"><a href="#在JVM中java对象的构成" class="headerlink" title="在JVM中java对象的构成"></a>在JVM中java对象的构成</h2><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><p>synchronized可重入性：</p><p>synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块时，计数器的数量会1，知道计数器的数量为0，就释放这个锁。</p><p>synchronized不可中断性：</p><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会—直阻塞或等待，不可被中断。</p><p><strong>synchronized反汇编文件分析</strong>：</p><p>monitorenter：</p><p>monitorexit：</p><p>同步代码块发生异常时会自动释放锁</p><p>同步方法在反汇编后，会增加ACC-SYNCHRONIZED修饰。会隐式调用monitorenter和monitorexit，在执行同步方法前会调用monitorenter，在执行完同步方法后会调用monitorexit</p><p><strong>总结</strong>：通过javap反汇编我们看到synchronized使用编程了monitorentor和monitorexit两个指令每个锁对象都会关联一个monitor（监视器，它才是真正的锁对象），它内部有两个重要的成员变量owner会保存获得锁的线程recursions会保存线程获得锁的次数当执行到monitorexit时，recursions会1，当计数器减到0时这个线程就会释放锁</p><p>无锁状态-》偏向锁-》轻量级锁-》重量级锁      自旋锁   锁消除    </p><h2 id="JDK6后对synchronized的优化"><a href="#JDK6后对synchronized的优化" class="headerlink" title="JDK6后对synchronized的优化"></a>JDK6后对synchronized的优化</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>很多并发编程都使用了volatile关键字，主要的作用包括两点：</p><ol><li><strong>保证线程间变量的可见性。</strong></li><li><strong>禁止CPU进行指令重排序。</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;synchronized &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>学习SpringBoot疑惑记录</title>
    <link href="http://example.com/2021/10/12/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/10/12/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-10-12T01:20:10.000Z</published>
    <updated>2021-10-14T13:23:05.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前写过好几篇多线程相关的，不过总差点意思</p></blockquote><a id="more"></a><p>先列举一些基础知识：（参照面试手册路人zhang）</p><p>1.什么是进程？什么是线程（从1.两个基本单位 2.轻量级进程、包含多个线程 3.JVM内存结构共享资源方面）</p><p>进程和线程的区别</p><p>即每个进程所包含的多个线程共享进程的堆和方法区，并且具备私有的虚拟机栈、本地方法栈、程序计数器，如图所示，假设某个进程包含三个线程。</p><p>2.并发（一个时间段多个进程时间片轮转）和并行（一个时刻多个）的区别</p><p>3.多线程的优缺点（为什么使用多线程、多线程会引发什么问题）</p><p>（优点提高cpu的利用率，缺点上下文切换影响多线程执行速度、死锁、）</p><p>线程上下文切换</p><h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><p>java中线程分为两种类型：<strong>用户线程</strong>和<strong>守护线程</strong>。通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。</p><p>用户线程：平时使用到的线程均为用户线程。<br>守护线程：用来服务用户线程的线程，例如垃圾回收线程。</p><p>用户线程和守护线程的区别：</p><p>1.主线程结束后用户线程还会继续运行，JVM存活；</p><p>2.如果没有用户线程，都是守护线程，那么JVM结束，进而守护线程也会退出</p><p><strong>总结：</strong></p><ul><li>java中的线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li><li>程序中的所有的用户线程结束之后，不管守护线程处于什么状态，java虚拟机都会自动退出</li><li>调用线程的实例方法setDaemon()来设置线程是否是守护线程（true为守护线程，false为用户线程）</li><li>setDaemon()方法必须在线程的start()方法之前调用，在后面调用会报异常，并且不起效</li><li>线程的daemon默认值和其父线程一样</li></ul><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p>六个状态：新建(new)、运行(runnable)、阻塞(block)、等待(waiting)、超时等待(time_waiting)、终止(terminated)。</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110744753.png" alt="image-20211012110744753"></p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110853349.png" alt="image-20211012110853349"></p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110906205.png" alt="image-20211012110906205"></p><h2 id="创建线程有哪几种方法？"><a href="#创建线程有哪几种方法？" class="headerlink" title="创建线程有哪几种方法？"></a>创建线程有哪几种方法？</h2><p>创建多线程常见的四种方法：</p><ul><li>继承Thread类创建线程</li><li>实现Runnable接口创建线程</li><li>使用callable和Future创建线程</li><li>使用线程池创建线程</li></ul><p><strong>继承Thread类创建线程</strong>，首先继承Thread类，重写run（）方法，在主函数中调用子类实实例的start（）方法。</p><p><strong>实现Runnable接口创建线程</strong>：1.实现Runnable接口，重写run（）方法；2.将这个类的实例对象作为参数创建Thread对象3.调用Thread对象的start（）方法。</p><p><strong>使用Callable和Future创建线程</strong>：1.实现Callable接口，重写call（）方法<br>2.将这个类的实例对象作为参数创建FutureTask对象。3.以FutureTask对象作为参数创建Thread对象。4.调用Thread对象的start（）方法。</p><p><strong>使用线程池创建线程</strong></p><h2 id="Runnable和callable的区别"><a href="#Runnable和callable的区别" class="headerlink" title="Runnable和callable的区别"></a>Runnable和callable的区别</h2><p>相同点：两者都需要调用Thread.start()启动线程；</p><p>不同点：是否有返回值、是否能抛出异常</p><p>1、两者最大的不同点是：实现Callable接口的任务线程有返回值；Runnable接口的任务线程不能返回结果；<br>2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的不可以</p><h2 id="线程的run（）和start（）有什么区别？"><a href="#线程的run（）和start（）有什么区别？" class="headerlink" title="线程的run（）和start（）有什么区别？"></a>线程的run（）和start（）有什么区别？</h2><p>1.线程中的具体任务的执行是通过run（）来实现的，而线程的启动是通过start（）方法执行的。<br>2.run（）方法可以重复调用，start（）方法只能调用一次</p><h2 id="为什么调用start（）方法时会执行run（）方法，而不直接执行run（）方法？"><a href="#为什么调用start（）方法时会执行run（）方法，而不直接执行run（）方法？" class="headerlink" title="为什么调用start（）方法时会执行run（）方法，而不直接执行run（）方法？"></a>为什么调用start（）方法时会执行run（）方法，而不直接执行run（）方法？</h2><p>总结：调用start（）方法方可启动一个线程，并使线程进入就绪状态，等分配到时间片会自动调用其中的run（）方法；如果我们直接执行run（）方法时，只会把它看成是main（）线程中一个普通方法去执行，并不会在其他的线程中执行，所以不是多线程。</p><h2 id="线程调度的一些方法"><a href="#线程调度的一些方法" class="headerlink" title="线程调度的一些方法"></a>线程调度的一些方法</h2><ul><li><p>wait():</p></li><li><p>sleep():</p></li><li><p>join():执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队列，直到join结束或中断线程B才开始进入阻塞队列。</p><p>将join理解为插队，比如说A.join() ，那么在当前运行的线程进入阻塞队列，A插入进去。</p><p><a href="https://blog.csdn.net/u013425438/article/details/80205693">https://blog.csdn.net/u013425438/article/details/80205693</a>  对join方法的理解</p></li><li><p>yield():</p></li><li><p>notify():</p></li></ul><h2 id="sleep-方法和wait-方法的区别"><a href="#sleep-方法和wait-方法的区别" class="headerlink" title="sleep()方法和wait()方法的区别"></a>sleep()方法和wait()方法的区别</h2><p>两者都可以使当前线程进入阻塞状态</p><p>两者最主要的区别在于：sleep()方法没有释放锁，而wait()方法释放了锁。</p><ul><li><p>sleep是Thread类的方法，而wait是Object类的方法；</p></li><li><p>sleep()可以在很多场景下使用，wait()只能在同步代码块和同步方法中使用</p></li><li><p>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。</p></li><li><p>sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</p></li></ul><h2 id="sleep-和wait-方法的区别"><a href="#sleep-和wait-方法的区别" class="headerlink" title="sleep()和wait()方法的区别"></a>sleep()和wait()方法的区别</h2><p>调用yield方法会让当前线程交出CPU权限</p><p>它跟sleep方法类似，同样不会释放锁。</p><ul><li>但是yield不能控制具体交出CPU的时间</li><li>yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</li><li>yield方法不会让线程进入阻塞状态，而是让线程重回就绪状态</li></ul><h2 id="交替轮流打印数字（待完成）"><a href="#交替轮流打印数字（待完成）" class="headerlink" title="交替轮流打印数字（待完成）"></a>交替轮流打印数字（待完成）</h2><p>下面看第二个问题，两个线程交替打印1-100的奇偶数，为了减少输入所占篇幅，这里将100改成了10。基本思路上面类似，线程odd先拿到锁―—打印数字――唤醒线程even——阻塞线程odd，以此循环。</p><p><strong>原子性</strong>：一个或多个操作要么全部执行成功，要么全部执行失败，是不可分割的</p><blockquote><p>i++操作不满足原子性，对i++反汇编（javap xx.class文件）操作，发现i++是由3步组成：（1）读取i的值。（2）对i加1。（3）赋值给i</p></blockquote><p>int i = 2;</p><p>int j = i;</p><p>i++;</p><p>i = i + 1;</p><p>第一句是基本类型赋值操作，必定是原子性操作。</p><p>第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。</p><p>第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</p><p>JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p><p><strong>可见性</strong>：当一个线程修改共享变量的值时，其他线程立马能够直到被修改了</p><p>线程1从主内存中拿到true到自己的工作内存中，并不断循环，在此期间线程2从主内存中拿到true到自己的工作内存中，并修改为false更新到主内存；但这个操作对于线程1是不可见的，线程1自己的工作内存中还是true。</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211013122255816.png" alt="image-20211013122255816"></p><p><strong>实现可见性的方法：</strong></p><p>synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</p><p>volatile:被volatile修饰的变量，一个线程修改后直接把值写入主内存，其他线程直接从主内存中读取。</p><p><strong>有序性</strong>：指的是程序按照代码的先后顺序执行</p><p> 为了性能优化，编译器和处理器可能会进行指令重排序，有时候会改变程序中语句的先后顺序，但是它会保证在单线程情况下，语句最终执行结果和代码按顺序执行的结果是一致的。</p><p>那么它是如何保证在单线程下，语句最终执行结果和代码按顺序执行的结果是一致的呢？</p><p>那么就要提到as-if-serial语义了</p><blockquote><p><strong>as-if-serial语义</strong>的意思是：不管怎么进行指令重排序，单线程内程序的执行结果不能被改变。编译器，处理器进行指令重排序都必须要遵守as-if-serial语义规则。</p><p>处理器在进行重排序时是会考虑指令之间的<strong>数据依赖性</strong>，如果一个指令2必须用到1的结果，那么处理器会保证指令1会在指令2之前执行。</p></blockquote><p>比如说我们看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span> ;</span><br><span class="line">i = <span class="number">1</span> ;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span> ;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p> 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生<strong>指令重排序（Instruction Reorder）。</strong></p><p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;</span><br><span class="line">a = a + <span class="number">3</span>;</span><br><span class="line">r = a * a;</span><br></pre></td></tr></table></figure><p> 　这段代码有4个语句，那么可能的一个执行顺序是：</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Center.jpeg" alt="img"></p><p>那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3</p><p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p><p>　</p><p>再看多线程的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volatile boolean inited = false;</span></span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>; <span class="comment">//语句2</span></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>详解：上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><p><strong>实现有序性的方法：</strong></p><ul><li><p>synchronized或者Lock</p></li><li><p>volatile(禁止指令重排序)</p></li></ul><p><strong>as-if-serial语义是什么？</strong></p><p><strong>happens-before规则是什么？</strong></p><p><a href="https://blog.csdn.net/zwx900102/article/details/106320017/">https://blog.csdn.net/zwx900102/article/details/106320017/</a></p><p>1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。注意：这一点仅仅是JMM对程序员的保证</p><p>2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以前写过好几篇多线程相关的，不过总差点意思&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>员工管理系统的疑难点</title>
    <link href="http://example.com/2021/10/08/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/"/>
    <id>http://example.com/2021/10/08/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/</id>
    <published>2021-10-08T07:21:35.000Z</published>
    <updated>2021-10-09T02:53:30.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringBoot+Layui项目实战【神盾局特工管理系统】，只实现了初级的增删改查功能</p></blockquote><a id="more"></a><p>关于templates文件夹的说明</p><h3 id="templates目录"><a href="#templates目录" class="headerlink" title="templates目录"></a><strong>templates目录</strong></h3><p>template目录是用来保存动态模版文件的目录, 比如Freemarker, JSP, Thymeleaf等需要服务器动态渲染数据的文件.<br>由于页面渲染需要服务器中的数据, 所以该文件必须经过Controller控制器进行Model数据绑定后, 由服务器进行跳转. 所以直接访问是无意义的, 也访问不到.<br>模板文件夹，该文件下的页面不能通过地址栏地址直接访问，需要经过Controller类来访问，需要在application.properties中配置对应的模板引擎</p><p>原文链接：<a href="https://blog.csdn.net/qq_44866153/article/details/117184752">https://blog.csdn.net/qq_44866153/article/details/117184752</a></p><h3 id="在前端中引入themeleaf的语法："><a href="#在前端中引入themeleaf的语法：" class="headerlink" title="在前端中引入themeleaf的语法："></a><strong>在前端中引入themeleaf的语法：</strong></h3><p>注意静态资源的引入路径是从static目录的下一级开始算的</p><p><img src="/images/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/image-20211008215606377.png" alt="image-20211008215606377"></p><h3 id="密码在数据库中加密存储"><a href="#密码在数据库中加密存储" class="headerlink" title="密码在数据库中加密存储"></a>密码在数据库中加密存储</h3><p>随机盐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BCryptPasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br></pre></td></tr></table></figure><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>原理就是生成一个随机的字符串展示到页面上，并写入session中。</p><p>引入一个简单的验证码库easy-captcha。</p><p>三个功能：部署验证码，判断输入的验证码是否正确，点击验证码框能够更换验证码图片（前端实现）。</p><h3 id="增加登录拦截器（interceptor）"><a href="#增加登录拦截器（interceptor）" class="headerlink" title="增加登录拦截器（interceptor）"></a>增加登录拦截器（interceptor）</h3><p>防止没有登陆的用户也有权限直接访问后台</p><p>本案例比较简单，只需要判断session里面用户信息是否存在</p><p>需要一个拦截器和一个拦截器配置类</p><p><strong>1.编写拦截器实现类，实现接口  HandlerInterceptor，</strong></p><p><strong>重写里面需要的三个比较常用的方法，实现自己的业务逻辑代码</strong></p><p><strong>(就是自己拦截器拦截时做什么处理)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  逻辑代码，返回<span class="keyword">false</span>进行拦截，返回<span class="keyword">true</span>放行&#125;</span><br></pre></td></tr></table></figure><p><strong>2.编写拦截器配置文件类并继承 WebMvcConfigurer类，并重写其中的方法 addInterceptors并且在主类上加上注解 @Configuration</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    InterceptorRegistration registration</span><br><span class="line">               = registry.addInterceptor(handlerInterceptor);</span><br><span class="line">    <span class="comment">// 拦截请求</span></span><br><span class="line">    registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    <span class="comment">// 放行请求</span></span><br><span class="line">    registration.excludePathPatterns(一般是静态资源和登陆请求);</span><br></pre></td></tr></table></figure><p>一个login是跳转到登录页面，一个login是登陆请求</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SpringBoot+Layui项目实战【神盾局特工管理系统】，只实现了初级的增删改查功能&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>学习SpringBoot疑惑记录</title>
    <link href="http://example.com/2021/10/03/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/10/03/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/</id>
    <published>2021-10-03T00:30:20.000Z</published>
    <updated>2021-10-10T09:30:04.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕叽咕叽</p></blockquote><a id="more"></a><p>mapper   ORM框架    </p><p>IOC容器控制反转      AOP面向切片编程</p><p>ORM</p><p><strong>spring有哪些模块？</strong></p><p>截止到目前Spring 框架已集成了 20 多个模块 。 这些模块主要被分如下图所示的核心容器 、 数据访问 / 集成 、Web、AOP （面向切面编程） 、 工具 、 消息和测试模块 。</p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211010164940116.png" style="zoom: 67%;" /><p><strong>spring框架用了哪些设计模式？</strong></p><blockquote><p>了解一下设计模式</p></blockquote><p><strong>对IOC和AOP的理解：</strong></p><p><strong>IOC：</strong></p><p>IOC是inverse of control <strong>控制反转</strong>的缩写，是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理，目的是降低类与类之间的耦合度。loc容器是Spring用来实现loC的载体，loc容器实际上就是个Map（key，value），Map中存放的是各种对象。</p><p>我们用lOC容器完成对象的注入。loC容器的本质是一个”生产Bean的工厂”，当我们的bean注册到容器中后，在程序的运行过程中，我们可以直接向loC容器索取我们想要的bean实例，而不是使用传统的new 这种方式。</p><p>控制反转是目的，依赖注入是实现控制反转的手段。</p><p>控制反转是为了降低类与类之间的耦合度。</p><p><strong>AOP：</strong></p><p>AOP（Aspect-Oriented Programming：<strong>面向切面编程</strong>）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，即插即用。<br>Spring AOP就是基于<strong>动态代理</strong>的，</p><blockquote><p>什么是动态代理？</p><p>要搞清楚静态代理和动态代理的区别</p></blockquote><p><strong>DI：</strong></p><p>DI是<strong>依赖注入</strong>的意思。</p><ul><li>构造函数注入</li><li> setter 注入 </li><li>接口注入 </li></ul><p>在 Spring Framework 中，我们通常使用构造函数和 setter 注入。</p><p><strong>DAO层、Service层、Controller层的区别：</strong></p><p>DAO层：<br>DAO层叫数据访问层，全称为data access object，属于一种比较底层，比较基础的操作，具体到对于某个表的增删改查，也就是说<strong>某个DAO一定是和数据库的某一张表一一对应的</strong>，其中封装了增删改查基本操作，建议<strong>DAO只做原子操作，增删改查。</strong></p><p>Service层：<br>Service层叫服务层，被称为服务，粗略的理解就是<strong>对一个或多个DAO进行的再次封装</strong>，封装成一个服务，所以这里也就不会是一个原子操作了，<strong>需要事物控制。</strong></p><p>Controller层：<br>Controller负责<strong>请求转发，接受页面过来的参数，传给Service处理，接到返回值，再传给页面。</strong></p><p>总结：<br>个人理解DAO面向表，Service面向业务。后端开发时先数据库设计出所有表，然后对每一张表设计出DAO层，然后根据具体的业务逻辑进一步封装DAO层成一个Service层，对外提供成一个服务。</p><p>反射+工厂模式</p><p>springbean作用域默认是单例的，即每次从容器中获得的都是同一个对象</p><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211003154931318.png"></p><p>就是一般开发下，有哪些包结构组成，应该是关于MVC方面的架构</p><p><strong>Spring帮助我们管理Bean分为两个部分，一个是注册Bean，一个装配Bean。</strong></p><p>@Autowired：自动装配bean</p><blockquote><p> @Autowired注解就相当于从Spring容器中通过类型，实例化了当前对象，可以直接调用它的方法。</p><p>通过@Autowired注解，如果在容器中有对应的bean，就可以通过@Autowired自动装载，也就是赋值。装载之后自动的按照类型在spring容器中查找相同类型，然后为该字段其注入那个类型的bean实例。</p><p>其实就是一种依赖注入的方式，此方式必须确保加注解的类在spring中有对应的bean（怎样加进去不管），并且字段的类型需要在spring容器中有相同类型的bean，才能创建bean实例，为其注入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于执行了实例化 private UserService userService = new UserServiceImpl();</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p><strong>将⼀个类声明为Spring的 bean 的注解有哪些?（注册bean）</strong></p><p>@Component：</p><p>@Controller：</p><p>@Repository：</p><p>@Service：</p><p>简而言之，两个作用：</p><ul><li>说明这个类是一个spring IOC容器管理的类，之后可以通过@Autowired 实例化该类</li><li>当然也有语义化的作用，即代表该类是充当Controller的作用</li></ul><blockquote><p>Spring的一个核心功能是IOC，就是将Bean初始化加载到容器中， Bean加载到容器中可以使用 Spring注解方式或者 Spring XML配置方式。(通过注解将java中的一些类，加载到容器中) </p><p>在annotaion配置注解中用@Component来表示一个通用注释用于说明一个类是一个spring容器管理的类。即就是该类已经拉入到spring的管理中了。而@Controller,@Service, @Repository是@Component的细化，这三个注解比@Component带有更多的语义，它们分别对应了控制层、服务层、持久层的类。</p><ul><li><code>@Repository</code>：持久层，用于标注数据访问组件，即DAO组件。</li><li><code>@Service</code>：业务层，用于标注业务逻辑层主键。</li><li><code>@Controller</code>：控制层，用于标注控制层组件。</li><li><code>@Component</code>：当你不确定是属于哪一层的时候使用。</li></ul><p>之所以区分开几种类型，一是spring想在以后的版本中为它们添加特殊技能，二是这种分层的做法使web架构更清晰，易读性与维护性更好。</p></blockquote><p><strong>@component和@bean的区别和联系？</strong></p><p>这两个注解都是用来注册bean到spring容器中。</p><ul><li>@Component 注解作用于类，而 @Bean 注解作用于方法上</li><li>@Component 通常是通过类路径扫描来自动装配到Spring容器中。<br>@Bean注解通常与@Configuration配合，在配置类中的方法中返回bean对象</li><li>如果想要将第三方库中的组件装配到你的应用中，使用@component是不能实现自动装配的，可以使用@bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;SJL01&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那为什么有了@Component,还需要@Bean呢？</strong><br>如果你想要将第三方库中的组件装配到你的应用中，在这种情况下，@Component不能实现自动装配的，因此就不能使用自动化装配的方案了，但是我们可以使用@Bean,当然也可以使用XML配置。</p><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211005225450261.png" alt="image-20211005225450261"></p><p>@Transactional：</p><blockquote><p>与springboot事务管理有关系，暂时看不懂</p></blockquote><p>@ResponseBody：</p><blockquote><p>使用在控制层（controller）的方法上。</p><p>@RestController = @ResponseBody + @Controller</p><p>@ResponseBody的作用其实是将java对象转为json格式的数据。</p><p>json格式便于数据交互</p></blockquote><p>@Qualifier</p><blockquote><p>当一个接口有多个实现的时候，为了指名具体调用哪个类的实现;通常与@Autowired搭配使用</p></blockquote><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211009093317850.png" alt="image-20211009093317850"></p><p>下面三个的区别：用错了程序会报错</p><p>@GetMapping：控制跳转网页映射</p><p>@RequestMapping：</p><p>@PostMapping:</p><blockquote><p> Spring4.3中引进了@GetMapping、@PostMapping 来帮助简化常用的HTTP方法的映射 并更好地表达被注解方法的语义</p><p>@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。</p><p>@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。</p></blockquote><blockquote><p>什么时候用post 什么时候用 get？</p><p>1.当方法中的参数为@RequestParam、@PathVaiable、无参的情况下使用@GetMapping</p><p>2.当方法中的参数为@RequestBody、多参、对象参数的情况下使用@PostMapping</p><p>没看懂，但是暂且这样先用着吧</p></blockquote><p>@RequestParam</p><blockquote><ul><li>@RequestParam默认要求必须传参，可以通过设置<code>required = false</code>来关闭</li><li>如果为@RequestParam设置参数名，以他为准，不设置的话默认为其后的类型参数名</li><li></li></ul></blockquote><p><strong>不加的时候</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/request&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">test01</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">     String returnValue = <span class="string">&quot;返回的字符串为：&quot;</span>+name;</span><br><span class="line">     <span class="keyword">return</span> returnValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>请求端可以不带参数，比如：localhost:8080/request</p><p><strong>加上@RequestParam的时候</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/request&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test01</span><span class="params">(<span class="meta">@RequestParam(value = &quot;haha&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">    String returnValue = <span class="string">&quot;返回的字符串为：&quot;</span>+name;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求端必须带参数(当然我们可以设置false来关闭)，并且以设置的value值为准，如: localhost:8080/request?haha=www</p><p>@SpringBootApplication :放在springboot的启动程序上，标明这是一个启动类</p><p><strong>对spring bean生命周期的理解：</strong></p><p>实例化对象bean-》设置对象属性-》处理Aware接口-》BeanPostProcessor前置初始化方法-》调用bean自身的init方法-》调用BeanPostProcess的后置初始化方法-》使用bean-》销毁bean</p><p><strong>对SpringMVC的理解：</strong></p><p>弄清application.yml中mybatis两个属性的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mybatis配置</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;com&#x2F;baizhi&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.baizhi.ems_thymeleaf.entity</span><br></pre></td></tr></table></figure><p>mybatis传递多个参数需要绑定？</p><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211005213034158.png" alt="image-20211005213034158"></p><p>这里面的Model model 是什么意思？</p><p>开发功能的顺序：  entity包创建实体类  -》dao包创建持久层接口 -》mapper包中写sql语句 -》service包中写业务实现（一个service接口和service接口实现类） - 》controller包中写页面跳转</p><hr><p>mybatis：<br>mapper-locations：classpath:mybatis/mapper/<em>.xml               <strong>//对应每个实体类的mapper.xml文件的的位置</strong><br>type-aliases-package：cn.qqcn.</em>.entity               <strong>//存放实体类的包名</strong><br>configuration：<br>map-underscore-to-camel-case：true#驼峰转换    </p><p>数据库里面的字段用下划线，实体类用驼峰，那么之后怎么对应起来</p><p>HttpServletRequest  </p><p>HttpServletResponse    </p><blockquote><p>客户端浏览器发出的请求被封装成为一个HttpServletRequest对象。所有的信息包括请求的地址，请求的参数，提交的数据，上传的文件客户端的ip甚至客户端操作系统都包含在其内。</p><p>HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕叽咕叽&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>日常实习如何准备mark</title>
    <link href="http://example.com/2021/10/02/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87mark/"/>
    <id>http://example.com/2021/10/02/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87mark/</id>
    <published>2021-10-02T07:44:20.000Z</published>
    <updated>2021-10-02T08:55:17.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到的帖子先留下来</p></blockquote><a id="more"></a><p>没有项目可以做个简单的springboot项目练手；多刷题,不刷题阿里笔试0ac很正常<img src="/images/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87mark/1.gif" alt="ema1">；多看书多实践;多做比赛，我个人面试的时候被问到项目的时候比较少，但是每轮面试都能聊十几分钟做的比赛，确实有些比赛比通常crud的项目有东西。</p><p>下面上两个大佬的经验分享</p><p>先说学习方法(How)：所有的学习不外乎就是学习+实践这两个过程，从实践中学习，在实践中验证学到的东西。所谓的学习就是比较+思考，比较就是看别人怎么做的，看别人比自己强在哪里，思考包括不限于怎么利用别人的优点去改边自己的缺点，更深一层是去思考别人为什么比自己强，在深一层是思考自身：目前在做的事对你的终极目标是不是有意义，自己有没有在逃避一些事情而不敢直面自己的目标。你通过比较加思考学到了一些事情之后，下一步就是去实践，在实践中去熟练对的东西，去验证排除错的东西。<br>再聊学习动机(Why)：要有清晰而长远的目标，坚定的走下去，年轻时不要追求广，要追求深。<br>最后说学习内容（What）：对于Java研发来说，成长最快的方式有三种：项目，比赛，源码。<br>聊完上面这些东西，在具体事务上的建议就很清楚了：<br>0、确定方向；<br>1、学习：感兴趣领域内的书、公开课、比赛经验、有名的框架的源码；<br>2、归纳思考：整理知识体系，写博客，实习过程中的项目总结，看看周围最牛的人在做什么；<br>3、实践：实习+比赛（天池、华为云、TiDB）<br>在循环的学习-&gt;归纳-&gt;实践中提升自己。</p><hr><p>title: 阿里中间件大佬2020/04/12号面试经验分享<br>-–</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>阿里中间件团队博客</p><h4 id="扎实的计算机基础"><a href="#扎实的计算机基础" class="headerlink" title="扎实的计算机基础"></a>扎实的计算机基础</h4><p>- 计算机组成原理<br>- 计算机网络<br>- 操作系统<br>- 基本数据结构与算法<br>- 数据库<br>- JAVA基础<br>  熟悉基本语法与常用库<br>  学习源码、io、util、current、collection<br>  了解常用框架，spring、netty、dubbo等</p><h4 id="提高编程能力、编程比赛"><a href="#提高编程能力、编程比赛" class="headerlink" title="提高编程能力、编程比赛"></a>提高编程能力、编程比赛</h4><p>- 阿里巴巴天池比赛<br>- 华为软件精英挑战赛<br>- 中兴捧月挑战赛</p><h4 id="积极参加项目实战"><a href="#积极参加项目实战" class="headerlink" title="积极参加项目实战"></a>积极参加项目实战</h4><p>对平时做的项目多思考，对使用的技术深入了了解，多方比较</p><h4 id="笔试准备"><a href="#笔试准备" class="headerlink" title="笔试准备"></a>笔试准备</h4><p>- LeetCode<br>- 《编程珠玑》<br>- 《算法》</p><h4 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h4><p>- 记笔记<br>- 厚积薄发<br>单背面经有些不够<br>- 对不同的公司专门准备</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看到的帖子先留下来&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>秋招帖子markmark</title>
    <link href="http://example.com/2021/09/24/%E5%8C%97%E9%82%AE%E4%BA%BA%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90mark/"/>
    <id>http://example.com/2021/09/24/%E5%8C%97%E9%82%AE%E4%BA%BA%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90mark/</id>
    <published>2021-09-24T04:25:30.000Z</published>
    <updated>2021-09-27T11:32:04.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到的帖子先留下来</p></blockquote><a id="more"></a><h1 id="秋招Tips"><a href="#秋招Tips" class="headerlink" title="秋招Tips"></a>秋招Tips</h1><h3 id="0-卷首语"><a href="#0-卷首语" class="headerlink" title="0. 卷首语"></a>0. 卷首语</h3><p>秋招算是个人成长的一大转折，跌跌撞撞，终于在近期正式结束，由于受惠于诸多前辈的经验，打算写一下没啥人看的经验。攒攒人品，求个大包。</p><p>本人应届硕士，15级北邮本，计院；大四某无人驾驶公司算法实习 + 暑期阿里云弹性计算实习(偏底层）</p><p>收获的意向书：阿里云tan性计算，腾讯guang子，百度推广搜某架构，字节dou音电商，美团到家，快手shang业化，拼多多，虾皮，京东，网易互娱；其他公司offer够了就没面了，如微软，hulu…</p><p><strong>码字不易，请别乱传，请别外传</strong>。</p><h3 id="1-三维"><a href="#1-三维" class="headerlink" title="1. 三维"></a>1. 三维</h3><p>和保研差不多，秋招最重要的也是你的三维，好学校科班出身，基础知识牢固，丰富的大厂实习经验，SSSSP赢家就是你</p><ol><li>学历/专业 211+， 计科/软工/网工/通信…</li><li>基本知识：语言基础(C++, Go, Java)，算法，TCP/IP, Os，Redis，消息队列, 分布式(CAP，BASE，Xcc， Paxos，Raft…)</li><li>实习/项目：大厂相关实习，知名开源项目…<ol><li>个人觉得实习更重要，学历没法补，基本知识可以突击</li><li>找一个放实习的老板；个人最大的吃亏在于只有2段比较偏的实习，一个算法，一个太底层</li><li>相关实习，某些实习面试官可能不太care or 体现不出能力</li></ol></li></ol><h3 id="2-复习-amp-相关题目"><a href="#2-复习-amp-相关题目" class="headerlink" title="2. 复习&amp;相关题目"></a>2. 复习&amp;相关题目</h3><p>本人由于算法转开发，大多复习的是后台/服务器开发相关的知识；</p><p>大部分公司会在八股的基础上深入一下，但不会深入太多，很多我觉得难的都不会问….</p><p>建议不要只刷面经，系统的看一下/复习一下会更好</p><p>以下复习按照我理解的优先级进行排序；</p><ol><li><p>TCP / IP：复习使用的书籍《TCP/IP详解》，各种blog</p><ol><li>TCP，IP，UDP基本头部</li><li>TCP为啥三次握手/四次挥手；对应的状态迁移</li><li>TCP的各种状态位，什么时候有用</li><li>TCP的3种定时器，TCP的长肥管道问题</li><li>半连接，全连接</li><li>Time wait; 为啥Time wait；大量短连接怎么处理</li><li>TCP vs UDP</li><li>HTTP协议基本，以及1.0/1.1/2.0/3.0对比</li><li>HTTPS，和Http对比；握手；数字证书；对称加密非对称加密</li><li>DNS，递归/迭代查询；什么时候UDP，什么时候TCP</li><li>ARP，arp广播，arp代理</li><li>ICMP (比较偏)，ping，traceroute</li><li>socket编程客户端/服务端的几个函数，以及对应参数</li><li>IO多路复用select，poll，epoll区别/优劣，epoll的两种模式<ol><li>select为啥有个1024的限制，32*i32</li><li>epoll线程安全</li><li>reactor vs proactor</li></ol></li></ol></li><li><p>OS: 复习使用的书籍《现代操作系统》</p><ol><li>虚拟内存(必问)：MMU/TLB，多级页表，内存分配（slab，伙伴)</li><li>进程&amp;线程基本概念，PCB包含什么，进程内存模型，TCB</li><li>进程间通信<ol><li>基本概念，原理</li><li>通信效率，是否设计系统调用</li></ol></li><li>死锁，条件，检测/恢复/预防</li><li>同步，原子操作，CAS&amp;FAA，互斥锁，条件变量，RCU</li><li>底层IO模型，阻塞，非阻塞，信号，多路复用，异步</li><li>多线程vs多进程；同一进程线程切换，不同进程线程切换；</li><li>协程vs线程</li><li>inode，软连接、硬链接，文件描述符</li><li>零拷贝</li></ol></li><li><p>数据库 复习使用的课程《mysql实战45讲》+ blog</p><ol><li>mysql架构，server层 + 引擎层；<ol><li>连接器，查询缓存，分析器，优化器，执行器</li><li>两种存储引擎的对比</li></ol></li><li>redo log vs binlog vs undo log，这块可以问得可深了…<ol><li>redolog为啥crash safe, binlog为啥不是</li><li>如何恢复数据</li><li>何时刷新log/数据</li></ol></li><li>索引<ol><li>B+树 vs B树</li><li>唯一索引vs普通索引</li><li>聚簇 vs 非聚簇</li><li>最左前缀匹配，给你个sql让你分析</li><li>回表/覆盖索引</li><li>索引设计</li><li>explain</li></ol></li><li>事务，隔离级别（默认），脏读/不可重复读/幻读</li><li>MVCC，什么时候生成read view；如何判断哪些事务可见</li><li>锁（加锁才能实际解决幻读）<ol><li>两阶段锁</li><li>record lock，gap lock， next key lock</li></ol></li><li>数据库优化，读写分离，主从，分库分表等等</li><li>范式</li><li>手写嵌套查询<ol><li>如何设计索引</li><li>执行顺序</li></ol></li><li>给你个sql，让你分析如何加索引，使用了什么索引</li></ol></li><li><p>语言基础 (C++, Go)</p></li></ol><p>   <a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p><p>   + C++ primer plus</p><ol><li>几种时期多态，虚函数表(最基本, 多重继承)</li><li>智能指针 &amp; 手写最简单的智能指针</li><li>C++的内存分布/ 内存对齐</li><li>static / const</li><li>C++11，右值，转移语义，lambda等等</li><li>…</li><li>Go语言 GMP模型</li><li>线程池，内存池 (比较偏)</li></ol><ol start="5"><li><p>Redis</p><ol><li>基本数据结构底层，大数据量和小数据量情况下不同的数据类型；<ol><li>sds</li><li>跳表</li><li>ziplist，有啥好处</li><li>hash，渐进式hash，rehash</li><li>intset，提升</li></ol></li><li>为啥快？基于内存，多路复用，单线程事件分配器</li><li>大key问题；慢日志</li><li>缓存穿透，击穿，雪崩；如何处理</li><li>redis分布式锁，单机版&amp;分布式版</li><li>redis持久化，AOF vs RDB</li><li>redis主从流程</li></ol></li><li><p>消息队列：没复习，但经常会问</p></li><li><p>数据结构 《STL源码剖析》+ blog</p><ol><li>vector底层<ol><li>扩容</li><li>迭代器失效</li></ol></li><li>hashmap底层</li><li>树，**二叉树，avl，红黑树，B+树，B树，LSM树<ol><li>avl vs 红黑树</li><li>B+树 vs B树</li></ol></li></ol></li><li><p>设计模式 《大话设计模式》</p><ol><li>手写单例 (必问)</li><li>简单工厂，工厂方法…</li></ol></li><li><p>linux 常用指令</p><ol><li>grep</li><li>sed</li><li>find</li><li>iostat/netstat</li><li>top</li></ol></li><li><p>分布式</p><ol><li>CAP， BASE</li><li>分布式事务，两阶段，三阶段</li><li>Raft基本流程，选主，日志复制，脑裂之后流程</li><li>一致性hash</li></ol></li></ol><h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3. 算法"></a>3. 算法</h3><p>除了字节和外企，其他公司的面试题都很简单….也不用特别担心；建议面试前看看公司最喜欢考的题</p><ul><li>链表题<ul><li>翻转，每k个翻转，字节最爱…</li><li>环的入口</li><li>删除重复节点</li><li>链表快排/归并排序</li></ul></li><li>动规题，动规题理解了背住常见的几个模板就行；一般最多2维dp<ul><li>最长公共子串</li><li>最长上升子序列</li><li>换零钱，变种考了很多次</li><li>01背包</li><li>回文子串，及其变种比如区间[i, j]符合某某条件</li><li>矩阵连乘，加括号</li><li>编辑距离</li></ul></li><li>二叉树前中后，递归/非递归遍历；一般比较简单<ul><li>非递归遍历</li><li>前序中序重建</li><li>最大路径和</li><li>公共祖先</li></ul></li><li>排序，快排变种<ul><li>第K大/小</li><li>两个数组第k大</li></ul></li><li>单调栈，接雨水</li><li>位运算，子网掩码，只出现一次的数…</li><li>广度搜索 + 记忆化数组，求最短路径</li><li>dfs，暴力解法，骗分</li><li>排序算法，n2, nlogn, n</li><li>排列<ul><li>全排列，无重复</li><li>下一个排列</li><li>洗牌算法</li></ul></li></ul><h3 id="4-项目"><a href="#4-项目" class="headerlink" title="4. 项目"></a>4. 项目</h3><p>尽量提前实习，去有含金量的大厂，比如wxg，阿里云，抖音等等；</p><p>尽量实习方向和就业方向相同；</p><p>没项目经验的可以看看下面这个</p><ul><li>C++ web server <a href="https://github.com/linyacool/WebServer">https://github.com/linyacool/WebServer</a></li></ul><p>项目常常问</p><ul><li><strong>请使用star法则介绍你的项目</strong></li><li>项目实施的一些详细数据</li><li>为什么这么设计，你在其中承担的角色</li><li>如何保证/增加crash-safe的能力</li><li>考虑以后的优化</li><li>你的收获</li></ul><h3 id="4-面试"><a href="#4-面试" class="headerlink" title="4. 面试"></a>4. 面试</h3><p>不要紧张，不要紧张，不要紧张，此处不留爷自有留爷处；</p><p>大部分公司面试官都是很nice的，不要被某些面试官的黑脸搞崩心态，比如某节面试官。</p><ol><li><p>找一个安静，整洁的环境；好的环境会让双方都体验更好，开始我在宿舍面就体验不咋样，后来去学校的一些小房间面，状态感觉就不一样</p></li><li><p>开始面试前，让自己放松下，不要太紧张，不要再去拼命复习，没用的反而会让自己紧张</p></li><li><p>面试过程尽量保持自己的语调，确保面试官能听清楚，不会太快太急</p></li><li><p><strong>一定要结构化的回答问题</strong>，面试官听你的回答提炼答案也很累</p><ol><li>为啥有xx；相同点是: 第一点，第二点，第三点；不同点是：第一点，第二点，第三点；最后总结一下</li></ol></li><li><p>遇到不会的题，尽量回答一些有关系的点，如果实在不会，直接说不会，不要绕来绕去</p></li><li><p>遇到会的题，在答完基础的情况下，可以加深一下，比如</p><ol><li><p>面试官问你虚拟内存是啥；</p><p>虚拟内存的是啥…; 段式，页式；单级页表，多级页表；MMU，TLB加速翻译过程；内存换入换出等等</p></li><li><p>MYSQL的锁</p><p>表锁+行锁；行锁基于索引，record/gap/next-key；意向锁</p></li></ol></li><li><p>除了部分公司某些面试官，比如某节，其他公司的面试官会引导你去回答，也不会缠着你不会的；</p></li><li><p>不要在面试官面前显示的很卑微，此处不留爷自有留爷处</p></li><li><p>面试完了就不要患得患失了，准备下一场比啥都重要</p></li></ol><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ol><li>尽量早投，尤其是提前批别错过，秋招的一大感悟就是投晚了，真hc紧缺，很多公司都会有个池子养鱼，简历投了几个星期才面试。</li><li>适当练下手，培养面试状态，别一开始就面你最想去的公司</li><li>别只等转正offer，今年很多公司招了不少实习生，转正率不高，等offer会变得很焦虑</li><li>提早复习，边实习边复习，真的会没时间复习&amp;焦虑&amp;复习效果不好；</li><li>尽早拿一个offer垫底，没offer+没试提前批真的焦虑；有offer之后面试也硬气起来了</li><li>找个小伙伴 or 对象；不要一个人焦虑</li></ol><p>祝学弟学妹们，春招/秋招顺利！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看到的帖子先留下来&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/2021/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-09-20T09:05:43.000Z</published>
    <updated>2021-09-22T03:28:29.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统简要提纲</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>操作系统知识模块主要分为：操作系统概述、进程管理、内存管理、文件管理、输入/输出(I/O)管理。</p><p>操作系统（Operating System，OS）是计算机系统中最重要的系统软件，控制和管理整个计算机系统的硬件和软件资源。它位于硬件和其他系统软件之间。</p><p>操作系统的功能：</p><p>进程管理、内存管理、文件管理、输入/输出(I/O)管理、用户接口管理</p><p>操作系统的基本特征：<strong>并发、共享、虚拟和异步</strong>。</p><ul><li><p>并发是指两个或多个事件在<strong>同一时间间隔内</strong>发生。</p></li><li><p>共享是系统资源供多个并发执行的进程共同使用。</p></li><li><p>虚拟是指<strong>把一个物理上的实体变为若干个逻辑上的对应物</strong>。操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如<strong>虚拟存储器。</strong></p></li><li><p>异步是指在多道程序环境下，允许多个程序并发执行，但由于自由有限，进程的执行不是一贯到底，而是走走停停，<strong>以不可知的速度向前推进，这就是进程的异步性</strong></p></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程是系统进行资源分配和调度的一个独立单位。</p><p>用进程控制块（PCB）来动态地描述进程，PCB是进程存在的唯一标志。</p><p><strong>进程状态：</strong></p><p>五状态模型</p><ul><li>新建状态：进程正在被创建，尚未转到就绪状态</li><li>就绪状态：进程已获得除处理机之外的一切所需资源</li><li>运行状态：进程正在处理机上运行</li><li>阻塞状态：进程正在等待某一事件而暂停运行</li><li>终止状态：进程正从系统中消失，分为正常结束和异常退出</li></ul><p><strong>线程</strong>：</p><p>引入线程，是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p><p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元。</p><p>线程共享进程拥有的全部资源。</p><p>线程不拥有系统资源，但是它可以访问进程所拥有的系统资源。</p><p>线程没有自己独立的地址空间，他共享他所属的进程的空间。</p><p>线程自己并不拥有资源，而是与进程中的其他线程共享资源。也叫轻量级进程</p><p><strong>调度层次：</strong></p><ul><li>作业调度（高级调度）：选择处于后备状态的作业分配资源，发送频率低</li><li>内存调度（中级调度）：选择暂时不能允许的进程调出内存，发送频率中等</li><li>进程调度（低级调度）：选择就绪队列中合适的进程分配处理机，发生频率高</li></ul><p>**进程调度方式 **</p><ol><li>非剥夺调度方式 ：有更为重要或紧迫的进程需要使用处理机，仍让当前进程继续执行</li><li>剥夺调度方式 ：有更为重要或紧迫的进程需要使用处理机，立即分配</li></ol><p><strong>调度算法</strong></p><p>1.<strong>先来先服务调度算法（FCFS）</strong>，顾名思义，先到先得</p><p>2.<strong>短作业优先（SJF）调度算法</strong></p><p>从后备队列中选择一个或若干个估计运行时间最短的作业，将他们调入内存运行。</p><p>3.<strong>优先级调度算法</strong></p><p>根据能否抢占进程，可将调度算法分为：</p><ol><li>非剥夺式优先级调度算法</li><li>剥夺式优先级调度算法</li></ol><p>根据进程创建后其优先级是否可以改变，分为：</p><ol><li>静态优先级。优先级在创建进程时确定，且在进程的整个运行期间保持不变。</li><li>动态优先级。可动态调整优先级。</li></ol><p>4.<strong>高响应比优先调度算法</strong>：是对FCFS和SJF算法的综合平衡</p><p>5.<strong>时间片轮转调度算法</strong>：为每一个进程分配一个时间片，用完后进程循环轮流运行</p><p><strong>进程同步</strong></p><p>临界资源</p><p>我们把<strong>一次仅允许一个进程使用的资源</strong>称为临界资源。</p><p><strong>死锁</strong></p><h2 id="死锁的相关知识"><a href="#死锁的相关知识" class="headerlink" title="死锁的相关知识"></a>死锁的相关知识</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>是指多个线程在运行过程中因争夺资源而造成的一种僵局，它们中的一个或者多个都在等待某个资源被释放。</p><p>我们举一个例子：比如说，线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，都在等待对方释放自己所需要的资源，那么这时候两个线程就会互相等待而进入死锁状态。</p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210727212453831.png" alt="死锁的例子" style="zoom:67%;" /><h3 id="死锁产生的原因？"><a href="#死锁产生的原因？" class="headerlink" title="死锁产生的原因？"></a>死锁产生的原因？</h3><p>我们知道系统中的资源可以分为两类，一类是可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放。</p><p>第一个原因，因为多个进程之间<strong>竞争不可剥夺资源</strong>，比如说有一个进程抢占了打印机，其他进程只能等这个进程使用完成后才能使用。（举个例子假定进程PI已占用了打印机R1，进程P2已占用了磁带机R2，若P2继续要求打印机R1，P2将阻塞；P1若又要求磁带机，P1也将阻塞。于是，在P1和P2之间就形成了僵局）</p><p>第二个原因，竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p><p>第三个原因，进程间推进顺序非法</p><p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。</p><h3 id="死锁的必要条件？（4个，缺一不可）"><a href="#死锁的必要条件？（4个，缺一不可）" class="headerlink" title="死锁的必要条件？（4个，缺一不可）"></a>死锁的必要条件？（4个，缺一不可）</h3><p>1.<strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即一个资源每次只能被一个进程使用。</p><p>2.<strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>3.<strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p><p>4.<strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。（即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。）</p><h3 id="如何解决死锁问题？"><a href="#如何解决死锁问题？" class="headerlink" title="如何解决死锁问题？"></a>如何解决死锁问题？</h3><p>包括预防死锁、避免死锁、检测死锁、解除死锁四种方式</p><p><strong>预防死锁</strong></p><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p><p>1.<strong>破坏互斥条件</strong>（无法实现）：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的，如果互斥性被破坏的话，以打印机为例，多个进程共享使用打印机，则打印出来的结果就不正确了（临界资源需要互斥访问</p><p>2.<strong>破坏请求与保持条件</strong>：一次性申请所有的资源，该进程就可以顺利执行完毕（优点简单易于实现，缺点严重地降低了资源的利用率，有的资源在进程的后期才会使用，而其他进程要用这个资源的话就必须等待）</p><p>3.<strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>4.<strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。<br>破坏循环等待条件。（不足：1.需要知道资源的请求顺序、2.要请求某个序号比较大的资源时，需要先请求序号比较小的资源，占用了序号比较小的资源，使其利用率变低）</p><p><strong>避免死锁</strong></p><p>避免死锁可以采用判断<strong>系统是否会处于安全状态</strong>的方法</p><p>在进行系统资源分配之前，先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给<strong>进程； 否则，让进程</strong>等待。这是一种保证系统不进入死锁状态的动态策略</p><blockquote><p>系统的安全状态</p><p>对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p></blockquote><p><strong>银行家算法</strong>（一个避免死锁的著名算法）</p><p>我们可以把操作系统看作是银行家，系统资源看做资金，客户看做进程。</p><p>算法要求：</p><p>1、申请的贷款额度不能超过银行现有的资金总额</p><p>2、分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额</p><p>3、如果银行暂时不能满足客户申请的资金额度时，可推迟放款并在有限时间内给予贷款</p><p>4、客户要在规定的时间内还款</p><p><strong>检测死锁</strong></p><p>这种方法并不需要事先采取任何限制性措施，即允许产生死锁，若检测到死锁则采取相应的方法解除死锁</p><p><strong>解除死锁</strong></p><p>如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，此时就需要对系统采取相应的措施。常用的解除死锁的方法：<br>1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。<br>2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。<br>    a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。<br>     b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。一般根据如下几个方面来决定终止哪个进程：<br>    进程的优先级<br>    进程已运行时间以及运行完成还需要的时间<br>    进程已占用系统资源<br>    进程运行完成还需要的资源<br>    终止进程数目<br>    进程是交互还是批处理</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><code>地址空间</code>：</p><ul><li>逻辑地址空间：是指一个源程序的相对地址的空间；</li><li>物理地址空间：内存中物理地址</li></ul><p><code>地址重定位</code>：将逻辑地址转换为物理地址。</p><p>页面更新算法就是用来确定淘汰哪些页面的算法，</p><p>内存抖动：刚销毁不久的页面不久后又要使用，又要将其调入内存中，反反复复，导致大部分时间开销都花费在反复调度页面上。</p><p>最优更新算法：淘汰以后永远不会使用，或未来很长一段时间内不会使用的页面，无法实现</p><p>先进先出更新算法（FIFO）：淘汰最先进入内存的页面</p><p>最近最久未使用更新算法（LRU）：淘汰最近最久没有使用的页面</p><p>页式内存管理、内存抖动、页面更新算法</p><p>段式内存管理</p><p>虚拟内存</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h2 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统简要提纲&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——概述</title>
    <link href="http://example.com/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</id>
    <published>2021-09-19T12:06:43.000Z</published>
    <updated>2021-09-21T01:58:10.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之概述</p></blockquote><a id="more"></a><p><a href="https://blog.csdn.net/cdlwhm1217096231/article/details/90760282">https://blog.csdn.net/cdlwhm1217096231/article/details/90760282</a></p><p>这篇总结写的非常详细和清楚</p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p>边缘部分：所有连接在互联网上的主机（主机指的是所有与网络直接相连的计算机）组成</p><p>核心部分：<strong>大量的网络</strong>与连接这些网络所使用的<strong>路由器</strong>构成，为边缘部分提供服务。</p><h3 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a><strong>计算机之间的通信</strong></h3><p>指的是主机A上的一个进程与主机B上的另一个进程之间进行通信。</p><p>计算机通信的方式主要有两种：</p><ul><li><strong>客户-服务器方式：即C /S方式</strong>。客户端发送服务的请求，服务器是服务的提供方。</li><li><strong>P2P：点对点连接方式</strong>。两台通信的主机之间不区分哪个是客户，哪个是服务端，进行对等连接</li></ul><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><p><strong>举个例子</strong>：</p><p>从A找到一条通往E的路径并建立会话的过程中，我们称之为<strong>电路交换</strong>的第一阶段—-<strong>建立连接</strong>。</p><p>之后A和E在通话的过程中会始终霸占着这条路径，数据传输的过程称为电路交换的第二阶段—-<strong>数据传输</strong>。</p><p>电路交换的第三阶段，也就是最后一个阶段—-<strong>释放连接</strong>。A和B只要有一方挂了电话，那便了开始释放连接。</p><p><strong>优点：</strong></p><p>1、传输速度快、高效。</p><p>2、实时。</p><p><strong>缺点：</strong></p><p>1、资源利用率低。（有可能占用着路线但没有进行通信）</p><p>2、新建连接需要占据一定的时间，甚至比通话的时间还长。</p><h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2. 分组交换"></a>2. 分组交换</h3><p>所谓分组，就是将一个数据包分成一个个更小的数据包。每个数据包由文件头和数据组成。分组交换采取<strong>存储转发</strong>传输的机制，<strong>单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</strong></p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210831155035763.png" alt="数据包" style="zoom:67%;" /><p>举个例子：我们生活中邮局的信件传输</p><p><strong>缺点：</strong></p><p>1、不具有实时性。</p><p>2、存在延时。 （A通过中介B到达E，并不是实时传输的）</p><p>3、会造成通信阻塞。 （太多数据包丢给路由器B后会造成堵塞）</p><p>4、存在无用的重复数据。（每个小数据包中的文件头有许多重复的数据）</p><p>5、会出现丢包的情况。 （路由器B的容量是有限的，如果有太多的数据包丢给它，它可能会容纳不下造成丢包）</p><p><strong>致命的优点：</strong></p><p>1、设计简单 。</p><p>2、资源利用率很高。</p><h3 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h3><p>当然，还有一种<strong>报文交换</strong>的方式，就是将整个报文进行存储转发的，不过这种方式使用的比较少</p><h3 id="4-三种交换方式示意图"><a href="#4-三种交换方式示意图" class="headerlink" title="4. 三种交换方式示意图"></a>4. 三种交换方式示意图</h3><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210831155953905.png" alt="三种交换方式示意图" style="zoom:67%;" /><p>详细见下面的链接</p><p><a href="https://blog.csdn.net/m0_37907797/article/details/104228141">电路交换与分组交换有什么区别？</a></p><h3 id="路由器介绍："><a href="#路由器介绍：" class="headerlink" title="路由器介绍："></a><strong>路由器</strong>介绍：</h3><p>核心部分起到特殊作用的是<strong>路由器</strong>，它是一个<strong>专用的计算机</strong>，主要作用是<strong>分组交换</strong>和<strong>存储转发</strong>的功能。</p><p>路由器的<strong>工作流程</strong>：</p><p>接收分组数据 -》检查首部 -》根据目的地址查找转发表 -》将分组转发给下一个路由器 -》一步一步转发到目的地</p><p>路由器接收到一个分组后，暂存数据到路由器自己的缓存中即自身的存储器中，然后检查其首部，查找转发表。按照首部中的目的地址，找到合适的接口转发除去，把分组交给下一个路由器。这样一步一步以存储转发的方式，把分组交给最终的目的主机。路由器只是暂存一个分组，不是整个报文。分组在哪段链路上传送时才会占用此段链路上的通信资源，在各分组传输之间的空闲时间，此链路也是可以被其他主机发送的分组使用。</p><h3 id="计算机网络中的常见硬件设备介绍："><a href="#计算机网络中的常见硬件设备介绍：" class="headerlink" title="计算机网络中的常见硬件设备介绍："></a>计算机网络中的常见硬件设备介绍：</h3><p><strong>物理层</strong>：实现网络互连的主要设备有**中继器和HUB(集线器)**。中继器的主要功能是对接收到的信号进行再生整形放大以扩大网络的传输距离；集线器在此基础上将所有的节点集中在以它为中心的节点中，可组成星型拓扑结构。</p><p><strong>数据链路层</strong>：实现网络互联的主要设备有<strong>交换机和网桥</strong>。交换机是一种基于MAC识别，能完成封装转发数据包功能的网络设备。它可以“学习”MAC地址，并把其存放在内部地址表中，当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口。 交换机将局域网分为多个冲突域，每个冲突域都是有独立的宽带，因此大大提高了局域网的带宽。网桥是数据链路层互联的设备，在网络互联中可起到数据接收、地址过滤与数据转发的作用，可用来实现多个不同网络系统之间的数据交换。</p><p><strong>网络层</strong>：实现网络互连的主要设备有<strong>三层交换机和路由器</strong>。路由器用于连接多个逻辑上分开的网络，具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网。</p><p><strong>传输层（包括传输层）以上</strong>：<strong>实现网络互连的设备有网关</strong>。网关在网络层以上实现网络互连，用于两个高层协议不同的网络互连。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210921095346172.png" alt="每层的网络设备"></p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210919161518894.png" alt="计算机网络体系结构"></p><h3 id="三个体系的简要介绍："><a href="#三个体系的简要介绍：" class="headerlink" title="三个体系的简要介绍："></a><strong>三个体系的简要介绍：</strong></h3><p>OSI由于体系比较复杂，而且设<strong>计先于实现</strong>，有许多设计过于理想，<strong>不太方便计算机软件实现</strong>，因而完全实现OSI参考模型的系统不多，应用的范围有限。</p><p>TCP/IP协议最早在计算机系统中实现，在Linux、Windows平台中都<strong>有稳定的实现</strong>，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP/IP协议已成为目前互联网事实上的国际标准和工业标准。</p><p>五层协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：<strong>物理层、数据链路层、网络层、运输层、应用层。</strong>（最底下两层可以称为网络接口层）</p><p>五层协议的体系结构只是为<strong>介绍网络原理而设计</strong>的，实际应用还是TCP/IP四层体系结构。</p><p>在互联网使用的各种协中最重要和最著名的就是 <strong>TCP/IP</strong> 两个协议。现在人们经常提到的TCP/IP 并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整<strong>个TCP/IP协议族。</strong></p><p>4.<strong>数据在各层之间的传递过程</strong></p><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有<strong>下面三层协议（物理层、数据链路层、网络层），</strong>因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h3 id="每层的大概作用"><a href="#每层的大概作用" class="headerlink" title="每层的大概作用"></a><strong>每层的大概作用</strong></h3><ul><li><strong>应用层</strong>：<strong>应用层直接为用户的应用进程程序提供服务</strong>。这里的进程就是指正在运行的程序。如支持万维网应用的http协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等。</li><li><strong>运输层</strong>：<strong>运输层的任务就是负责向两个主机进程之间的通信提供服务</strong>。由于一个主机可以同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是运输层把收到的信息分别交付给上面应用层中的相应进程。<br>运输层主要使用下面两个协议：<br><strong>传输控制协议TCP</strong>（Transmission Control Protocol）：面向连接的，数据传输的基本单位是报文段，能够提供可靠的交付<br><strong>用户数据报协议UDP</strong>（User Datagram Protocol）：无连接的，数据传输的基本单位是用户数据报，不能保证提供可靠的交付，只能提供尽最大努力交付。</li><li><strong>网络层</strong>： <strong>负责为分组交换网上的不同主机提供通信服务</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作<strong>IP数据报。</strong></li><li><strong>数据链路层</strong>：两个主机之间的数据传输，总是在一段一段的链路上传送的。在两个相邻结点之间传送数据时，<strong>数据链路层将网络层交下来的IP数据报组装成帧</strong>，在两个相邻结点间的链路上<strong>透明地传送帧中的数据</strong>，每一帧包括数据和必要的控制信息。</li><li><strong>物理层</strong>：<strong>负责最底层的物理介质连接</strong>。在物理层上传送的数据单位是<strong>比特</strong>。<strong>物理层的任务就是透明地传送比特流。</strong></li></ul><h3 id="每层的常用协议："><a href="#每层的常用协议：" class="headerlink" title="每层的常用协议：　"></a><strong>每层的常用协议：</strong>　</h3><p>物理层：</p><p>数据链路层：ppp协议、CSMA/CD 协议</p><p>网络层：IP、ARP、ICMP、IGMP、OSPF、RIP、BGP</p><p>传输层：TCP（传输控制协议）、UDP（用户数据报协议）</p><p>应用层：FTP（文件传输）、SMTP（电子邮件相关）、HTTP（超文本传输协议）、DNS（域名系统）、Telnet（远程登录）、WWW、NFS</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li><p>传输数据的基本单位：<strong>比特流0和1</strong></p></li><li><p>通道：</p><ul><li>单向通道（<strong>单工通道</strong>）：单向传输</li><li>双向交替通信（<strong>半双工通信</strong>）：双向交替传输</li><li>双向同时通信（<strong>全双工通信</strong>）：双向同时传输</li></ul></li></ul><ul><li>通道复用技术：<ul><li><strong>频分复用</strong>（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li><strong>时分复用</strong>（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li><strong>波分复用</strong>（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li><strong>码分复用</strong>（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之概述&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://example.com/2021/09/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/09/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-17T03:45:51.000Z</published>
    <updated>2021-09-28T02:30:52.075Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回溯本质就是一颗递归树</p></blockquote><a id="more"></a><p>回溯问题的解题模板：</p><p>在回溯函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;   <span class="comment">//此处要new一个新的路径加入，因为比如说res.add(path);由于是地址传递，在回溯的最后path为空，所以res中最后结果是几个空的path</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    剪枝; <span class="comment">//画递归树看是按层剪枝还是同一个树枝剪枝。</span></span><br><span class="line">    处理节点; <span class="comment">//一般是把节点加入路径中</span></span><br><span class="line">    backtracking(选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果; <span class="comment">//一般是去掉path中最后一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>假如是排除重复的情况，注意什么时候主函数中nums要排序，什么时候要设置一个start（一般是组合问题）</li></ul><hr><ul><li>排列问题</li><li>组合问题（查找叶子结点 ）</li><li>子集问题（查找每一个子节点）</li><li>分割问题（类似组合问题）</li></ul><p>组合问题都需要设置一个 startIndex， 保证每次搜索不能重复，排列则不需要</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</p><p>有同学问了，什么时候for可以从0开始呢？</p><p>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。</p><p>但是要清楚子集问题和组合问题、分割问题的的区别，<strong>子集是收集树形结构中树的所有节点的结果</strong>。</p><p><strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，<strong>一个维度是同一树枝上使用过，一个维度是同一树层上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p><strong>两种去重方式比较</strong>：</p><p>如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210917161342246.png" alt="树层上去重"></p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210917161411436.png" alt="树枝上去重"></p><p><strong>树层上对前一位去重非常彻底，效率很高</strong>，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><p>这两句话说的真好，我们都是在两个维度上面进行去重的，一个是同一层上，一个是一个树枝上。</p></blockquote><p>参考资料：代码随想录</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;回溯本质就是一颗递归树&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>9.11</title>
    <link href="http://example.com/2021/09/11/9-11/"/>
    <id>http://example.com/2021/09/11/9-11/</id>
    <published>2021-09-11T02:34:25.000Z</published>
    <updated>2021-10-12T01:43:17.159Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕咕一下</p></blockquote><a id="more"></a><p>最近事情蛮多。</p><p>前段时间忙着保研材料，感谢竞赛加分，算了下排名已经很稳很稳了。</p><p>其实你会发现，人的主观能动性所带来的的能量是非常巨大的。只要你想做什么事情，全面分析，一步一步开始做，做好长期的规划，最终的结果都是很好的。</p><p>我总是记得家里人说过的一句话，什么阶段就该做什么阶段的事情。身边的很多事例都证明了这句话的正确性。</p><p>一个阶段的结束又是另一个新阶段的开始。</p><p>可能是很久没写感想了，让我再写出什么刻骨铭心的感想也写不出来了，这段时间让思想变得简单点，再去做自己想做的事情。</p><hr><p>虽然中途差点找不到老师，好在事在人为。</p><hr><p>9.27更</p><p>最近国家一系列手段、各种政策方针下来，随着经济的高速发展，给人一种大的要来了的感觉。</p><p>疫情加速了这种割据的状态。</p><p>我对国家的发展持乐观态势，但对底层普通百姓的生活持悲观态度。</p><p>历史的发展都是相似的，从历史中得到的最大教训就是人们不会吸取历史教训。</p><p>大部分会被时代洪流裹挟着往前走。</p><hr><p>10.8更</p><p>要保持一颗积极<strong>乐观</strong>向上的心，人生的常态就是求而不得。</p><p>还有就是</p><p>如果你对未来期许太多，往往会思前想后，觉得这个没用那个没用，这个没意义那个没意思，浮于表面。</p><p>如果太过看到眼前的东西，眼界又会被遮挡住，丢掉很多有用的信息。</p><p>正确的应该是眼前有个长期的目标，但不要每天总想着要怎么才能去到达最后一步，而是把这些目标划分成一个个小小的模块，每次做一点，把每个小部分做完，在每个小部分中探索一些支线剧情，在根据目标和当前的实际情况做调整，不至于太高或太低。</p><p>好像把上面的总结一下，是未来的美好期许和眼前自身实力的差距以及想一步到位的心理要素之间的矛盾所导致的。</p><p>人太急是做不好事情的，太悠闲也只会啥也干不好。</p><p>我好像很容易陷入这两种极端中，希望能找到一个中间调和点</p><p>没有人会和你作对，即便有你也改变不了什么，大部分情况下是我们自己在做无用的情绪消耗</p><p>让时间来沉淀自己的情绪</p><p>嚯</p><hr><p>10.12更</p><p>为什么很多人会发现即使自己在教室里坐了很久：但还是时间不够用呢？</p><p>学习第一要义：进入教室后，直奔主题开始学习，不要想着先看看新闻，先刷几分钟pyq，这样会导致两种完全不一样的学习状态。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕咕一下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="想法" scheme="http://example.com/categories/%E6%83%B3%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>两个大数求和</title>
    <link href="http://example.com/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <id>http://example.com/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/</id>
    <published>2021-09-04T13:47:54.000Z</published>
    <updated>2021-09-19T02:32:06.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果给出两个很大很大的整数，这两个数大到long类型也装不下，比如100位整数，如何求它们的和呢？</p></blockquote><a id="more"></a><p>采用字符串存储，逆序相加，最后的结果再逆序即可</p><p><img src="/images/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/image-20210904215330885.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            res.append(tmp % <span class="number">10</span>);</span><br><span class="line">            i--; j--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//此处要注意最后一个进位可能为1，但还没有加上去</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是自己写的，有点麻烦，还是看上面的比较好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bigNumberSum</span><span class="params">(String bigNumberA, String bigNumberB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.把两个大整数用数组逆序存储，数组长度等于较大整数位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLength = Math.max(bigNumberA.length(), bigNumberB.length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigNumberA.length(); i++)&#123;</span><br><span class="line">        arrayA[i] = bigNumberA.charAt(bigNumberA.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigNumberB.length(); i++)&#123;</span><br><span class="line">        arrayB[i] = bigNumberB.charAt(bigNumberB.length() - <span class="number">1</span>- i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构建result数组，数组长度等于较大整数位数+1，为了保证进位数能被存放下</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历数组，按位相加，每一个位置上的值=对应位数值相加再加上进位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLength; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arrayA[i] + arrayB[i] + carry;</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = tmp % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.如果最后一位进位为1,</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">        result[result.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        len = maxLength + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        len = maxLength ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.把result数组再次逆序并转成String（之前要判断首位是0还是1）</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        sb.append(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(bigNumberSum(<span class="string">&quot;426709752318&quot;</span>, <span class="string">&quot;95481253129&quot;</span>));</span><br><span class="line">    <span class="comment">//运行结果：522191005447</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果给出两个很大很大的整数，这两个数大到long类型也装不下，比如100位整数，如何求它们的和呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql相关</title>
    <link href="http://example.com/2021/09/03/mysql%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/09/03/mysql%E7%9B%B8%E5%85%B3/</id>
    <published>2021-09-03T09:04:17.000Z</published>
    <updated>2021-09-03T13:14:27.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mysql一些面试题</p></blockquote><a id="more"></a><h2 id="mysql里面的数据类型"><a href="#mysql里面的数据类型" class="headerlink" title="mysql里面的数据类型"></a>mysql里面的数据类型</h2><p>主要有三种：<strong>数值</strong>、<strong>时间</strong>和**字符串(字符)**类型。</p><img src="/images/mysql/image-20210903171114888.png" alt="数据类型"  /><p><a href="https://zhuanlan.zhihu.com/p/50891083">https://zhuanlan.zhihu.com/p/50891083</a></p><h2 id="mysql-里面时间是怎么存储的"><a href="#mysql-里面时间是怎么存储的" class="headerlink" title="mysql 里面时间是怎么存储的"></a>mysql 里面时间是怎么存储的</h2><p>存储时间的类型：year、date、time、datetime、timestamp</p><p><strong>DATE</strong> - 以YYYY-MM-DD格式的日期，在1000-01-01和9999-12-31之间。 例如，1973年12月30日将被存储为1973-12-30。</p><p><strong>DATETIME</strong> - 日期和时间组合以YYYY-MM-DD HH:MM:SS格式，在1000-01-01 00:00:00 到9999-12-31 23:59:59之间。例如，1973年12月30日下午3:30，会被存储为1973-12-30 15:30:00。</p><p><strong>TIMESTAMP</strong> - 1970年1月1日午夜之间的时间戳，到2037的某个时候。这看起来像前面的DATETIME格式，无需只是数字之间的连字符; 1973年12月30日下午3点30分将被存储为19731230153000(YYYYMMDDHHMMSS)。</p><p><strong>TIME</strong> - 存储时间在HH:MM:SS格式。</p><p><strong>YEAR(M)</strong> - 以2位或4位数字格式来存储年份。如果长度指定为2(例如YEAR(2))，年份就可以为1970至2069(70〜69)。如果长度指定为4，年份范围是1901-2155，默认长度为4。</p><p><img src="/images/mysql/v2-63be71052bbe166d1d1bfdf63a0dc83a_1440w.jpg"></p><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种数据结构,可以帮助我们<strong>快速的进行数据的查找.</strong></p><p>拿字典作比方，字典目录的作用是快速定位某一个汉字，而索引的作用是快速定位所需数据</p><p>提出问题：为什么不用二叉搜索树？</p><p>创建索引需要两个条件，这就是：我要给谁–以什么实现方式–创建什么类型的索引</p><ol><li>给谁：就是给那个字段，这里可以是一个字段，也可以是多个字段；</li><li>实现方式：就是索引的数据结构，可以是BTREE、HASH；</li><li>类型：就是索引的类型，innoDB中一共支持四种索引类型，分别是普通索引、唯一索引、主键索引、全文索引。</li></ol><p>创建索引的字段：可以是一个字段，也可以是多个字段，在多个字段上使用时需要满足最左匹配原则。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>单值索引</li><li>主键索引</li><li>唯一索引</li><li>复合索引</li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有<strong>Hash索引,B+树索引</strong>等,而我 们经常使用的<strong>InnoDB存储引擎</strong>的默认索引实现为:B+树索引.</p><h2 id="聚簇索引非聚簇索引"><a href="#聚簇索引非聚簇索引" class="headerlink" title="聚簇索引非聚簇索引"></a>聚簇索引非聚簇索引</h2><p>一些关键词：</p><p>InnoDB、MyISAM</p><p>索引、B+树、聚簇索引、</p><p>事务、并发事务、事务回滚、隔离级别</p><p>mysql锁、锁算法、锁优化、</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;mysql一些面试题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>http相关内容</title>
    <link href="http://example.com/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</id>
    <published>2021-09-01T11:52:13.000Z</published>
    <updated>2021-09-20T07:51:01.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>http</p></blockquote><a id="more"></a><h2 id="在浏览器中输入url到显示页面的过程中发生了什么？"><a href="#在浏览器中输入url到显示页面的过程中发生了什么？" class="headerlink" title="在浏览器中输入url到显示页面的过程中发生了什么？"></a>在浏览器中输入url到显示页面的过程中发生了什么？</h2><p>1、通过DNS解析<strong>将域名解析为对应的IP地址</strong> ，寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。  （DNS解析过程）</p><p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;（三次握手具体过程） </p><p>3、由浏览器发送一个HTTP请求 ，经过路由器的转发，到达了服务器 </p><p>4、服务器处理该HTTP请求，返回一个HTML文件 </p><p>5、浏览器解析该HTML文件，并且显示在浏览器端</p><blockquote><p>DNS解析过程：</p><p>DNS查找过程：浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存（hosts文件）中是否有这个域名对应的DNS解析结果。若还没有，此时会发送一个数据包给DNS服务器，DNS服务器找到后将解析所得IP地址返回给用户。</p></blockquote><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>超文本传输协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），属于应用层，端口号80</p><p>HTTP协议<strong>定义Web客户端如何向Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</strong></p><p>HTTP协议采用了<strong>请求/响应模型</strong>。<strong>客户端向服务器发送一个请求报文</strong>，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。<strong>服务器以一个状态行作为响应</strong>，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>请求报文包含三部分：</p><ul><li>请求行：包含请求方法、URI、HTTP版本信息</li><li>请求首部字段</li><li>请求内容实体</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901204224623.png" alt="请求报文结构"></p><p>响应报文包含三部分：</p><ul><li>状态行：包含HTTP版本、状态码、状态码的原因短语</li><li>响应首部字段</li><li>响应内容实体</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901204401019.png" alt="响应报文结构"></p><h2 id="常用的-HTTP-请求方法"><a href="#常用的-HTTP-请求方法" class="headerlink" title="常用的 HTTP 请求方法"></a>常用的 HTTP 请求方法</h2><ul><li>GET：<strong>GET方法用来请求URL指定的资源。</strong>指定的资源经服务器端解析后返回响应内容 </li><li>POST：<strong>用于传输信息给服务器，主要功能与GET方法类似</strong>，但一般推荐使用POST方式。 </li><li>PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。 </li><li>HEAD：获得报文首部，与GET方法类似，只是不返回报文主体</li><li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 </li><li>OPTIONS：请求一些选项信息，允许客户端查看服务器的性能</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901200949347.png" alt="option方法作用"></p><h2 id="Get与Post的区别"><a href="#Get与Post的区别" class="headerlink" title="Get与Post的区别"></a>Get与Post的区别</h2><p>1、 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源</p><p>2、GET是<strong>幂等的，即读取同一个资源，总是得到相同的数据</strong>，而POST不是幂等 的，因为每次请求对资源的改变并不是相同的</p><p>3、就安全性而言，<strong>POST的安全性要比GET的安全性高</strong>，因为GET请求提交的数据将<strong>明文</strong>出现在URL上， 而且POST请求参数则被包装到<strong>请求体</strong>中，相对更安全。</p><p>4、从请求的大小看，<strong>GET请求的长度受限于浏览器或服务器对URL长度的限制</strong>，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p><h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901201650517.png" alt="状态码"></p><p>一些常见状态码的含义：</p><table><thead><tr><th>状态码</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>初始的请求已经接受，请客户端继续发送剩余部分</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>301</td><td>永久移动</td><td>请求的页面已永久跳转到新的url</td></tr><tr><td>401</td><td>未授权</td><td>请求要求用户进行身份演验证</td></tr><tr><td>403</td><td>禁止</td><td>服务器拒绝请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的页面</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理出现错误</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr></tbody></table><h2 id="什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h2><p><strong>概念</strong>：是指每一次的请求都是独立的，客户端第一次向服务器发送请求完成之后，再一次向服务器发送请求，服务器并不知道该客户端是刚才那个。</p><p><strong>解决方法</strong>：</p><p>使用Cookie和Session技术（引出这两个知识点）</p><h2 id="Cookie和Session技术"><a href="#Cookie和Session技术" class="headerlink" title="Cookie和Session技术"></a>Cookie和Session技术</h2><h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><p>1、端口：HTTP的URL由”http://起始且默认使用端口80，而HTTPS的URL由”https:/起始且默认使用端口443.</p><p>2、安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份。</p><p>HTTPS是运行在<strong>SSL</strong>之上的HTTP协议，SSL运行在TCP之上。所有传输的内容都经过加密，<strong>加密采用对称加密</strong>，但对<strong>称加密的密钥用服务器方的证书进行了非对称加密</strong>。所以说，<strong>HTTP安全性没有HTTPS高，但是HTTPS比HTTP耗费更多服务器资源。</strong></p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><blockquote><p>对称加密：密钥只有一个，加密解密为同一个密钥，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p>非对称加密：公钥所有人都可以获得，通信发送方获得接收方的公钥之后，就可以使用公钥进行加密，接收方收到通信内容后使用私钥解密。相对对称加密速度较慢。</p><p>SSL：安全套接层（Secure Sockets Layer ）</p><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901215413693.png"></p></blockquote><h2 id="HTTP长连接-短连接"><a href="#HTTP长连接-短连接" class="headerlink" title="HTTP长连接,短连接"></a>HTTP长连接,短连接</h2><p>HTTP的长连接和短连接<strong>本质上是TCP长连接和短连接</strong>。</p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>Keep-Alive不会永久保持连接，它有一个<strong>保持时间</strong>，可以在header当中进行设置的。实现长连接需要客户端和服务端都支持长连接。</p><h3 id="什么时候用长连接，短连接？"><a href="#什么时候用长连接，短连接？" class="headerlink" title="什么时候用长连接，短连接？"></a><strong>什么时候用长连接，短连接？</strong></h3><ol><li>长连接多用于<strong>操作频繁，点对点的通讯，而且连接数不能太多情况</strong>，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</li><li>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。<strong>所以并发量大，但每个用户无需频繁操作情况下需用短连好。</strong></li></ol><h3 id="长连接与短连接区别"><a href="#长连接与短连接区别" class="headerlink" title="长连接与短连接区别:"></a>长连接与短连接区别:</h3><p>**长连接:**连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）； </p><p>**短连接:**连接→数据传输→关闭连接；</p><h2 id="Http1-0-和-Http1-1-有什么区别？"><a href="#Http1-0-和-Http1-1-有什么区别？" class="headerlink" title="Http1.0 和 Http1.1 有什么区别？"></a>Http1.0 和 Http1.1 有什么区别？</h2><p>HTTP1.0出现早，主要用于一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ul><li>长连接 : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li>错误状态响应码 :<strong>在HTTP1.1中新增了24个错误状态响应码</strong>，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——应用层</title>
    <link href="http://example.com/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-09-01T09:07:44.000Z</published>
    <updated>2021-09-20T08:09:27.026Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之应用层</p></blockquote><a id="more"></a><h2 id="域名系统（DNS）-Domain-Name-System"><a href="#域名系统（DNS）-Domain-Name-System" class="headerlink" title="域名系统（DNS）  Domain Name System"></a>域名系统（DNS）  Domain Name System</h2><p>DNS 可以使用 <strong>UDP 或者 TCP</strong> 进行传输，使用的<strong>端口号都为 53。</strong>大多数情况下 DNS 使用 <strong>UDP 进行传输</strong>，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 <strong>TCP 进行传输：</strong></p><ul><li>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com</li><li>如果返回的响应<strong>超过 512 字节</strong>（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><p><strong>域名有什么用？</strong></p><p>我们可以通过IP地址去访问网站，但ip地址并不好记，域名是具有一定含义的字符组合。域名系统可以将域名与IP地址相互映射。便于人们访问网页。</p><p><strong>DNS劫持：</strong></p><p>指某些手段取得域名的解析控制权，将此地址指向一个错误的IP地址的行为，相当于访问到的并不是原来的网页。</p><h2 id="文件传送协议（FTP）File-Transfer-Protocol"><a href="#文件传送协议（FTP）File-Transfer-Protocol" class="headerlink" title="文件传送协议（FTP）File Transfer Protocol"></a>文件传送协议（FTP）File Transfer Protocol</h2><p>FTP使用两个并行的<strong>TCP</strong>连接来传输文件，一个是控制连接，一个是数据连接。</p><ul><li><strong>控制连接</strong>：服务器打开<strong>端口号 21</strong> 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li><strong>数据连接</strong>：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有<strong>主动</strong>和<strong>被动</strong>两种模式：</p><ul><li><p><strong>主动模式</strong>：服务器端主动建立数据连接，其中服务器端的<strong>端口号为 20</strong>，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</p></li><li><p><strong>被动模式</strong>：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p></li></ul><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。</p><p>被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><p>还有一个TFTP（Trivial File Transfer Protocol,简单文件传输协议）看做是FTP的简化版本，使用UDP传输，简单，速度快，但是安全性不好（使用UDP传输）</p><h2 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了<strong>即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</strong></p><p>DHCP 配置的内容不仅是 IP 地址，还包括<strong>子网掩码</strong>、<strong>网关 IP 地址。</strong></p><h2 id="远程登录协议（TELNET）"><a href="#远程登录协议（TELNET）" class="headerlink" title="远程登录协议（TELNET）"></a>远程登录协议（TELNET）</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：<strong>用户代理</strong>、<strong>邮件服务器</strong>以及<strong>邮件协议</strong>。</p><p>邮件协议包含发送协议和读取协议，<strong>发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</strong></p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20210901172320605.png"></p><h3 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1. SMTP"></a>1. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><h3 id="2-POP3"><a href="#2-POP3" class="headerlink" title="2. POP3"></a>2. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p><h3 id="3-IMAP"><a href="#3-IMAP" class="headerlink" title="3. IMAP"></a>3. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之应用层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历模板</title>
    <link href="http://example.com/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-09-01T02:04:34.000Z</published>
    <updated>2021-09-02T10:31:43.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树遍历模板</p></blockquote><a id="more"></a><p>使用迭代法：</p><p>前序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val);   <span class="comment">//中序相当于把这一句移到了下面代码块中间</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList();    <span class="comment">//在前序遍历的基础上换成了LinkedList</span></span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.addFirst(root.val);   </span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;   <span class="comment">//在前序遍历的基础上把左右子树的顺序换了一下</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;二叉树遍历模板&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络——传输层</title>
    <link href="http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2021-08-31T13:18:15.000Z</published>
    <updated>2021-09-21T03:33:44.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之传输层</p></blockquote><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我们知道<strong>网络层可以实现两个主机之间的通信</strong>。但是这并不具体，因为，真正进行通信的实体是在<strong>主机中的进程</strong>，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。<strong>IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。而端到端的通信才应该是应用进程之间的通信。</strong></p><p><strong>UDP</strong> 在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的<strong>速度比较快</strong>，比如一些对<strong>实时性要求较高的服务</strong>，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p><p><strong>TCP</strong> 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p><h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul><li>用户数据报协议 UDP（User Datagram Protocol）是<strong>无连接的</strong>，<strong>尽最大可能交付</strong>，<strong>不能保证可靠性</strong>，<strong>没有拥塞控制，面向报文</strong>（对于应用程序传下来的报文不合并也不拆分，<strong>只是添加 UDP 首部</strong>），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是<strong>面向连接的</strong>，<strong>提供可靠交付</strong>，<strong>有流量控制，拥塞控制</strong>，<strong>提供全双工通信</strong>，<strong>面向字节流</strong>（把应用层传下来的报文看成字节流，把一个数据包拆分成若干组进行发送），每一条 TCP 连接只能是<strong>点对点的</strong>（一对一）。</li></ul><h2 id="TCP、UDP协议的区别"><a href="#TCP、UDP协议的区别" class="headerlink" title="TCP、UDP协议的区别"></a>TCP、UDP协议的区别</h2><ul><li>TCP是面向连接的，UDP是无连接的； </li><li>TCP是可靠的，UDP是不可靠的；</li><li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式； </li><li>TCP是面向字节流的，UDP是面向报文的； </li><li>TCP有流量控制、拥塞控制机制;UDP没有拥塞控制机制。</li><li>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</li></ul><h2 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h2><p>对某些<strong>实时性要求比较高</strong>的情况使用UDP，比如即时通信（QQ聊天），实时直播，视频会议，即使出现传输错误也可以容忍；</p><p>对<strong>数据准确性要求高，速度可以相对较慢</strong>的情况用TCP。比如: 文件传输、邮件的发送与接收等。</p><h2 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h2><ul><li><p><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据； </p></li><li><p><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达<strong>可能会失序</strong>，<strong>TCP将对失序数据进行重新排序，然后才交给应用层；</strong> </p></li><li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据； </p></li><li><p><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能 及时收到一个确认，将重发这个报文段； </p></li><li><p><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓 冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使 用的流量控制协议是可变大小的滑动窗口协议</p></li><li><p><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。</p></li></ul><h2 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h2><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210919221902143.png" alt="TCP报文结构" style="zoom:67%;" /><p>TCP首部</p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210919221922389.png" alt="TCP首部" style="zoom:67%;" /><p><strong>TCP的6种标志位</strong>（tcp flags）</p><ul><li>URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li><li>ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。</li><li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li><li>RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li><li>FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。</li></ul><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><h3 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h3><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210831220758563.png" alt="TCP三次握手"  /><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK = 1，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><blockquote><p>有6种位码即tcp标志位</p><p>① SYN(synchronous建立联机)；</p><p>② ACK(acknowledgement 确认)</p><p>③ PSH(push传送)</p><p>④ FIN(finish结束)</p><p>⑤ RST(reset重置)</p><p>⑥ URG(urgent紧急)</p><p>Sequence number(顺序号码) //Acknowledge number(确认号码)</p></blockquote><h3 id="为什么要有第三次握手呢？"><a href="#为什么要有第三次握手呢？" class="headerlink" title="为什么要有第三次握手呢？"></a><strong>为什么要有第三次握手呢？</strong></h3><blockquote><p>为了防止已失效的连接请求报文段突然又传送到了服务端，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，在第二次握手时客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><p><a href="https://blog.csdn.net/scuzoutao/article/details/81774100">https://blog.csdn.net/scuzoutao/article/details/81774100</a></p><h3 id="第三次握手失败了怎么办？"><a href="#第三次握手失败了怎么办？" class="headerlink" title="第三次握手失败了怎么办？"></a><strong>第三次握手失败了怎么办？</strong></h3><p>当client与server的第三次握手失败了之后，即client发送至server的确认建立连接报文段未能到达server，server在等待client回复ACK的过程中超时了（超过了SYN timeout），<strong>那么server会向client发送一个RTS报文段并进入关闭状态</strong>，即：并不等待client第三次握手的ACK包重传，直接关闭连接请求，这主要是为了<strong>防止SYN泛洪攻击</strong>。</p><h3 id="三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？"><a href="#三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？" class="headerlink" title="三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？"></a>三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？</h3><p><strong>SYN泛洪攻击</strong></p><p><strong>黑客仿造IP大量的向服务器发送TCP连接请求报文包，而当服务器返回ACK后，该攻击者就不对其进行再确认从而将server的半连接队列占满</strong>（上文所说的未连接队列，即server收到连接请求SYN之后将client加入半连接队列中），<strong>从而使得server拒绝其他正常的连接请求</strong>。即拒绝服务攻击</p><h3 id="怎么防范这种攻击？"><a href="#怎么防范这种攻击？" class="headerlink" title="怎么防范这种攻击？"></a>怎么防范这种攻击？</h3><p>对于SYN泛洪攻击的防范，优化主机系统设置是常用的手段。</p><ul><li><p>如<strong>降低SYN timeout时间</strong>，使得主机尽快释放半连接的占用；</p></li><li><p>又比如采用SYN cookie设置，如果<strong>短时间内连续收到</strong>某个IP的重复SYN请求，则认为受到了该IP的攻击，<strong>丢弃来自该IP的后续请求报文。</strong></p></li><li><p>此外合理地采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击。</p></li></ul><blockquote><p>SYN timeout时间</p><p>客户端程序因为莫名崩溃等原因，收到SYN+ACK报文后不再回以ACK，服务端将如何处置呢？这时服务端会“优雅地”再等等，会不会是发送的包丢失了呢？于是重新发送一遍SYN+ACK，再收不到来自客户端的ACK响应的话，就把这次连接请求丢弃掉。这个过程大约会“优雅地”持续分钟级，这个持续时间被称作SYN timeout时间。</p></blockquote><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>连接的释放</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210831221447248.png" alt="TCP的四次挥手"></p><p>第一次挥手:客户端请求断开，向服务器发送了FIN=1。<br>就是我这边即将要把数据传输完了，我准备跟你断开连接了。</p><p>第二次挥手：服务端收到了FIN标志位后，并不会立即向客户端发送FIN标志位，而是发送一个ACK的应答信息。<br>相当于：你想要关闭的请求我已经收到，服务端继续发送之前没发完的数据给客户端；</p><p>第三次挥手：当服务端将最后的数据发送完毕，不再需要连接时，发送连接释放报文，将ACK和FIN=1。</p><p>第四次挥手：客户端收到请求后，发送一个确认断开连接的请求给服务端。这时候客户端进入<strong>TIME_WAIT状态</strong>，等待 <strong>2 MSL（最大报文存活时间）</strong>后释放连接。 </p><p><strong>为什么客户端最后还要等待2MSL？</strong></p><blockquote><p>MSL（Maximum Segment Lifetime），TCP允许设置不同的MSL值。</p><p>第一，为了保证客户端第四次挥手时发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 标志符，客户端再重传 ACK，并重新计时。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>TCP利用<strong>滑动窗口机制</strong>实现流量控制，流量控制是为了<strong>控制发送方发送速率</strong>，<strong>让接收方来得及接收。</strong></p><p>接收方发送的确认报文中的<strong>窗口字段</strong>（<strong>rwnd</strong>）可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p>rwnd = 0</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>若对网络中某<strong>资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏。这种现象称为<strong>拥塞</strong> (congestion)</p><p>出现拥塞的<strong>原因</strong>：∑对资源需求 &gt; 可用资源</p><p>拥塞往往会趋于恶化：如果网络出现拥塞，分组将会丢失，此时发送方会继续<strong>重传</strong>，从而导致网络拥塞程度更高。</p><p>TCP 主要通过<strong>四个算法</strong>来进行拥塞控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong>。</p><p>为了问题简单化，我们假定：</p><ul><li>数据是<strong>单方向传送</strong>，而另外一个方向只传送确认</li><li>接收方总是<strong>有足够大的接收缓存空间</strong>，因此不会发生流量控制；</li></ul><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方需要维护一个叫做<strong>拥塞窗口（cwnd）</strong>的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p><p>注意<strong>拥塞窗口与发送方窗口的区别</strong>：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口，考虑到接收方的接受能力，发送窗口可能小于拥塞窗口。<strong>发送窗口的上限=Min[rwnd,cwnd].</strong></p><p><strong>慢开始：</strong></p><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个<strong>报文段</strong>；当收到确认后，将 cwnd <strong>加倍</strong>，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个<strong>慢开始门限 ssthresh</strong>，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了<strong>网络拥塞</strong>（其根据就是<strong>接收端没有收到确认</strong>），令 ssthresh = cwnd / 2，cwnd = 1，然后重新执行慢开始。</p><blockquote><p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p></blockquote><p><strong>拥塞避免：</strong></p><p>拥塞避免算法思路：让拥塞窗口缓慢增长，即每经过一个往返时间就把发送方的<strong>拥塞窗口cwnd加1</strong>，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901155452218.png"></p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传和快恢复（FRR）能快速恢复丢失的数据包</p><p><strong>快重传</strong>：</p><p>快重传要求接收方在收到一个<strong>失序</strong>的报文段后就立即发出<strong>重复确认</strong>，发送方只要一连收到<strong>三个重复确认</strong>就应当立即重传对方尚未收到的报文段，不用<strong>重传计时器时间</strong>到期再重传（比如设置60s，如果60s发送端没有收到确认，则重传该数据）。</p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901161422815.png" alt="image-20210901161422815" style="zoom:80%;" /><p><strong>快恢复</strong>：</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时<strong>直接进入拥塞避免</strong>（cwnd每次加一而不是翻倍）。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901161722077.png" alt="快恢复"></p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。<strong>慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</strong></p><ul><li></li></ul><h2 id="TCP-和-UDP分别对应的常见应用层协议"><a href="#TCP-和-UDP分别对应的常见应用层协议" class="headerlink" title="TCP 和 UDP分别对应的常见应用层协议"></a>TCP 和 UDP分别对应的常见应用层协议</h2><p>1、 <strong>TCP 对应的应用层协议：</strong> </p><ul><li>FTP：定义了<strong>文件传输协议</strong>，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服 务。下载文件，上传主页，都要用到FTP服务。 </li><li>Telnet：它是一种用于<strong>远程登陆</strong>的端口，用户可以以自己的身份远程连接到计算机上，通过这种端 口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将 23端口打开，对外提供服务。 </li><li>SMTP：定义了<strong>简单邮件传送协议</strong>，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常 见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口 设置这个栏，服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于<strong>接收邮件</strong>。通常情况下，POP3协议所用的是110端口。也是 说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登 陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进 入自己的邮-箱来收信）。 </li><li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</li></ul><p> 2、 <strong>UDP 对应的应用层协议：</strong> </p><ul><li>DNS：用于<strong>域名解析服务</strong>，将域名地址转换为IP地址。DNS用的是53号端口。 </li><li>SNMP：<strong>简单网络管理协议</strong>，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 </li><li>TFTP(Trival File Transfer Protocal)：<strong>简单文件传输协议</strong>，该协议在熟知端口69上使用UDP服务</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之传输层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——网络层</title>
    <link href="http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-08-31T12:06:43.000Z</published>
    <updated>2021-09-22T02:40:04.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之网络层</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>网络层向上只提供<strong>简单灵活的、无连接的、尽最大努力交付</strong>的数据报服务，不提供服务质量的承诺。即<strong>不可靠传输</strong>，也就是所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的<strong>运输层负责可靠交付</strong>（包括差错处理、流量控制等） 。</li><li>网络在发送分组时<strong>不需要先建立连接</strong>。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li></ul><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="IP地址表示方法及其分类"><a href="#IP地址表示方法及其分类" class="headerlink" title="IP地址表示方法及其分类"></a>IP地址表示方法及其分类</h2><p>IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是<strong>唯一的 32 位的标识符</strong></p><h3 id="点分十进制表示IP地址"><a href="#点分十进制表示IP地址" class="headerlink" title="点分十进制表示IP地址"></a>点分十进制表示IP地址</h3><p>将32位二进制<strong>每8个为一组</strong>转化为10进制，每组用小数点隔开</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831201947844.png" alt="点分十进制"></p><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>将IP地址划分为若干个固定类。</p><ul><li>其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络</li><li>而另一个字段则是主机号 host-id，它标志该主机（或路由器）。</li></ul><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831202353408.png" alt="image-20210831202353408" style="zoom:80%;" /><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p>IP地址可分为<strong>ABCDE五类</strong></p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831202500778.png" style="zoom:80%;" /><h2 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210919211052531.png" alt="IP数据报格式"></p><p><strong>IP数据报格式：</strong></p><ul><li>一个IP数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li>首部的前一部分是<strong>固定长度</strong>，共<strong>20字节</strong>，是所有IP数据报必须具有的。</li><li>在首部的固定部分的后面是一些<strong>可选字段</strong>，其长度是可变的。</li></ul><p>首部固定部分部分字段含义：</p><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>生存时间</strong> ：TTL（time to live），它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>源地址和目的地址</strong>：两个地址都占4字节</li></ul><h2 id="IP地址与硬件地址区别"><a href="#IP地址与硬件地址区别" class="headerlink" title="IP地址与硬件地址区别"></a>IP地址与硬件地址区别</h2><ul><li>IP 地址是<strong>网络层和以上各层使用的地址</strong>，是一种<strong>逻辑地址</strong>（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。</li><li>硬件地址（或物理地址）是<strong>数据链路层</strong>和<strong>物理层</strong>使用的地址。</li><li>IP 地址放在 IP 数据报的首部</li><li>硬件地址则放在 MAC 帧的首部。</li></ul><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831202725519.png" style="zoom:80%;" /><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><h3 id="ARP协议作用"><a href="#ARP协议作用" class="headerlink" title="ARP协议作用"></a>ARP协议作用</h3><p>通信时要使用两个地址：</p><ol><li>IP地址(网络层地址)</li><li>MAC地址(数据链路层地址)</li></ol><p><strong>IP 地址通过地址解析协议ARP，解析出在数据链路层使用的硬件地址</strong>。因为不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</p><p>ARP 实现由 <strong>IP 地址</strong>得到 <strong>MAC 地址</strong>。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831203333054.png" alt="ARP协议的作用"></p><h3 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h3><p>每一个<strong>主机</strong>都设有一个 <strong>ARP 高速缓存 (ARPcache)**，存有</strong>所在的局域网上<strong>的各主机和路由器的 **IP 地址到硬件地址的映射表。</strong></p><p><strong>作用</strong>：存放最近获得的 IP 地址到 MAC 地址的映射，以减少 ARP 广播的数量。为了减少网络上的通信量。</p><p><strong>问题</strong>：如何知道同一个局域网内其他主机的mac地址？</p><p><strong>流程</strong>：如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过<strong>广播</strong>的方式发送 ARP 请求分组，主机 B 收到该请求后会给主机 A做出响应告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><p>注意：ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831203629409.png" alt="image-20210831203629409"></p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了<strong>更有效地转发 IP 数据报和提高交付成功的机会</strong>。它封装在 IP 数据报中，但是<strong>不属于高层协议。</strong></p><p>ICMP 报文分为<strong>差错报告报文</strong>和<strong>询问报文。</strong></p><p>ICMP的功能是报告问题而不是纠正问题。</p><p>ICMP报文分为差错报告报文和询问报文两种。若数据报不能到达目标主机，ICMP差错报告报文可以以回送信息的方式，向源主机发去信息，并不能纠正数据报中的任何出错。除了出错报告，ICMP还可以诊断出某些网络问题，这就是ICMP的查询报文。</p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831205116023.png" style="zoom:67%;" /><p>ICMP 的两种常见应用：<strong>Ping</strong> 和  <strong>Traceroute</strong>。</p><h3 id="PING-Packet-InterNet-Groper-的应用举例"><a href="#PING-Packet-InterNet-Groper-的应用举例" class="headerlink" title="PING (Packet InterNet Groper) 的应用举例"></a>PING (Packet InterNet Groper) 的应用举例</h3><ul><li><p>主要用来<strong>测试两台主机之间的连通性</strong>。</p></li><li><p>Ping 的原理是通过向目的主机发送 ICMP Echo request 报文，目的主机收到之后会发送 Echo reply报文。Ping 会根据时间和成功响应的次数估算出<strong>数据包往返时间</strong>以及<strong>丢包率</strong>。</p></li><li><p>Ping 是应用层直接使用网络层 ICMP 的例子，</p></li><li><p>它没有通过运输层的 TCP 或 UDP。</p></li></ul><h3 id="Traceroute-的应用举例"><a href="#Traceroute-的应用举例" class="headerlink" title="Traceroute 的应用举例"></a>Traceroute 的应用举例</h3><ul><li><p>用来<strong>跟踪一个分组从源点到终点的路径。</strong></p></li><li><p>traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p></li></ul><ul><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><p>IGMP网络组管理协议。主要用于建立和管理多播组，对IP分组广播进行控制。</p><h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：<strong>路由选择</strong>和<strong>分组转发</strong>。</p><p>分组转发结构由三个部分组成：<strong>交换结构</strong>、<strong>一组输入端口</strong>和<strong>一组输出端口</strong>。</p><p>路由器中通过<strong>路由表</strong>和<strong>分组转发算法</strong>来实现其功能的。</p><p>路由表中每条路由包含以下信息：<strong>（目的网络地址，下一跳地址）</strong></p><h2 id="路由器分组转发流程（IP数据报转发算法）"><a href="#路由器分组转发流程（IP数据报转发算法）" class="headerlink" title="路由器分组转发流程（IP数据报转发算法）"></a>路由器分组转发流程（IP数据报转发算法）</h2><p>知道了主机和路由器的IP地址，怎么将数据报传送过去？</p><ul><li>从<strong>数据报的首部</strong>提取目的主机的 <strong>IP 地址 D</strong>，得到目的<strong>网络地址 N</strong>。</li><li>若 N 就是<strong>与此路由器直接相连的某个网络地址</strong>，则进行直接交付；（直接交付，下面的是间接交付）</li><li>若路由表中有<strong>目的地址为 D 的路由</strong>，则把数据报传送给表中所指明的下一跳路由器；</li><li>若路由表中有<strong>到达网络 N 的路由</strong>，则把数据报传送给路由表中所指明的下一跳路由器；</li><li>若路由表中<strong>有一个默认路由</strong>，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210919211720950.png" alt="路由器分组转发流程"></p><p>另外，当涉及到包含子网划分的问题时，需要将路由做如下改动：</p><p>​                                <strong>（目的网络地址，子网掩码，下一跳地址）</strong></p><p>相应的，上述算法也需要做一些改动，但整体流程还是一致的。改动如下：</p><ul><li>从数据报的首部提取目的主机的IP地址D，<strong>将子网掩码和IP地址做按位与运算</strong>可得出网络地址N</li><li>若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要在经过其他路由器，直接把数据报交付给目的主机（这里涉及到地址解析协议，不再详述）；否则就是间接交付，执行（3）；</li><li>若路由表中有目的地址为D的特定主机路由，则把数据报传送给该路由指明的下一跳地址；否则，执行（4）；</li><li>.若路由表中有达到网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器。；否则，执行（5）；</li><li>若路由表中有一个默认路由，则把数据报该默认路由指明的下一跳地址；</li><li>否则，报告转发分组出错。</li></ul><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li><strong>内部网关协议IGP</strong>（一个自治系统内）：RIP 和 OSPF</li><li><strong>外部网关协议EGP</strong>（自治系统间）：BGP</li></ul><h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种<strong>基于距离向量</strong>的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，因此距离16表示不可达。</p><p>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的最佳距离记录</strong>（即一组距离）</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210920172758485.png"></p><p>RIP 协议的特点：（和谁交换？交换什么？多久交换一次？）<br>① <strong>仅和相邻路由器交换信息并不断更新路由表，经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</strong></p><p>② 路由器交换的信息是自己的路由表</p><p>③ 每隔30s交换一次路由信息并更新路由表。</p><p>RIP 协议<strong>实现简单，开销小</strong>。但是当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><p>使用距离向量算法（具体不写了）</p><h3 id="2-内部网关协议-OSPF（Open-Shortest-Path-First）"><a href="#2-内部网关协议-OSPF（Open-Shortest-Path-First）" class="headerlink" title="2. 内部网关协议 OSPF（Open Shortest Path First）"></a>2. 内部网关协议 OSPF（Open Shortest Path First）</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示<strong>使用了 Dijkstra 提出的最短路径算法 SPF。</strong></p><p>OSPF 协议的特点：（和谁交换？交换什么？多久交换一次？）</p><ul><li>向<strong>本自治系统中的所有路由器发送信息，这种方法是洪泛法。</strong></li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。<strong>相比于 RIP，OSPF 的更新过程收敛的很快。</strong></p><h3 id="3-外部网关协议-BGP"><a href="#3-外部网关协议-BGP" class="headerlink" title="3. 外部网关协议 BGP"></a>3. 外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210920173637886.png" alt="image-20210920173637886" style="zoom:67%;" /><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，<strong>通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</strong></p><h3 id="4-三种路由协议比较"><a href="#4-三种路由协议比较" class="headerlink" title="4.三种路由协议比较"></a>4.三种路由协议比较</h3><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210920173521153.png" alt="三种路由协议比较"></p><h2 id="虚拟专用网络-VPN"><a href="#虚拟专用网络-VPN" class="headerlink" title="虚拟专用网络 VPN"></a>虚拟专用网络 VPN</h2><p>vpn（Virtual Private Network）</p><p>使用的两种技术：<strong>隧道传输</strong>和<strong>加密技术</strong></p><p>主机想在内网中进行私密传输</p><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并<strong>不需要把所有的主机接入到外部的互联网中</strong>，机构内的计算机可以使用<strong>仅在本机构有效</strong>的 IP 地址（专用地址）。</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来<strong>将本地 IP 转换为全球 IP。</strong></p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，<strong>使得多个专用网内部的主机共用一个全球 IP 地址</strong>。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之网络层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——数据链路层</title>
    <link href="http://example.com/2021/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2021/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-08-29T12:19:48.000Z</published>
    <updated>2021-09-21T02:21:19.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之数据链路层</p></blockquote><a id="more"></a><p>参考下面这篇文章的</p><p><a href="https://www.nowcoder.com/discuss/711548?channel=-1&amp;source_id=profile_follow_post_nctrack">https://www.nowcoder.com/discuss/711548?channel=-1&amp;source_id=profile_follow_post_nctrack</a>  </p><p>1.操作系统</p><p>1.1 linux 杀掉一个进程，怎么操作？</p><p>ps -ef | grep 正则表达式     来查询进程pid  （其中-e为显示所有进程，-f为全格式显示。）</p><p>然后 kill pid</p><p>强制杀死 kill - 9 pid</p><p>其中默认是 kill pid  相当于 kill -15 pid， 默认信号是15，有时候程序接到这个信号时会先释放自己的资源，做一些准备工作然后再干净地退出，<strong>即有可能不会立马退出</strong></p><p>kill -9 会<strong>强制进程退出</strong></p><p>1.2 32、64位操作系统区别</p><p>32位就每次处理32个0和1的组合 4g内存（2^30 = 1GB ), 有外设需占用内存，实际可以使用的达不到4G。64位就每次处理64个0和1的组合 。所以说64位应该更快。</p><p>1.3 操作系统的虚拟内存管理</p><p>分页式内存管理和分段式内存管理</p><p>2.计网</p><p>2.1 浏览器提示找不到IP地址，怎么解决？</p><p>DNS解析  Domain Name System  域名系统</p><p>2.2 DNS解析过程</p><p>域名是为了方便记忆而专门建立的一套地址转换系统，要访问一台互联网上的服务器，最终还必须通过<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>来实现，域名解析就是将域名重新转换为IP地址的过程。一个域名对应一个IP地址，一个IP地址可以对应多个域名；所以多个域名可以同时被解析到一个IP地址。域名解析需要由专门的域名解析服务器(DNS)来完成。</p><p>使用的传输层协议： TCP、UDP</p><p>2.3 TCP如何保证可靠传输</p><hr><p>ISP   Internet Service Provider   互联网服务提供商</p><p>IXP  Internet Exchange Point   互联网交换中心</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层主要有两个功能 ：<strong>帧编码</strong>（将IP数据报封装成帧）和<strong>误差纠正控制</strong></p><p>数据链路层使用的信道主要有两种类型：<strong>点对点信道</strong>(PPP协议)和<strong>广播信道</strong>（CSMA/CD 协议）。</p><p>数据链路层传送的是<strong>帧</strong>，那么就要考虑<strong>三个基本问题。</strong>（<strong>封装成帧、透明传输、差错检测</strong>）</p><p><strong>1. 封装成帧</strong></p><p>将网络层传下来的<strong>IP数据报</strong>添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831170624807.png"></p><p><strong>2.透明传输问题</strong></p><p>透明指的是对外界是<strong>不可见的</strong>。</p><ul><li>SOH表示帧的首部开始</li><li>EOT表示帧的结束</li></ul><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831171037929.png" style="zoom:67%;" /><ul><li>思考：但是如果数据中的<strong>某个字节的二进制代码恰好和 SOH 或EOT 一样</strong>，数据链路层会不会错误地“找到帧的边界”？</li><li>答案：会的，这就是透明传输问题。</li></ul><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831171213023.png" style="zoom: 67%;" /><ul><li><p>解决方法：发送端在控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符</strong>ESC，接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831193739949.png" alt="解决"></p></li></ul><p><strong>3.差错检测</strong></p><p>传输过程中可能会产生<code>比特差错</code>：1 可能会变成 0 而 0 也可能变成 1。</p><p>目前数据链路层广泛使用了<strong>循环冗余检验（CRC）</strong>（Cyclic Redundancy Check）来检查比特差错。</p><p>（1）在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。<br>（2）在发送端，先把数据<strong>划分为组。</strong><br>（3）我们在 每组数据 的后面再添加供差错检测用的 n 位<strong>冗余码一起发送</strong>。</p><h3 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h3><p>一对多通信，<strong>一个节点发送的数据能够被广播信道上所有的节点接收到。</strong></p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用 <strong>CSMA/CD 协议。</strong></p><p>信道复用技术：频分服用、时分复用、码分复用等</p><h3 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h3><p><strong>用户计算机和 ISP （互联网服务提供商）</strong>通信时所使用的协议</p><p>一对一通信。 point to point</p><p>因为不会发生碰撞，因此也比较简单，使用 <strong>PPP 协议</strong>进行控制。</p><h3 id="3-CSMA-CD-协议"><a href="#3-CSMA-CD-协议" class="headerlink" title="3. CSMA/CD 协议"></a>3. CSMA/CD 协议</h3><p>CSMA/CD 含义： 载波监听多点接入 / 碰撞检测(Carrier Sense Multiple Access with CollisionDetection) 。</p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831165301685.png" style="zoom: 80%;" /><ul><li><strong>多点接入</strong> ：说明这是<strong>总线型网络</strong>，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，<strong>但是由于电磁波的传播时延的存在，还是有可能会发生碰撞</strong>。</li></ul><h3 id="4-ppp协议"><a href="#4-ppp协议" class="headerlink" title="4. ppp协议"></a>4. ppp协议</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是<strong>用户计算机和 ISP 进行通信时所使用的数据链路层协议。</strong></p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831194112245.png" alt="ppp协议" style="zoom:80%;" /><h2 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h2><p><strong>MAC层是数据链路层的两个子层之一。</strong></p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831195740975.png"></p><p>在局域网中，硬件地址又称为物理地址，或 <strong>MAC 地址。</strong></p><p>MAC 地址是<strong>链路层地址</strong>，长度为 <strong>6 字节</strong>（48 位），用于唯一标识<strong>网络适配器</strong>（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的<strong>广播信道</strong>。</p><p>优点：</p><p>从一个站点可很方便地访问全网，局域网上的主机可<strong>共享连接</strong>在局域网上的各<strong>种硬件和软件资源。</strong></p><p>主要特点：</p><ul><li><p><strong>网络为一个单位所拥有</strong></p></li><li><p><strong>地理范围和站点数目均有限</strong>。</p></li></ul><p>什么是局域网？比如我们小时候上信息课的机房就是一个局域网。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照<strong>网络拓扑结构</strong>对局域网进行分类：</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831194641442.png" alt="按拓扑结构分类"></p><h2 id="以太网局域网"><a href="#以太网局域网" class="headerlink" title="以太网局域网"></a>以太网局域网</h2><p>以太网是一种<strong>星型拓扑结构局域网</strong>。</p><p>早期使用<strong>集线器进行连接</strong>，集线器是一种物理层设备， 作用于比特而不是帧，。</p><p>目前以太网使用<strong>交换机</strong>替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有<strong>自学习能力</strong>，学习的是<strong>交换表</strong>的内容，<strong>交换表中存储着 MAC 地址到接口的映射</strong>。</p><p>正是由于这种自学习能力，因此交换机是一种<strong>即插即用设备，不需要网络管理员手动配置交换表内容。</strong></p><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831195056450.png" alt="交换机"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之数据链路层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划问题</title>
    <link href="http://example.com/2021/08/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/08/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</id>
    <published>2021-08-01T10:07:15.000Z</published>
    <updated>2021-08-01T13:03:46.032Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果哪天我把动态规划弄明白了，我就去楼上楼吃顿好的</p></blockquote><a id="more"></a><p>强推！看这个入门 <a href="https://zhuanlan.zhihu.com/p/91582909%EF%BC%8C%E7%9C%8B%E5%AE%8C%E4%B9%8B%E5%90%8E%E8%BF%9E%E8%BF%87%E5%87%A0%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%BE%88%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%A2%98%E7%9B%AE%E3%80%82">https://zhuanlan.zhihu.com/p/91582909，看完之后连过几题，可以解决很基本的题目。</a></p><p>如果想要深入需要多做题目练习。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果哪天我把动态规划弄明白了，我就去楼上楼吃顿好的&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中,为什么byte类型的取值范围为-128~127?</title>
    <link href="http://example.com/2021/07/31/Java%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA-128-127/"/>
    <id>http://example.com/2021/07/31/Java%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA-128-127/</id>
    <published>2021-07-31T03:45:11.000Z</published>
    <updated>2021-08-01T01:49:48.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在java中，我们知道，byte类型是1字节8位的，取值范围是 -128~127，第一位是符号位。那么按理说0111 1111是最大值，表示127；1111 1111是最小值，表示 -127， 那么 -128是怎么来的呢？</p></blockquote><a id="more"></a><p>在解释这个问题之前我们需要了解几个概念：<strong>机器数</strong>、<strong>真值</strong>、<strong>原码</strong>、<strong>反码</strong>、<strong>补码</strong><br><strong>机器数</strong>：</p><p>一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1。</p><p>比如：十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。</p><p><strong>真值</strong>：<br>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p><p><strong>原码</strong>：<br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>[+1]原 = 0000 0001<br>[-1]原 = 1000 0001<br>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]<br>即[-127 , 127]。原码是人脑最容易理解和计算的表示方式.</p><p><strong>反码</strong>：<br>反码的表示方法是:正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</p><p>[+1] = [00000001]原 = [00000001]反<br>[-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><p><strong>补码</strong>：<br>补码的表示方法是:</p><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><p><strong>总结</strong>：</p><p>1.计算机系统中,数值一律用<strong>补码</strong>来表示(存储)。</p><p>2.正数：<br>正数的反码和补码都与原码相同</p><p>3.负数：<br>负数的反码：原码中除去符号位，其他的数值位取反，0变1，1变0。    负数的补码：反码+1</p><p>4.对于二进制，“减1取反”和“取反加1”的效果是一样的，所以<strong>补码的补码就是原码</strong>；</p><p>所以我们从负数的补码求它的原码时，只需要取反加一，而不需要减一取反（这样是对的，但是容易算错）</p><p>例如：</p><img src="/images/Java%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA-128-127/image-20210731114909912.png" style="zoom:67%;" /><hr><p><strong>解释：为什么byte类型的取值范围为-128~127？</strong></p><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p><p>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>　　所以不需要过多解释. 但是对于负数:</p><p>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>　　可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p><p>　　首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><p>　　于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p><p>　　如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p><p>　　为了解决原码做减法的问题, 出现了反码:</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p><p>　　发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现<strong>在”0”这个特殊的数值上.</strong> 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有**[0000 0000]原和[1000 0000]原两个编码表示0.**</p><p>　　于是补码的出现, 解决了0的符号以及两个编码的问题:</p><p>　　1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =[0000 0001]反 + [1111 1110]反= [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p><p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用**[1000 0000]表示-128:**</p><p>　　(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p><p>　　-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以**-128并没有原码和反码表示**.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)，使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够<strong>多表示一个最低数</strong>. 这就是为什么8位二进制, **使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]**。</p><p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值。</p><p>参考文章：<a href="https://blog.csdn.net/qq_23418393/article/details/57421688">Java中，为什么byte类型的取值范围为-128~127?</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在java中，我们知道，byte类型是1字节8位的，取值范围是 -128~127，第一位是符号位。那么按理说0111 1111是最大值，表示127；1111 1111是最小值，表示 -127， 那么 -128是怎么来的呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
</feed>
