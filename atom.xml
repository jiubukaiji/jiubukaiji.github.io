<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pb</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-09T02:05:29.293Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android点击事件</title>
    <link href="http://example.com/2022/04/06/android%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/"/>
    <id>http://example.com/2022/04/06/android%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</id>
    <published>2022-04-06T04:01:13.000Z</published>
    <updated>2022-05-09T02:05:29.293Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在自定义Adapter类中的onCreateViewHolder直接添加点击事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent,<span class="keyword">false</span>);</span><br><span class="line">    ViewHolder holder = <span class="keyword">new</span> ViewHolder(view);</span><br><span class="line"></span><br><span class="line">    holder.textView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> position = holder.getAdapterPosition();</span><br><span class="line">            Toast.makeText(view.getContext(), <span class="string">&quot;你点击了&quot;</span> + lists.get(position), Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">或者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myHolder.itemView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </span><br><span class="line">                Toast.makeText(context, <span class="string">&quot;短点击&quot;</span>+position, Toast.LENGTH_SHORT).show(); <span class="comment">// context 是上下文</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp</summary>
      
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>机试注意点</title>
    <link href="http://example.com/2022/03/31/%E6%9C%BA%E8%AF%95%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://example.com/2022/03/31/%E6%9C%BA%E8%AF%95%E6%B3%A8%E6%84%8F%E7%82%B9/</id>
    <published>2022-03-31T06:25:33.000Z</published>
    <updated>2022-05-09T02:06:07.530Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ACM模式的java算法模板，希望能有帮助吧</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照这个模板来</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        </span><br><span class="line">        System.out.println(); <span class="comment">//这个是有换行的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遇到输入一个数字n,后面输入n行</span></span><br><span class="line"><span class="comment">// 样例： </span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">// 2 1</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    <span class="comment">//要注意此时n的值变化了，如果后面还要用n的话，在循环之前 int temp = n;</span></span><br><span class="line">    <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">   <span class="comment">// 同上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java 数组的一些常见自带函数用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个数最大值、最小值</span></span><br><span class="line">Math.max();</span><br><span class="line">Math.min();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有时候我们需要一个最小或最大的常量值</span></span><br><span class="line"><span class="keyword">int</span> a = Integer.MAX_VALUE;  <span class="comment">//Integer包中自带的常量 ,大概是2^31 - 1</span></span><br><span class="line"><span class="keyword">int</span> b = Integer.MIN_VALUE;  <span class="comment">//最小的常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型转换</span></span><br><span class="line"><span class="number">1.</span>String -&gt; <span class="keyword">int</span> </span><br><span class="line">Integer.parseInt(String str);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">char</span> -&gt; <span class="keyword">int</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>其他类型 -&gt; String</span><br><span class="line">String.ValueOf(<span class="keyword">int</span> a)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>String -&gt; <span class="keyword">char</span>数组</span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] arr = str.toCharArray();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类型的一些API</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取String中某个位置的字符  </span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> c = str.charAt(<span class="number">1</span>);  <span class="comment">//&#x27;b&#x27;  从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.求String的长度    </span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> len = str.length();  <span class="comment">//4  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.去除首尾的空格</span></span><br><span class="line">String str = <span class="string">&quot;   ab c d  &quot;</span>;</span><br><span class="line">String str1 = str.trim() <span class="comment">// &quot;ab c d&quot;   中间的空格不会去掉</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.按指定元素分割</span></span><br><span class="line">String str = <span class="string">&quot;a,b,c,d&quot;</span>;</span><br><span class="line">String strArr =  str.split(<span class="string">&quot;,&quot;</span>);  <span class="comment">//按照&quot;,&quot;分割，得到一个String数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.得到子串</span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String substr = str.substring(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">//&quot;bc&quot;    1是b，3是d， 包首不包尾</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到一个整数每位数字  num 为整数不能以0开头,  比如 12345  </span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> x = num % <span class="number">10</span>;  <span class="comment">//首先得到的是个位数</span></span><br><span class="line">    list.add(x);   <span class="comment">//把得到的每一位数从后往前放入数组中</span></span><br><span class="line">    num = num / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如一个数不是整数  ，只是一串数字，比如 02311 ，先转换成字符串，再一个个取</span></span><br><span class="line">String num = sc.next();  <span class="comment">//num 是字符串</span></span><br><span class="line"><span class="keyword">int</span> len = num.length();  <span class="comment">//num的长度，也就是位数（如果未知长度的情况下）</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    list.add(num.charAt(i) - <span class="string">&#x27;0&#x27;</span>)  <span class="comment">// num.charAt(i) - &#x27;0&#x27; 直接得到了int类型的数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求一个数组中最大值的下标</span></span><br><span class="line"><span class="keyword">int</span> a[]= &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//定义数组中最大值为max</span></span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;  <span class="comment">//最小的整数，一个常量值</span></span><br><span class="line"><span class="comment">//最大值下标</span></span><br><span class="line"><span class="keyword">int</span> max_Index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &gt; a[max_a]) &#123;</span><br><span class="line">        max = a[i];</span><br><span class="line">        max_Index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;最大值为&quot;</span> + max + <span class="string">&quot;下标为&quot;</span> + max_Index);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求绝对值 ,也是自带函数</span></span><br><span class="line">Math.abs();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ACM模式的java算法模板，希望能有帮助吧&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>实习感受and春节见闻</title>
    <link href="http://example.com/2022/02/07/%E5%AE%9E%E4%B9%A0%E6%84%9F%E5%8F%97and%E6%98%A5%E8%8A%82%E8%A7%81%E9%97%BB/"/>
    <id>http://example.com/2022/02/07/%E5%AE%9E%E4%B9%A0%E6%84%9F%E5%8F%97and%E6%98%A5%E8%8A%82%E8%A7%81%E9%97%BB/</id>
    <published>2022-02-07T03:06:13.000Z</published>
    <updated>2022-02-10T14:10:50.766Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>呱呱呱，好久没写了</p></blockquote><a id="more"></a><p>实践才是王道  菜确实</p><p>想学什么就立马就去做  pb第一定律   永不过时</p><p>知道哪些东西要去学  多去担责任  软实力</p><hr><p>提升自己  多去见识  总会感叹年轻真好</p><hr>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;呱呱呱，好久没写了&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="日常" scheme="http://example.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>仿牛客论坛记录</title>
    <link href="http://example.com/2021/11/14/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/11/14/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-14T06:22:35.000Z</published>
    <updated>2021-11-26T07:14:50.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录仿牛客论坛记录一些不懂的地方</p></blockquote><a id="more"></a><p>运行项目之前的准备：</p><p>1.右键pom.xml,设置为maven项目</p><p>2.修改compile为jdk1.8</p><p>3.在properties中修改端口号、数据库账号密码等等。。</p><p>mybatis中有哪些标签？</p><p>select、update、insert、sql、if、include</p><p>什么是动态sql</p><p>分布式架构中存在session共享的问题：</p><p>因为要保证负载均衡，所以所以。。</p><p>解决方案：粘性session、同步session、将数据存到redis中</p><p>@bean和</p><p><strong>spring事务管理：  事务的传播机制？</strong></p><p>@Transactional，  保证事务是个整体</p><p>springboot整合redis</p><p>先在pom.xml中导入包，写一个配置类，</p><p>再使用redisTemplate来操作</p><p>kafka的消息持久化是怎样的？</p><p>参考文章：<a href="https://blog.csdn.net/weixin_48610702/article/details/115859656?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-12.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-12.no_search_link">https://blog.csdn.net/weixin_48610702/article/details/115859656?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-12.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-12.no_search_link</a></p><p>使用之前要开启redis、zookeeper、kafka、elasticsearch服务器。</p><ul><li><p>打开<strong>redis</strong>：切换到redis目录下，输入：<code>redis-server.exe redis.windows.conf</code></p></li><li><p>打开<strong>Zookeeper</strong>：切换到kafka_2.12-2.3.0，输入：<code>bin\windows\zookeeper-server-start.bat config\zookeeper.properties</code></p></li><li><p>打开<strong>kafka</strong>：切换到kafka_2.12-2.3.0，输入：<code>bin\windows\kafka-server-start.bat config\server.properties</code></p></li><li><p>打开<strong>elasticsearch</strong>：切换到elasticsearch目录下，输入：<code>bin\elasticsearch.bat</code></p></li></ul><p>在index页面上做了一点修改，隐藏了最热功能。</p><h2 id="请简要介绍一下你的项目？"><a href="#请简要介绍一下你的项目？" class="headerlink" title="请简要介绍一下你的项目？"></a>请简要介绍一下你的项目？</h2><p>这个项目的整体结构来源于牛客网，实现了论坛讨论区，主要使用了Springboot、Mybatis、MySQL、Redis、Kafka等工具。实现了用户的注册、登录、发帖、点赞、系统通知、搜索等功能。另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。使用Elasticsearch实现按关键词搜索帖子的功能。</p><p>利用 ThreadLocal 保存用户状态，通过拦截器拦截请求，根据自定义注解判断用户登录状态。<br>使用 Ajax 异步发帖、发送私信、评论，通过字典树过滤敏感词。<br>使用 Redis 实现点赞、关注功能，优化登录模块——存储登录凭证、缓存用户信息、存储 kaptcha 生成的验证码。</p><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a><strong>数据库表设计</strong></h3><h4 id="用户表-user"><a href="#用户表-user" class="headerlink" title="用户表 user"></a><strong>用户表 user</strong></h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>username</td><td>varchar</td><td>用户名，创建索引</td></tr><tr><td>password</td><td>varchar</td><td>用户密码</td></tr><tr><td>salt</td><td>varchar</td><td>加密盐值</td></tr><tr><td>email</td><td>varchar</td><td>用户邮箱，创建索引</td></tr><tr><td>type</td><td>int</td><td>用户类型：0 普通、1 管理员、2 版主</td></tr><tr><td>status</td><td>int</td><td>用户状态：0 未激活、1 已激活</td></tr><tr><td>activation_code</td><td>varchar</td><td>激活码</td></tr><tr><td>header_url</td><td>varchar</td><td>用户头像地址</td></tr><tr><td>create_time</td><td>timestamp</td><td>注册时间</td></tr></tbody></table><h4 id="用户登录凭证表-login-ticket"><a href="#用户登录凭证表-login-ticket" class="headerlink" title="用户登录凭证表 login_ticket"></a>用户登录凭证表 login_ticket</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>登录用户 id</td></tr><tr><td>ticket</td><td>varchar</td><td>登录凭证，随机字符串</td></tr><tr><td>status</td><td>int</td><td>登录状态：0 有效、1 无效</td></tr><tr><td>expired</td><td>timestamp</td><td>过期时间</td></tr></tbody></table><h4 id="帖子表-discuss-post"><a href="#帖子表-discuss-post" class="headerlink" title="帖子表 discuss_post"></a>帖子表 discuss_post</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>发帖的用户 id，创建索引</td></tr><tr><td>title</td><td>varchar</td><td>帖子标题</td></tr><tr><td>content</td><td>text</td><td>帖子内容</td></tr><tr><td>type</td><td>int</td><td>帖子类型：0 普通、1 置顶</td></tr><tr><td>comment_count</td><td>int</td><td>评论数量</td></tr><tr><td>status</td><td>int</td><td>帖子状态：0 普通、1 精华、2 拉黑</td></tr><tr><td>create_time</td><td>timestamp</td><td>帖子发表时间</td></tr></tbody></table><h4 id="评论表-comment"><a href="#评论表-comment" class="headerlink" title="评论表 comment"></a>评论表 comment</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>user_id</td><td>int</td><td>评论的用户 id，创建索引</td></tr><tr><td>entity_id</td><td>int</td><td>评论实体 id（给哪个帖子或哪个评论发表评论），创建索引</td></tr><tr><td>entity_type</td><td>int</td><td>评论实体类型：1 对帖子评论、2 对评论回复</td></tr><tr><td>target_id</td><td>int</td><td>评论目标（具体给哪个人评论） id</td></tr><tr><td>content</td><td>text</td><td>评论内容</td></tr><tr><td>status</td><td>int</td><td>评论状态：0 有效、1 无效</td></tr><tr><td>create_time</td><td>timestamp</td><td>评论发表时间</td></tr></tbody></table><h4 id="消息表-message"><a href="#消息表-message" class="headerlink" title="消息表 message"></a>消息表 message</h4><table><thead><tr><th>字段</th><th>类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>主键、自增</td></tr><tr><td>from_id</td><td>int</td><td>发消息的 id，创建索引</td></tr><tr><td>to_id</td><td>int</td><td>收消息的 id，创建索引</td></tr><tr><td>conversation_id</td><td>varchar</td><td>会话 id，由通信双方 id 拼接，创建索引</td></tr><tr><td>content</td><td>text</td><td>消息内容</td></tr><tr><td>status</td><td>int</td><td>消息状态：0 未读、1 已读、2 删除</td></tr><tr><td>create_time</td><td>timestamp</td><td>消息发送时间</td></tr></tbody></table><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><ul><li>访问注册页面，</li><li><ul><li>填写好注册账号、密码、邮箱</li></ul></li><li>提交注册数据</li><li><ul><li>通过表单提交数据。</li><li>服务端验证账号是否已存在、邮箱是否已注册。</li><li>服务端发送激活邮件。</li></ul></li><li>激活注册账号</li><li><ul><li>点击邮件中的链接，即可完成注册</li></ul></li></ul><p><strong>配置邮箱功能</strong>：</p><ul><li>在新浪邮箱配置 SMTP 服务，引入 <code>spring-boot-starter-mail</code> 依赖。</li><li>在配置文件配置主机（smtp.sina.com）、端口（465）、邮箱、授权码、协议（smtps），设置 smtp.ssl.enable = true。</li><li>调用 springboot内置的 <strong>JavaMailSender</strong> 的 API 发送邮件（只需要填写目标邮箱、邮件主题、邮件内容即可发送），激活 url 由用户 id 和用户的激活码拼接而成。点击激活 url 后由 controller 中的方法进行处理（成功/重复/失败），调用 Model 对象的 <code>addAttribute</code> 方法将结果返回前端。</li></ul><p><strong>注册流程</strong>如下：<br>1，打开注册网页</p><p>2，把注册的表单信息发送给服务器（点注册）</p><p>3、逻辑判断和发送邮件</p><ul><li>判断账号、密码、邮箱<strong>是否为空</strong></li><li>判断账号和邮箱<strong>是否已经存在</strong>（从数据库查）</li><li>如果以上条件都满足的话会在数据库中<strong>初始化用户的信息</strong>，会给密码加随机盐，并用md5对密码加密保存在数据库中，并发送一封注册邮件给用户邮箱（此时status=0，表示未激活）。</li><li>用户点击邮箱中的确认链接后（status置为1）即可完成注册。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//激活链接：http://localhost:8080/community/activation/101/code    #101-用户id，#code-激活码 </span></span><br><span class="line">String url = domain+contextPath+<span class="string">&quot;/activation/&quot;</span>+user.getId()+<span class="string">&quot;/&quot;</span>+user.getActivationCode();</span><br><span class="line">激活连接是由用户的id唯一标识的，当点击链接后，status设为<span class="number">1</span>，再点击就失败显示已经激活。</span><br></pre></td></tr></table></figure><h3 id="登录和退出登录"><a href="#登录和退出登录" class="headerlink" title="登录和退出登录"></a>登录和退出登录</h3><ul><li>访问登录页面</li><li><ul><li>点击顶部区域内的链接，打开登录页面。</li></ul></li><li>登录</li><li><ul><li>验证账号、密码、验证码。</li><li>成功时，生成登录凭证，发放给客户端cookie。</li><li>失败时，跳转回登录页。</li></ul></li><li>退出</li><li><ul><li>将登录凭证修改为失效状态。</li><li>跳转至网站首页</li></ul></li></ul><p><strong>生成验证码</strong></p><ul><li>引入第三方依赖 kaptcha，主要是生成随机的字符串，以及将字符串图片进行模糊化处理，我们可以通过配置文件配置随机的字符串组成、验证码图片尺寸颜色等等。</li><li>在登录的 controller 处理验证码，设置页面的响应类型为 png，通过 ImageIO 的 <code>write</code> 方法将图片输出到浏览器。</li></ul><p>由于访问同一个生成验证码路径，需要在 url 参数加上一个随机数字，保证点击会重新请求获取新图片。</p><p><strong>判断验证码正确后，调用业务层处理登录逻辑</strong></p><p>首先会判断验证码是否正确，是在控制层中判断的，业务层主要进行账号密码的判断。</p><ul><li> 在业务层中首先判断账号、密码是否非空，之后判断账号是否存在、用户是否激活、密码是否正确，将错误信息存到 map 集合。</li><li>如果全部合法，为用户生成一个包含过期时间的<strong>登录凭证</strong>，将凭证存入 redis 和 map 集合。</li></ul><blockquote><p><strong>登录凭证</strong>：四个字段，登录<strong>用户id</strong>，一个随机字符串唯一标识登录凭证，<strong>登录状态</strong>（0有效和1无效，当我们没有登陆的时候通常不会删掉该用户的凭证，而是判断登录状态），<strong>过期时间</strong>（勾选上记住我时间就长，否则设为30min失效    ， 放入redis中）</p></blockquote><p><strong>根据返回的 map 是否包含登陆凭证判断登陆状态</strong></p><ul><li>如果登录成功，<strong>将凭证存入 cookie</strong> ，设置为同样的过期时间，并重定向至首页。</li><li>如果登陆失败，将 map 中的错误信息添加到 Model 对象，返回登录页。</li></ul><p><strong>退出登录只需要将登录凭证的状态设为1，表示登录处于失效状态</strong></p><p><strong>分布式系统session一致性问题</strong></p><p>由于Http是无状态的，每次的http请求之间信息不共享，为了保证用户每次请求不用重新输入账号密码，保存用户的登录状态，就会有session和cookie这样的机制，去保存用户登录信息，但是在分布式部署的时候就会存在session共享的一个问题。</p><p>由于现在网站基本是多台服务器分布式部署的，如果将用户信息存到session中，而session是存到服务器上，在分布式环境下，由于各个服务器主机之间的信息并不共享，将用户信息存到服务器1上，同一个用户的下一个请求过来的时候，由于nginx的负载均衡策略，去请求了服务器2，就找不到之前的session了。下面介绍几种分布式Session问题的解决策略。<img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211118224450584.png" alt="image-20211118224450584"></p><p>粘性session：同一个ip分给同一个服务器，很难做负载均衡</p><p>同步Session：当一个服务器创建了session之后，会将该Session同步给其他<br>服务器。服务器之间耦合，加大服务器之间的同步开销</p><p>Session服务器：专门一个服务器管理Session，这台服务器是单体的，万一挂掉，有安全隐患</p><p>将客户端会话数据不存到Session中而是存到数据库中：<br>关系型数据库性能较慢<br>存到redis中（项目中采用的方式）<img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211118224506990.png" alt="image-20211118224506990"></p><hr><p>第一版： <strong>将用户登录凭证ticket存到mysql的login_ticket表中</strong><br>登陆成功的时候生成登录凭证，生成Loginticket往数据库login_ticket存，并且被设置为cookie，下次用户登录的时候会带上这个ticket，ticket是个随机的UUID字符串，有过期的时间expired和有效的状态status。</p><p>用login_ticket存储用户的登录信息，每次请求会随着cookie带到服务端，服务端只要与数据库比对携带的ticket，就可以通过表中的used_id字段查到用户的信息。<br>用户退出时将status更改为0即可。</p><p>第二版：<strong>使用Redis优化登录模块</strong></p><h3 id="使用Redis优化登录模块"><a href="#使用Redis优化登录模块" class="headerlink" title="使用Redis优化登录模块"></a>使用Redis优化登录模块</h3><ul><li>使用Redis存储验证码</li><li><ul><li>验证码需要频繁的访问与刷新，对性能要求较高。</li><li>验证码不需永久保存，通常在很短的时间后就会失效。</li><li>分布式部署时，存在Session共享的问题。</li></ul></li><li>使用Redis存储登录凭证</li><li><ul><li>处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。</li></ul></li><li>使用Redis缓存用户信息</li><li><ul><li>处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高。</li></ul></li></ul><p><strong>使用Redis存储验证码</strong></p><p>开始我们是把验证码存入session中，每次用户在登录界面上输入验证码时，从session中取验证码，然后再进行比对。</p><p>为什么用Redis存储验证码呢？</p><p>因为验证码需要频繁的访问与刷新，<strong>对性能要求较高</strong>。验证码不需永久保存，通常<strong>在很短的时间后就会失效。</strong></p><p>我们用Redis存储验证码，之后直接从Redis缓存中取，效率更高。</p><p>具体：</p><p>生成验证码的时候用户还未登录，此时随机生成一个kpatchowner字段标明当前用户，并存到cookie中，同时将kaptchowner字符串最为redis的key，具体的验证码的值作为redis的value。</p><p>用户进行登录验证的时候，先从cookie中取出kpatchowner字段，得到唯一标明属于此用户验证码的rediskey，再从redis中取出验证码真正的文本，然后与用户的输入进行比对，判断你验证码是否正确。</p><p><strong>使用Redis存储登录凭证</strong>（判断用户是否登陆，有的功能只有用户登录了才能使用）</p><p>当我们登录的时候，会生成一个登录凭证存入mysql中，登录凭证中包含用户的id，以及当前用户的登录状态（0代表登录了，1代表没有登录），并且把登录凭证存入客户端的cookie中。当我们每次发起请求的时候，都要从请求的cookie中取出登录凭证，并与从mysql中查询用户的登录凭证作比对，确认用户的登录状态，登录凭证的访问的频率非常高（原来登录凭证ticket是存到mysql里面，ticket如果用redis存，mysql就可以不用存了，login_ticket可以作废）于是我们选择使用Redis存储登录凭证。</p><p><strong>使用Redis缓存用户信息</strong></p><p>查询User的时候，先尝试从缓存中取值，缓存中没有的话先从数据库中取然后存到redis中，有些地方会改变用户数据，需要更新缓存，可以直接把该用户的缓存删除，下一次请求的时候发现没有用户的信息，就会重新查一次再放到缓存中</p><h3 id="检查登录状态（拦截器的使用）"><a href="#检查登录状态（拦截器的使用）" class="headerlink" title="检查登录状态（拦截器的使用）"></a>检查登录状态（拦截器的使用）</h3><p>如果用户知道我们账号设置的url，那么不用登录也可以直接访问账号其他页面，显然这是不合理的，利用拦截器，<strong>防止用户在未登录情况下通过 url 访问没有权限的页面。</strong></p><p>所以我们需要检查用户登录状态。</p><p>利用 ThreadLocal 创建 HostHolder 类，包括 <code>set</code>、<code>get</code>、<code>remove</code> 方法，模拟 session 存储用户信息。</p><p>通过实现 HandlerInterceptor 接口创建一个拦截器，在 <code>preHandle</code> 方法中通过查询是否有登录凭证的 cookie，如果有则通过登录凭证查询用户 ID，再通过用户 ID 查询用户。最后将用户放入 hostHolder 中，在本次请求中持有用户信息。</p><p>声明拦截器（实现HandleInterceptor）并在spring @Configuration中配置拦截信息</p><ul><li>在请求开始时查询登录用户</li><li>在本次请求中持有用户数据<br>使用拦截器Interceptor来拦截所有的用户请求，判断请求中的cookie是否存在有效的ticket，如果有的话就将查询用户信息并将用户的信息写入ThreadLocal在本次请求中持有用户，将每个线程的threadLocal都存到一个叫做hostHolder的实例中，根据这个实例就可以在本次请求中全局任意的位置获取用户信息。</li></ul><p>redis是存储用户登录的状态，是在用户登录之后，跨不同的请求的，而使用ThreadLocal具体针对的是一次请求，在这次请求中去存储用户信息，方便程序的开发，比如说我请求了帖子详情页面，去做评论或者回复，就可以直接从threadLocal中取到用户的信息，进行编码。</p><h3 id="发帖、评论、私信"><a href="#发帖、评论、私信" class="headerlink" title="发帖、评论、私信"></a>发帖、评论、私信</h3><p>发帖功能利用了<strong>Ajax技术</strong>，异步加载</p><p>ajax指异步的javascript和xml技术。最大的特点是：<strong>不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。</strong></p><p>项目中：帖子发布成功/失败的提示(点击发表帖子后弹出的消息提示框)，使用到Ajax</p><p><strong>发表帖子</strong>：就是向discuss_post表中插入数据，记录了发帖用户id，标题、内容、类型（置顶或者是精华）、评论数量、发帖时间这些字段</p><p><strong>展示帖子</strong>：点击首页的帖子，帖子标题绑定了详情页的链接，跳转到详情页。就是首先查询controller层，接着调用service层中的findDiscussPostById方法查询到这个帖子，再调用Dao层中Mapper方法，到数据库中查找discuss_post这个数据表，里面记录了帖子的详细情况，因为帖子里面还记录了userId，我们便可以得到发帖者的相关信息。</p><p><strong>添加评论</strong>：评论的是每一个帖子都评论，并且支持对评论进行评论，也就是评论的回复，<br>能够显示评论的数量，具体的内容，以及评论人回复人等等。</p><p>添加评论就是给comment表填充数据，记录了评论的用户、给哪个实体发表了评论（给帖子评论，或者回复帖子），实体类型，给哪个人发表了评论，内容，发表时间。</p><p>添加评论时：(将添加评论和更新评论数量放在一个事务中)使用spring声明式事务管理@Transactional实现</p><p><strong>私信功能</strong>：</p><p><strong>敏感词过滤</strong></p><ul><li>创建静态内部类 TrieNode ，通过 boolean 结束符判断是否匹配到关键字尾部。</li><li>利用 <code>@PostConstruct</code> 注解，在构造方法执行后初始化字典树。</li><li>添加 <code>filter</code> 方法，利用双指针进行匹配，过滤敏感词。</li></ul><hr><h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>如何实现点赞功能？</p><p>对帖子和评论点赞，第一次点赞，第二次取消点赞，统计帖子和评论的赞总数。</p><p>使用redis中的set实现点赞的功能。</p><p>点赞操作：（使用了Redis中set这个数据类型，key代表被点赞的实体，value代表谁给我点了赞）</p><p>key：<code>like:entity:entityType:entityId  </code> 表示被点赞的实体（给帖子还是评论点赞），帖子或评论的id</p><p>value：存的是用户id，为了统计谁给我点了赞</p><p><strong>点赞和取消点赞</strong>：先判断是否点过赞，也就是在redis中查找是否存有点赞的记录（也就是set中是否有这个键值对），如果已经有就是取消点赞（把set中对应的值给删掉），否则就是第一次点赞（添加进set中）</p><p><strong>统计帖子或评论的点赞数量</strong>：只需要统计redis中这个实体所代表的的set中的value的数量，也就是set的尺寸就可以</p><p>被点赞的用户总赞数：</p><p>key：<code>like:user:userId</code>表示被点赞的用户</p><p>value：自增或自减</p><p><strong>在我的主页中统计我收到的赞</strong>：使用redis的事务，在点赞操作后，接着给用户的收到的总赞数加一，反之则减一。</p><p><strong>具体实现</strong>：</p><p>创建 RedisKeyUtil 工具类，通过实体类型和实体 id 生成对应实体获得赞的 key。</p><p>点赞/取消点赞：</p><ul><li>通过 RedisKeyUtil 获得实体点赞的 key，然后通过 RedisTemplate 的 API 操作，调用集合的 <code>isMember</code> 方法查询 userId 是否存在于对应集合中，如果存在则移除出点赞的用户集合，如果不存在则添加到点赞的用户集合。</li><li>通过 RedisTemplate 的 <code>execute</code> 方法实现事务，保证被点赞用户点和点赞用户的数据更新一致。通过 <code>isMember</code> 方法查询用户的点赞状态，之后通过 <code>mutli</code> 方法开启事务，用 <code>exec </code>方法执行事务。</li></ul><p>点赞数量：通过调用 set 集合的 <code>size</code> 方法查询元素个数。</p><p>点赞状态：通过 set 集合的 <code>isMember</code> 方法实现。</p><h3 id="关注和粉丝"><a href="#关注和粉丝" class="headerlink" title="关注和粉丝"></a>关注和粉丝</h3><p><strong>关注和取消关注：</strong></p><p>类似于点赞功能，使用redis的zset实现每一个用户的粉丝列表，以及每一个用户的关注列表。</p><p>可以用两个sorted set 实现粉丝列表和关注列表。key表示某个用户，value中代表粉丝或者关注者，zset的score存储的是关注时间，可以按照时间展示关注的结果。</p><p>同样要实现共同关注功能，只需要对两个用户的关注列表取交集即可。使用 sinter 方法取交集</p><p><strong>具体做法</strong>：</p><p>在 RedisUnitl 工具类增加两个方法</p><ul><li>通过用户 id 和实体类型获得用户关注的实体集合的 key。</li><li>通过实体类型和实体 id 获得实体拥有的粉丝集合的 key。</li></ul><p>当用户关注某实体时，</p><ul><li>将实体 id 和时间作为 value 和 score 加入用户的关注集合。</li><li>将用户 id 和时间作为 value 和 score 加入实体的粉丝集合。</li></ul><p>当用户取消关注某实体时，将实体从用户的关注集合移除，用户从实体的粉丝集合移除。</p><p><strong>关注列表和粉丝列表</strong></p><ul><li>用户的关注列表，通过 zset 的 <code>reverseRange</code> 获取 value 即关注用户的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li><li>用户的粉丝列表，通过 zset 的 <code>reverseRange</code> 获取 value 即粉丝的 userId，再查询出 user，通过 <code>score</code> 获取关注时间。</li><li>列表信息封装在 list 集合中，再将 list 添加到 Model 对象里。</li></ul><hr><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p><strong>为什么要用kafka？</strong></p><p>评论，点赞，关注等事件是非常频繁的操作，我们使用kafka消息队列来实现。</p><p><strong>哪个地方用到了kafka？</strong></p><p>当我们进行点赞，评论，关注请求时，会发送系统通知，告诉用户谁进行了点赞，评论，关注操作。</p><p>在处理这些系统通知信息时，使用到了Kafka消息队列。</p><p><strong>具体做法</strong>：定义了三类不同的主题，点赞一个主题、评论一个主题、关注一个主题。一旦事件触发了就包装成一个消息放入消息队列对应的主题中，而生产者就可以处理后序的业务，不用管消息是如何被消费的，接着消费者从消息队列中读取消息并存入mysql的message表中。</p><p>生产者主动发消息，消费者被动接收消息</p><p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211119215925683.png" alt="image-20211119215925683"></p><p>具体分为三步：</p><ul><li><p>封装一个事件，这个事件包括事件的主题（评论、点赞、关注）、事件发起者、事件接受者。</p></li><li><p>开发生产者</p></li><li><p>开发消费者</p></li></ul><p><strong>首先会封装一个事件对象，</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String topic;  <span class="comment">//事件主题（评论、点赞、关注）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> userId;   <span class="comment">// 事件发起者（谁评论了，谁点赞了）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> entityType;  <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> entityUserId;  <span class="comment">//事件接受者 （评论了谁，点赞了谁）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,object&gt; data;   <span class="comment">// map用于后序功能的拓展</span></span><br></pre></td></tr></table></figure><p><strong>开发事件的生产者</strong><br>向特定的主题（评论，点赞，关注）发送事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//处理事件(发送事件)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">(Event event)</span></span>&#123;</span><br><span class="line">   <span class="comment">//将事件发布到指定的主题</span></span><br><span class="line">   kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>开发事件的消费者</strong><br>使用@KafkaListener注解监听事件，如果监听成功并进行相应的处理，最后调用messageService添加到数据库中，下次用户显示消息列表的时候就可以看到系统消息了。</p><p>我们用的同样是message这个数据表，只不过与发私信中的数据有差别</p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211119221120618.png" alt="image-20211119221120618" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCommentMessage</span><span class="params">(ConsumerRecord record)</span> </span>&#123;</span><br><span class="line">    Event event = JSONObject.parseObject(record.value().toString(), Event.class);   </span><br><span class="line">   <span class="comment">//发送站内的通知</span></span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">    message.setToId(event.getEntityUserId());</span><br><span class="line">    message.setConversationId(event.getTopic());<span class="comment">//comment like follow</span></span><br><span class="line">    message.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">          </span><br><span class="line">    message.setContent(JSONObject.toJSONString(content));</span><br><span class="line"></span><br><span class="line">    System.out.println(content);</span><br><span class="line">    <span class="comment">//调用messageService添加到数据库中</span></span><br><span class="line">    messageService.addMessage(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>触发事件</strong></p><p>创建 EventProducer 事件生产者，新增 <code>fireEvent(Event event)</code> 方法，通过 Event 获取事件类型，并将其封装成 JSON 数据，然后调用注入的 KafkaTemplate 实例的 send 方法发送。</p><p>在 CommentController、LikeControler、FollowController 中注入 EventProducer 实例，分别重构 <code>addComment</code> 方法、<code>like</code> 方法、<code>follow</code> 方法，封装 Event 对象，然后调用 EventProducer 的<code>fireEvent</code> 方法发布通知。。</p><p>而消费事件是被动触发的，只要消费者订阅了这三个主题，就会进行相应的操作并计入数据库中。</p><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p><strong>es介绍：</strong></p><p>Elasticsearch是一个<strong>实时的分布式的搜索引擎</strong>。</p><p>Elasticsearch是<strong>面向文档型数据库</strong>，一条数据就是一个文档，和数据结构mongoDB类似，文档序列化之后是JSON格式，例如一条用户数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;tino&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>:<span class="string">&quot;25&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;department&quot;</span>:<span class="string">&quot;DC&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;hobies&quot;</span>:[</span><br><span class="line">        <span class="string">&quot;sports&quot;</span>,</span><br><span class="line">        <span class="string">&quot;music&quot;</span>,</span><br><span class="line">        <span class="string">&quot;movie&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于oracle/mysql数据库中的一张user表中的一条记录，这user表有name、age、department、hobies字段，而在Elasticsearch中，这是一个文档，而user则是整个文档的一个类型，Elasticsearch和关系型数据库术语的对照基本上是：</p><ul><li> Index：Elasticsearch的Index相当于数据库的Table</li><li> 类型（Type）类型是索引内部的逻辑分区(category/partition)，一个索引内部可定义一个或多个类型(type)。类比传统的关系型数据库领域来说，类型相当于“表”。</li><li> Document：Document相当于数据库的一行记录</li><li>Field：相当于数据库的Column的概念</li></ul><p>Elasticsearch 使用的是标准的 RESTful API 和 JSON，它的交互可以通过HTTP请求，也可以通过java API，如果插入一条记录，可以发送一个HTTP请求来实现：</p><p>更新和查询也是类似的操作。</p><p><strong>基本特征</strong>：</p><ol><li>实现了用于全文检索的<strong>倒排索引</strong>，实现了用于存储数值数据和位置数据的 BKD 树， 以及用于分析的列存储。</li><li>将每个字段编入索引，使其可搜索，提高搜索速度。</li><li>实时分析的分布式引擎，确保故障时仍安全可用。</li><li>可以在承载了 PB （2的50次方个字节，约为1000个TB）级数据的成百上千台服务器上运行。</li><li>可处理多种数据类型，数字、文本、地理位置、结构化、非结构化。</li></ol><p>相比mysql优势：在<strong>模糊查询</strong>和<strong>分词查询</strong>上更有优势，在海量数据的查询下用es更有优势</p><p>mysql也可以模糊查询，但是要明白的是：<code>name like %Java3y%</code>这类的查询是不走<strong>索引</strong>的，不走索引意味着：只要你的数据库的量很大（1亿条），你的查询肯定会是<strong>秒</strong>级别的。</p><p><strong>es倒排索引：</strong></p><ul><li><strong>正排索引</strong>：是以文档对象的唯一 ID 作为索引，以文档内容作为记录的结构。</li><li><strong>倒排索引</strong>：指的是将文档内容中的单词作为索引，将包含该词的文档 ID 作为记录的结构。</li></ul><p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTYwNjIz,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><strong>倒排索引的生成过程：</strong></p><p>举个例子，假设目前有以下两个文档内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">苏州街维亚大厦 </span><br><span class="line">桔子酒店苏州街店</span><br></pre></td></tr></table></figure><p>其处理步骤如下：</p><blockquote><p>1、正排索引给每个文档进行编号，作为其唯一的标识。</p></blockquote><table><thead><tr><th>文档 id</th><th>content</th></tr></thead><tbody><tr><td>1</td><td>苏州街维亚大厦</td></tr><tr><td>2</td><td>桔子酒店苏州街店</td></tr></tbody></table><blockquote><p>2、生成倒排索引：</p></blockquote><ul><li>首先要对字段的内容进行分词，分词就是将一段连续的文本按照语义拆分为多个单词，这里两个文档包含的关键词有：苏州街、维亚大厦…</li><li>然后按照单词来作为索引，对应的文档 id 建立一个链表，就能构成上述的倒排索引结构。</li></ul><table><thead><tr><th>Word（term）</th><th>文档 id（posting list）出现过这个单词的文档id</th></tr></thead><tbody><tr><td>苏州街</td><td>1,2</td></tr><tr><td>维亚大厦</td><td>1</td></tr><tr><td>维亚</td><td>1</td></tr><tr><td>桔子</td><td>2</td></tr><tr><td>酒店</td><td>2</td></tr><tr><td>大赛</td><td>1</td></tr></tbody></table><p>有了倒排索引，能快速、灵活地实现各类搜索需求。整个搜索过程中我们不需要做任何文本的模糊匹配。</p><p>例如，如果需要在上述两个文档中查询 <strong>苏州街桔子</strong> ，可以通过分词后 <strong>苏州街</strong> 查到 1、2，通过 <strong>桔子</strong> 查到 2，然后再进行<strong>取交取并</strong>等操作得到最终结果。</p><p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211122215841822.png" alt="image-20211122215841822"></p><p>搜索服务<br>将帖子保存到Elasticsearch服务器<br>从 Elasticsearch 服务器中删除帖子<br>从 Elasticsearch 服务器搜索帖子<br>发布事件（将发帖或者更改帖子的事件存到kafka中，消费事件并将帖子存到es服务器中）<br>发布帖子时，将帖子异步的提交到Elasticsearch服务器<br>增加评论的时候，将帖子异步的提交到Elasticsearch服务<br>在kafka消费组件中增加一个方法，消费帖子发布事件<br>显示结果<br>在控制器中处理搜索请求，在HTML高亮显示搜索结果</p><ul><li><p>搜索服务</p><ul><li>将帖子保存到Elasticsearch服务器</li><li>从 Elasticsearch 服务器中删除帖子</li><li>从 Elasticsearch 服务器搜索帖子</li></ul></li><li><p>发布事件（将发帖或者更改帖子的事件存到kafka中，消费事件并将帖子存到es服务器中）</p><ul><li>发布帖子时，将帖子异步的提交到Elasticsearch服务器</li><li>增加评论的时候，将帖子异步的提交到Elasticsearch服务</li><li>在kafka消费组件中增加一个方法，消费帖子发布事件</li></ul></li><li><p>显示结果</p><ul><li>在控制器中处理搜索请求，在HTML高亮显示搜索结果</li></ul></li></ul><p><strong>哪里用到了es？</strong></p><p>在进行帖子搜索时，使用到了ES。可用Repository和Template两种方式，由于Repository搜索到的结果（直接返回的post类，方便）没有高亮标签（why），所以使用了template方式重写了mapResults函数，获得了带有高亮标签的post。<br>使用消息队列（kafka）的方式，实现发帖/删帖后ES数据库的自动更新。<br>搜索：定义SearchQuery，确定搜素内容，排序方式，高亮等。接着使用elasticTemplate.queryForPage方法，需要重写mapResults函数，得到高亮数据。</p><h2 id="什么是Spring框架？"><a href="#什么是Spring框架？" class="headerlink" title="什么是Spring框架？"></a>什么是Spring框架？</h2><p>有很多模块组成，利用这些模块可以方便开发工作。这些模块是：核心容器（spring core)/数据访问和集成(Spring JDBC)/Web(Spring Web/MVC)/AOP(Spring Aop)/消息模块/测试模块(Spring Test)等。</p><h2 id="对Spring-IoC的理解"><a href="#对Spring-IoC的理解" class="headerlink" title="对Spring IoC的理解"></a>对Spring IoC的理解</h2><p>IoC的意思是控制反转，是一种设计思想，把需要在程序中手动创建对象的控制权交给了Spring框架。IoC的载体是IoC容器，本质是一个工厂，数据结构上来看是一个Map，用来存放着各种对象。当我们创建一个对象时，只需要配置好配置文件/注解，而不用担心对象是怎么被创建出来的。</p><p>IoC的优点：降低耦合，对象被容器管理需要两份数据：你的对象定义 + 配置文件，对象间的关系体现在配置文件，不会直接产生耦合。</p><h2 id="什么是DAO"><a href="#什么是DAO" class="headerlink" title="什么是DAO"></a>什么是DAO</h2><p>data access object，存放数据库访问对象。</p><h2 id="Spring中关于Bean的注解"><a href="#Spring中关于Bean的注解" class="headerlink" title="Spring中关于Bean的注解"></a>Spring中关于Bean的注解</h2><p>四种常见Bean<br>@Controller @Repository @Service @Component一般来说Bean只会被容器初始化一次，@PostConstruct：初始化前调用 @PreDestroy：销毁之前<br>如何使用Bean<br>bean通过容器管理，不需要我们实例化，如果要使用某个bean，使用依赖注入 @Autowired</p><h2 id="Spring-MVC是什么，是怎样的工作流程"><a href="#Spring-MVC是什么，是怎样的工作流程" class="headerlink" title="Spring MVC是什么，是怎样的工作流程"></a>Spring MVC是什么，是怎样的工作流程</h2><p>服务器分为表现层/业务层/数据层，其中Spring MVC是工作在表现层，作用是接收/解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。</p><p>客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)；<br>DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler；<br>查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理；<br>HandlerAdapter根据Handler来调用真正的Controller；<br>Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View；<br>ViewResolver根据逻辑view找到实际view；<br>DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者。<br>C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。<br>M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。<br>V - View：视图。返回给客户看的结果。</p><h2 id="DispatcherServlet处理流程？"><a href="#DispatcherServlet处理流程？" class="headerlink" title="DispatcherServlet处理流程？"></a>DispatcherServlet处理流程？</h2><p>DispatcherServlet 处理流程：<br>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 DispatcherServlet时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：</p><p>Tomcat 启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；<br>客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；<br>DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；<br>DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；<br>执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用<br>HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的<br>postHandler() 方法；<br>利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面；<br>最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。</p><h2 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h2><p>目的：让未登录用户不能访问某些页面<br>原理：在方法前标注自定义注解，拦截所有的请求，只处理带有该注解的方法。</p><h2 id="什么是SSM框架？"><a href="#什么是SSM框架？" class="headerlink" title="什么是SSM框架？"></a>什么是SSM框架？</h2><p>包括Spring + Spring MVC(和Spring天生集成) + MyBatis（帮你和数据库打交道的框架，简单的设置，你就可以像Java一样，操作数据库了）</p><h2 id="怎么实现注册功能的？"><a href="#怎么实现注册功能的？" class="headerlink" title="怎么实现注册功能的？"></a>怎么实现注册功能的？</h2><p>根据请求来拆解功能<br>1，打开注册网页<br>2，把注册的信息发送给服务器（点注册）<br>3，把激活邮件发送给邮箱<br>4，利用激活链接打开网页</p><p>每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层</p><h2 id="什么是Interceptor，在项目的哪里使用到了Interceptor"><a href="#什么是Interceptor，在项目的哪里使用到了Interceptor" class="headerlink" title="什么是Interceptor，在项目的哪里使用到了Interceptor?"></a>什么是Interceptor，在项目的哪里使用到了Interceptor?</h2><p>Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。本项目中，每次请求都会检查request中的login_ticket，把找到的user信息存放在协程中，并在完成处理后，自动释放。（方便的进行用户信息取用）</p><h2 id="使用什么技术生成验证码"><a href="#使用什么技术生成验证码" class="headerlink" title="使用什么技术生成验证码?"></a>使用什么技术生成验证码?</h2><p>使用Kaptcha包，可随机生成字符和图片。</p><h2 id="如何检查登陆状态"><a href="#如何检查登陆状态" class="headerlink" title="如何检查登陆状态"></a>如何检查登陆状态</h2><p>加拦截器注解。</p><h2 id="如何实现敏感词过滤"><a href="#如何实现敏感词过滤" class="headerlink" title="如何实现敏感词过滤"></a>如何实现敏感词过滤</h2><p>使用前缀树（字典树）存储敏感词，对text中的敏感词实现替换。</p><h2 id="什么是Ajax，应用在项目哪些地方？"><a href="#什么是Ajax，应用在项目哪些地方？" class="headerlink" title="什么是Ajax，应用在项目哪些地方？"></a>什么是Ajax，应用在项目哪些地方？</h2><p>ajax指异步的json和xml技术，不是一门新的语言，而是使用现有技术的新方法。最大的特点是：不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。<br>项目中：帖子发布成功/失败的提示，使用到ajax</p><h2 id="什么是事务，事务的四大特性。"><a href="#什么是事务，事务的四大特性。" class="headerlink" title="什么是事务，事务的四大特性。"></a>什么是事务，事务的四大特性。</h2><p>定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>事物的四大特性-ACID：<br>A：原子性，事务是最小的执行单位，不允许被分割，事务的全部操作要么全部提交成功，要么全部失败回滚。<br>C：一致性，数据库在事务执行前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果相同。<br>I ：隔离性，一个事务所作的修改在最终提交前，对其他事务是不可见的。避免多个事物交叉执行所导致的数据不一致问题。<br>D（Duability）：持久性，一旦事务提交，所做的修改将被永远保存到数据库中。即使系统发生崩溃，事务执行的结构也不能丢失。</p><h2 id="怎么利用Spring实现事务管理"><a href="#怎么利用Spring实现事务管理" class="headerlink" title="怎么利用Spring实现事务管理"></a>怎么利用Spring实现事务管理</h2><p>Spring管理事务忽略了底层数据库的结构，非常方便。有两种方式：注解（类型，传播方式）/编程式事务（override)。</p><h2 id="是怎样实现统一捕获异常的？"><a href="#是怎样实现统一捕获异常的？" class="headerlink" title="是怎样实现统一捕获异常的？"></a>是怎样实现统一捕获异常的？</h2><p>在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层（controller)统一处理错误即可。<br>方法：在controller中加上advice包，并通过注解@ControllerAdvice和@ExceptionHandler，统一捕获异常。</p><h2 id="是怎样实现统一记录日志的？"><a href="#是怎样实现统一记录日志的？" class="headerlink" title="是怎样实现统一记录日志的？"></a>是怎样实现统一记录日志的？</h2><p>如果我们不统一记录日志时，就需要在每个业务执行方法中加上处理日志的功能，那么业务功能就与记录日志功能耦合了，并且要重复很多代码，为了复用代码，我们将每个业务组件中记录日志的功能抽取出来，作为一个aspect，</p><p>使用了AOP技术（面向切面编程），这里使用到的是SpringAOP。 AOP技术能够将哪些与业务，但是为业务模块共同调用的逻辑或责任（比如事务处理，日志记录，权限控制等），封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和维护性。 SpringAOP本质上基于动态代理，当要代理的对象实现了某接口，会使用JDK动态代理，在运行时通过创建接口的代理实例，织入代码。当要代理的对象没有实现接口，则使用Cglib技术（编译时增强），通过子类代理织入代码。</p><p>前置通知</p><p>@Aspect 标记ServiceLogAspect为切面类，切面类中的方法就是业务模块中共同的切入模块。<br>@Pointcut标记service的所有方法，表示将代码<br>@Before表示在所有业务层方法直接执之前记录日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLogAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.wsc.community.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用户[1.2.3.4],在[xxx],访问了[com.nowcoder.community.service.xxx()].</span></span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">       <span class="keyword">if</span>(attributes==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        String ip = request.getRemoteHost();</span><br><span class="line">        String now = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        String target = joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;.&quot;</span> + joinPoint.getSignature().getName();</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;用户[%s],在[%s],访问了[%s].&quot;</span>, ip, now, target));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211119195313765.png" alt="image-20211119195313765" style="zoom:67%;" /><h2 id="怎么往Spring框架中配置Redis，介绍常见的Redis操作"><a href="#怎么往Spring框架中配置Redis，介绍常见的Redis操作" class="headerlink" title="怎么往Spring框架中配置Redis，介绍常见的Redis操作"></a>怎么往Spring框架中配置Redis，介绍常见的Redis操作</h2><p>我们使用redisTemplate来操作redis。</p><p>常见操作<br>string类型：redisTemplate.opsForValue().set(redisKey, 1)，redisTemplate.opsForValue().get(redisKey)， redisTemplate.opsForValue().increment(redisKey)，<br>Hash类型：redisTemplate.opsForHash().put(redisKey, “id”, 1)， 还有get等操作<br>List类型：redisTemplate.opsForList().leftPush(redisKey, 101)， 还有size, index, range， leftPop等操作<br>Set类型：add, size, pop, members等操作<br>Zset类型：redisTemplate.opsForZSet().add(redisKey, “Linda”, 92), 有socre，rank，reverseRank， range等操作<br>操作key：可以delete，以及设置过期时间<br>同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）</p><h2 id="项目中Redis的作用"><a href="#项目中Redis的作用" class="headerlink" title="项目中Redis的作用"></a>项目中Redis的作用</h2><p>1、事务操作：redisTemplate直接调用opsfor…来操作redis数据库，每执行一条命令是要重新拿一个连接，因此很耗资源，让一个连接直接执行多条语句的方法就是使用SessionCallback，同样作用的还有RedisCallback，但不常用。<br>2、使用redis存储验证码：</p><p>因为验证码需要频繁的进行访问与刷新，因此对性能的要求较高；<br>验证码不需要永久保存，通常在很短的时间后就会失效；<br>分布式部署的时候，存在session共享的问题。<br>3、使用redis存储登录凭证：<br>因为后台在每次处理请求的时候都要查询用户的登录凭证，访问的频率非常高，因此需要使用redis存储。<br>4、使用redis缓存用户信息：<br>因为后台在每次处理请求的时候都要根据用户的凭证用户信息，访问的频率非常高。<br>5、Redis可以使用zset对需要排序的数据进行自定义的排序。</p><p>怎样存储的点赞/关注/缓存用户数据<br>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score<br>缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）</p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。消息队列的主要功能（优点）在于：</p><p>解耦：生产者只负责把消息放在队列中，而不用关心谁去使用它。<br>异步：生产者把消息放在队列中后即可返回，而不用一个个的通知消费者去执行，消费者是异步的获取消息的。<br>限流：生产者一次性产生大量的数据时，不会给消费者造成压力，消费者可以根据自身的能力，去消息队列中取数据。<br>消息队列作为信息传递的中间件，需要注意哪些问题？<br>1、高可用：因为消息队列如果宕机，会导致整个系统不可用。（分布式/集群的现成支持）<br>2、数据持久化：防止数据丢失<br>3、如何取数据：消息队列主动通知或者消费者轮询。</p><p>Java中的blockingqueue，可以提供线程间的消息队列<br>BQ也是生产者与消费者模式，属于点对点式消息队列？（一个消息只会被消费一次）Blocking Queue构建了一个桥梁，能够解决生产速度/消费速度不匹配问题。阻塞的时候只是在那里等着，但是不会占用CPU资源，对性能不会有影响。</p><h2 id="什么是Kafka，有哪些功能和应用场景？"><a href="#什么是Kafka，有哪些功能和应用场景？" class="headerlink" title="什么是Kafka，有哪些功能和应用场景？"></a>什么是Kafka，有哪些功能和应用场景？</h2><p>Kafka为分布式流处理平台。流处理是指对不断产生的动态数据流实时处理，基于分布式内存，具有数据处理快速，高效，低延迟的特性。</p><p>Kafka简介：Kafka是一种消息队列，主要用来处理大量数据状态下的消息队列，一般用来做日志的处理，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景<br>特点：</p><p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。<br>可扩展性：kafka集群支持热扩展<br>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失<br>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）<br>高并发：支持数千个客户端同时读写<br>Kafka主要提供的功能包括：消息系统，日志收集，用户行为跟踪，流式数据处理。</p><h2 id="Kafka的基础架构"><a href="#Kafka的基础架构" class="headerlink" title="Kafka的基础架构"></a>Kafka的基础架构</h2><p>Producer：消息生产者，向Kafka中发布消息的角色。<br>Consumer：消息消费者，即从Kafka中拉取消息消费的客户端。<br>Consumer Group：消费者组，消费者组则是一组中存在多个消费者，消费者消费Broker中当前Topic的不同分区中的消息，消费者组之间互不影响，所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。某一个分区中的消息只能够一个消费者组中的一个消费者所消费<br>Broker：经纪人，一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。<br>Topic：主题，可以理解为一个队列，生产者和消费者都是面向一个Topic<br>Partition：分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列(分区有序，不能保证全局有序)<br>Replica：副本Replication，为保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka可以正常的工作，Kafka提供了副本机制，一个Topic的每个分区有若干个副本，一个Leader和多个Follower<br>Leader：每个分区多个副本的主角色，生产者发送数据的对象，以及消费者消费数据的对象都是Leader。<br>Follower：每个分区多个副本的从角色，实时的从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。</p><p>Kafka的消息模型，以及常见术语<br>消息模型：发布-订阅模型，消费者订阅了某一主题（topic）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。<br>Topic：主题，类似于文件夹，用来存放不同的数据。<br>Partition：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。<br>Offset：消息在Partition中的存放位置。<br>Broker：可以理解为kafka集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着topic1的leader， topic2的follower等等。</p><h2 id="在项目哪里用到了Kafka？"><a href="#在项目哪里用到了Kafka？" class="headerlink" title="在项目哪里用到了Kafka？"></a>在项目哪里用到了Kafka？</h2><p>当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞/评论/关注功能对应的Controller使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。</p><h2 id="什么是ElasticSearch，存储原理，功能，特点"><a href="#什么是ElasticSearch，存储原理，功能，特点" class="headerlink" title="什么是ElasticSearch，存储原理，功能，特点"></a>什么是ElasticSearch，存储原理，功能，特点</h2><p>概念：ES是一个基于lucene构建的，分布式的，RESTful的开源全文搜索引擎。<br>存储原理：数据按照Index – Type – Document – 字段四级存储，其中Index对应数据库，Type对应表，Document为搜索的原子单位，包含一个或多个容器，基于JSON表示。字段是指JSON中的每一项组成，类似于数据库中的行/列。Mapping是文档分析过滤后的结果，根据用户自定义，将某些文字过滤掉，类似于表结构定义DDL？？。同时ES也和分布式数据库一样，支持shard的replication。<br>功能：<br>1、分布式的搜索引擎和数据分析引擎<br>2、全文检索，结构化检索，数据分析。<br>3、对海量数据进行近实时的处理<br>特点：<br>1、可以作为分布式集群处理PB级别的数据，也可单机使用。<br>2、不是特有技术，而是将分布式+全文搜索（lucene) + 数据分析合并在一起。<br>3、操作简单，作为传统数据库的补充，提供了数据库所不具备的很多功能。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>records = load ‘/home/stu2018210945/anime.csv’ as (id:int, name:chararray, genre:chararray, type:chararray, episodes:int, rating:float, members:int);</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录仿牛客论坛记录一些不懂的地方&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>kafka相关</title>
    <link href="http://example.com/2021/11/07/kafka%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/11/07/kafka%E7%9B%B8%E5%85%B3/</id>
    <published>2021-11-07T02:26:32.000Z</published>
    <updated>2021-11-23T14:46:38.167Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一点kafka相关面试题</p><p>guide哥、3y哥，敖丙哥，入门必看，接着再看其他文章深入理解</p></blockquote><a id="more"></a><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列的两种模型"><a href="#消息队列的两种模型" class="headerlink" title="消息队列的两种模型"></a>消息队列的两种模型</h3><p>消息队列有两种模型：<strong>队列模型</strong>和<strong>发布/订阅模型</strong>。</p><p><strong>队列模型</strong></p><p>生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者， 但是每条消息只能被一个消费者消费。如果我们想要一条消息被多个消费者消费，就需要用到发布-订阅模型</p><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/640.webp" alt="图片"></p><p><strong>发布/订阅模型</strong></p><p><strong>为了解决一条消息能被多个消费者消费的问题</strong>，就出现了发布/订阅模型。该模型是将消息发往一个<code>Topic</code>即主题中，所有订阅了这个 <code>Topic</code> 的消费者都能消费这条消息。</p><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107224113649.png" alt="image-20211107224113649"></p><p>消息队列的应用场景：<strong>解耦、异步、削峰</strong></p><h3 id="为什么要使用消息队列？（优点）"><a href="#为什么要使用消息队列？（优点）" class="headerlink" title="为什么要使用消息队列？（优点）"></a><strong>为什么要使用消息队列？</strong>（优点）</h3><p>主要从消息队列的使用场景来分析，比如说在哪些场景下消息队列会带来好处</p><p><strong>解耦</strong></p><p>A 系统发送数据到 BCD 三个系统，我们把BCD三个系统的代码写入到A中，如果之后不需要发送数据给C系统，或者说还需要发送数据给新的系统，那么就需要反复调整架构，修改代码，因为他们的耦合性很高。</p><p>我们现在使用MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据就订阅主题进行消费。如果某个系统不需要这条数据了，就取消对这个主题的订阅停止消费即可。这样下来，A 系统就不需要去考虑要给谁发送数据，实现了系统的解耦。</p><p><strong>异步</strong></p><p>以商品下单作为例子，比如说我们下单买下商品后，还需要通过优惠券系统花时间扣除优惠券，通过积分系统花时间扣除积分，还需要花时间给用户发短信等等流程。但如果按照这个链路的话用户花的时间很长。</p><p>我们可以采用MQ，当用户支付成功后，采用异步的方式，扣除优惠券的同时增减积分啊，还可以同时发个短信，这样的话花的时间就少很多了。而这些步骤用多线程的方式，我们需要调用这些操作的接口，耦合性很高，出了问题也不好排查</p><p>所以通常使用MQ的方式来解决问题。你下单了，你就把你<strong>支付成功的消息告诉别的系统</strong>，他们收到了去处理就好了，你只用走完自己的流程，把自己的消息发出去，那后面要接入什么系统简单，直接订阅你发送的支付成功消息，你支付成功了我<strong>监听就好了</strong>。</p><p><strong>那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？</strong></p><p>问题是个好问题，但是没必要考虑，业务系统本身就是自己的开发人员维护的，你积分扣失败关我下单的什么事情？你管好自己下单系统的就好了。</p><p><strong>削峰</strong></p><p>比如说在一个系统中数据库平常只能处理1k条请求，但是遇到秒杀的情况请求会暴增，这时候数据库一下子处理不了这么多请求就会导致系统崩溃。</p><p>我们可以将请求写入MQ中，然后系统按照能够承载的负荷拉取请求，这样有的请求可能会延迟一段时间才能得到处理，但是系统至少不会崩溃，可以在请求高峰期过后慢慢消化掉MQ中的请求。</p><h3 id="MQ缺点"><a href="#MQ缺点" class="headerlink" title="MQ缺点"></a>MQ缺点</h3><p><strong>高可用</strong>、消息<strong>重复消费</strong>、<strong>消息丢失</strong>、<strong>消息的顺序消费</strong>、数据一致性（消费者消费完后是否成功了？）</p><p>缺点有以下几个：</p><ul><li><strong>系统可用性降低</strong><br>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以<a href="https://github.com/heqiyoujing/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md">点击这里查看</a>。</li><li><strong>系统复杂度提高</strong><br>硬生生加个 MQ 进来，你怎么<a href="https://github.com/heqiyoujing/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md">保证消息没有重复消费</a>？怎么<a href="https://github.com/heqiyoujing/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li><li><strong>一致性问题</strong><br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</li></ul><h3 id="有哪些消息中间件呢？"><a href="#有哪些消息中间件呢？" class="headerlink" title="有哪些消息中间件呢？"></a><strong>有哪些消息中间件呢？</strong></h3><p><strong>Kafka、ActiveMQ、RabbitMQ、RocketMQ</strong></p><p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka </p><p>RocketMQ是ali研发的具有高吞吐量的MQ</p><h2 id="Kafka是什么"><a href="#Kafka是什么" class="headerlink" title="Kafka是什么"></a>Kafka是什么</h2><p>Kafka是一个分布式的流处理平台。</p><p>主要功能：（官网上对它有介绍）</p><p>1.消息队列：发布和订阅消息</p><p>2.将消息流存储下来：Kaka会把消息持久化到磁盘，有效避免了消息丢失的风限。</p><p>3.流式处理平台：在消息发布的时候进行处理，Kafka提供了一个完整的流式处理类库。</p><p>总的来说就是传输数据，处理数据的功能</p><h2 id="Kafka消息队列入门"><a href="#Kafka消息队列入门" class="headerlink" title="Kafka消息队列入门"></a>Kafka消息队列入门</h2><p>生产者、消费者、消费者群组、broker、topic、partition、leader、follwer。</p><p>把消息放到队列里边的叫<strong>生产者</strong>，从队列里边消费的叫<strong>消费者</strong>。</p><p><strong>Broker</strong>：我们把kafka集群中一个kafka服务器实例叫做Broker</p><p><strong>Topic</strong>：简单理解为存储不同类型消息的队列，一种类型消息队列就是一个topic。生产者将消息发送到特定的topic，消费者通过订阅特定的topic来消费消息</p><p><strong>Partition</strong>：为了提高系统的吞吐量，我们会对topic进行分区，分为一个个的partition。Partition属于 Topic的一部分。一个 Topic有多个 Partition，并且同一 Topic下的 Partition可以分布在不同的 Broker上。</p><p>kafka的<strong>多副本机制</strong>-》引出<strong>leader</strong>和<strong>follwer。</strong></p><p>每个partition在不同broker中有备份，我们称为follwer，而主partion称为leader。生产者和消费者只和leader进行交互，如果leader所在的broker出现了故障，就会从follwer中推选出一个作为leader。</p><p><strong>问题：Kafka的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong><br>1.Kafka通过给特定Topic指定多个 Partition，而各个 Partition可以分布在不同的 Broker上，这样便能提供比较好的并发能力（<strong>负载均衡</strong>）。<br>2.Partition可以指定对应的 Replica数，这也极大地提高了消息存储的安全性，提高了容灾能力，不过也相应的增加了所需要的存储空间。（<strong>数据备用</strong>）</p><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107225518472.png" alt="image-20211107225518472"></p><p>一台Kafka服务器叫做<strong>Broker</strong>，Kafka集群就是多台Kafka服务器：</p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107225558077.png" alt="image-20211107225558077" style="zoom: 50%;" /><p>一个topic会分为多个partition，实际上partition会<strong>分布</strong>在不同的broker中：</p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107225658286.png" alt="image-20211107225658286" style="zoom:50%;" /><p>现在我们已经知道了往topic里边丢数据，实际上这些数据会分到不同的partition上，这些partition存在不同的broker上。分布式肯定会带来问题：“万一其中一台broker(Kafka服务器)出现了故障怎么办？”</p><p>每个partition在不同broker中有备份，我们称为follwer，而主partion称为leader。生产者和消费者只和leader进行交互，如果leader所在的broker出现了故障，就会从follwer中推选出一个作为leader。</p><p>现在我们有三个partition，分别存在三台broker上。每个partition都会备份，这些备份散落在<strong>不同</strong>的broker上。</p><p>在一个消费者组中，<strong>每个消费者去消费一个分区</strong>（也是为了提高吞吐量）</p><ul><li>如果消费者组中的某个消费者挂了，那么其中一个消费者可能就要消费两个partition了</li><li>如果只有三个partition，而消费者组有4个消费者，那么一个消费者会空闲</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107230812009.png" alt="image-20211107230812009"></p><p>如果一个消费者组中的某个消费者挂了，那挂掉的消费者所消费的分区可能就由消费组中存活的消费者消费。那<strong>存活的消费者是如何知道挂掉的消费者消费到哪了？</strong></p><p>这里要引出<code>offset</code>了，Kafka就是用<code>offset</code>来表示消费者的消费进度到哪了，每个消费者会都有自己的<code>offset</code>。说白了<code>offset</code>就是表示消费者的<strong>消费进度</strong>。</p><p>在以前版本的Kafka，这个<code>offset</code>是由Zookeeper来管理的，后来Kafka开发者认为Zookeeper不合适大量的删改操作，于是把<code>offset</code>在broker以内部topic(<code>__consumer_offsets</code>)的方式来保存起来。</p><p>每次消费者消费的时候，都会提交这个<code>offset</code>，Kafka可以让你选择是自动提交还是手动提交。</p><p>既然提到了Zookeeper，那就多说一句。Zookeeper虽然在新版的Kafka中没有用作于保存客户端的<code>offset</code>，但是Zookeeper是Kafka一个重要的依赖。</p><ul><li>探测broker和consumer的添加或移除。</li><li>负责维护所有partition的领导者/从属者关系（主分区和备份分区），如果主分区挂了，需要选举出备份分区作为主分区。</li><li>维护topic、partition等元配置信息</li></ul><p><a href="https://www.cnblogs.com/heqiyoujing/p/10926087.html">https://www.cnblogs.com/heqiyoujing/p/10926087.html</a>  写得有点详细关于如何处理消息队列的问题</p><h2 id="Zookeeper在Kafka中的作用"><a href="#Zookeeper在Kafka中的作用" class="headerlink" title="Zookeeper在Kafka中的作用"></a>Zookeeper在Kafka中的作用</h2><p>Zookeeper为分布式消息队列框架提供开源的分布式<strong>配置服务、同步服务和命名注册。</strong></p><p>ZooKeeper主要为 Kafka提供 <strong>Broker和 Topic的注册</strong>以及<strong>多个 Partition的负载均衡</strong>等功能</p><p>1.<strong>Broker注册</strong>：在 Zookeeper上会有一个专门用来进行 Broker服务器列表记录的节点。每个 Broker在启动时，都会到 Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点。每个 Broker就会将自己的P地址和端口等信息记录到该节点中去</p><p>2.<strong>Topic注册</strong>：在Kaka中，同一个 Topic的消息会被分成多个分区并将其分布在多个Broker上，这些分区信息及与 Broker的对应关系也都是由 Zookeeper在维护。比如我创建了一个名字为 my-topic的主题并且它有两个分区，对应到z0 keeper中会创建这些文件XE：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></p><p>3.<strong>负载均衡</strong>：上面也说过了 Kafka通过给特定 Topic指定多个 Partition，而各个 Partition可以分布在不同的 Broker上，这样便能提供比较好的并发能力。对于同一个 Topic的不同Partition，Kafka会尽力将这些 Partition分布到不同的 Broker服务器上。当生产者产生消息后也会尽量投递到不同 Broker的 Partition里面。当 <strong>Consumer消费的时候，Zookeeper可以根据当前的 Partition数量以及 Consumer数量来实现动态负载均衡。</strong></p><h2 id="如何保证消息的有序性？"><a href="#如何保证消息的有序性？" class="headerlink" title="如何保证消息的有序性？"></a>如何保证消息的有序性？</h2><p>我们的消息都是发送给topic，而topic由多个partition组成并分散到不同的broker中，每个partition类似于一个队列。</p><p>kafka每次添加消息都添加到partition的尾部。这样能保证Partition中的消息有序，而不能保证Topic中不同的 Partition的有序。</p><blockquote><p>消息在被追加到 Partition（分区）的时候都会分配一个特定的偏移量（offset）。Kafka通过偏移量（offset）来保证消息在分区内的顺序性。 </p></blockquote><ul><li><p>因此我们可以用一种简单的方式：1个Topic只对应一个 Partition，就不用担心topic中不同partition的顺序问题。</p></li><li><p>还可以这样：将要求有序的消息发送到指定的partition，这样消费者每次从指定的partition中取也可以保证消息的有序性。</p></li></ul><h2 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a>如何保证消息不丢失？</h2><p><strong>生产者丢失消息</strong></p><p>生产者发送消息至<code>Broker</code>，需要处理<code>Broker</code>的响应</p><p><strong>kafka丢失消息</strong></p><p><code>Broker</code>需要控制响应的时机，单机情况下是消息刷盘后返回响应，集群多副本情况下，即发送至两个副本及以上的情况下再返回响应。</p><p><strong>消费者丢失消息</strong></p><p>你需要考虑拿到消息放在内存之后消费者就宕机了怎么办。所以我们应该在<strong>消费者真正执行完业务逻辑之后，再发送给<code>Broker</code>消费成功</strong>，这才是真正的消费了。</p><p>所以只要我们在消息业务逻辑处理完成之后再给<code>Broker</code>响应，那么消费阶段消息就不会丢失。</p><h2 id="如何保证消息队列高可用"><a href="#如何保证消息队列高可用" class="headerlink" title="如何保证消息队列高可用"></a>如何保证消息队列高可用</h2><p>​    将partition备份到多个broker中</p><h2 id="如何保证消息不被重复消费？"><a href="#如何保证消息不被重复消费？" class="headerlink" title="如何保证消息不被重复消费？"></a><strong>如何保证消息不被重复消费？</strong></h2><p>假设我们消费者消费完消息后，此时需要更新<code> offset</code>了，然后这个消费者挂了，另一个消费者顶上，拿到了还没更新的<code>offset</code>，于是又重新消费上一个消息</p><p>可以看到正常业务而言<strong>消息重复是不可避免的</strong>，因此我们只能从<strong>另一个角度</strong>来解决重复消息的问题。</p><p>关键点就是<strong>幂等</strong>。既然我们不能防止重复消息的产生，那么我们只能在业务上处理重复消息所带来的影响。</p><p><strong>幂等：</strong></p><p>幂等是数学上的概念，我们就理解为同样的参数多次调用同一个接口和调用一次产生的结果是一致的。</p><p>例如这条 SQL<br><code>update t1 set money = 150 where id = 1 and money = 100;</code> 执行多少遍<code>money</code>都是150，这就叫幂等。</p><p>因此需要改造业务处理逻辑，使得在重复消息的情况下也不会影响最终的结果。</p><p>1）比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧</p><p>2）比如你是写redis，那没问题了，反正每次都是set，天然幂等性</p><p>3）比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</p><p>基本上就这么几个套路，<strong>真正应用到实际中还是得看具体业务细节</strong>。</p><h2 id="Zookeeper是什么？"><a href="#Zookeeper是什么？" class="headerlink" title="Zookeeper是什么？"></a>Zookeeper是什么？</h2><p>有使用过的，使用ZooKeeper作为<strong>dubbo的注册中心</strong>，使用ZooKeeper实现<strong>分布式锁</strong>。</p><p>ZooKeeper，它是一个开放源码的<strong>分布式协调服务</strong>，它是一个集群的管理者，它将简单易用的接口提供给用户。</p><p><strong>可以基于Zookeeper 实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能</strong></p><p>Zookeeper的<strong>用途</strong>：命名服务、配置管理、集群管理、分布式锁、队列管理</p><p><strong>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。</strong> 服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。</p><p>ZooKeeper的视图数据结构，很像Unix文件系统，也是树状的，这样可以确定每个路径都是唯一的。zookeeper的节点统一叫做<strong>znode</strong>，它是可以通过<strong>路径来标识</strong>，结构图如下： <img src="/images/kafka%E7%9B%B8%E5%85%B3/8d7058978e614f7f8ee4832cb3b9c7cbtplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h3 id="znode的4种类型"><a href="#znode的4种类型" class="headerlink" title="znode的4种类型"></a>znode的4种类型</h3><p>根据节点的生命周期，znode可以分为4种类型，分别是持久节点（PERSISTENT）、持久顺序节点（PERSISTENT_SEQUENTIAL）、临时节点（EPHEMERAL）、临时顺序节点（EPHEMERAL_SEQUENTIAL）</p><ul><li><strong>持久节点</strong>（PERSISTENT）</li></ul><blockquote><p>这类节点被创建后，就会一直存在于Zk服务器上。直到手动删除。</p></blockquote><ul><li><strong>持久顺序节点</strong>（PERSISTENT_SEQUENTIAL）</li></ul><blockquote><p>它的基本特性同持久节点，不同在于增加了顺序性。父节点会维护一个自增整性数字，用于子节点的创建的先后顺序。</p></blockquote><ul><li><strong>临时节点</strong>（EPHEMERAL）</li></ul><blockquote><p>临时节点的生命周期与客户端的会话绑定，一旦客户端会话失效（非TCP连接断开），那么这个节点就会被自动清理掉。zk规定临时节点只能作为叶子节点。</p></blockquote><ul><li><strong>临时顺序节点</strong>（EPHEMERAL_SEQUENTIAL）</li></ul><blockquote><p>基本特性同临时节点，添加了顺序的特性。</p></blockquote><h3 id="znode节点上的监听机制"><a href="#znode节点上的监听机制" class="headerlink" title="znode节点上的监听机制"></a>znode节点上的监听机制</h3><p>Zookeeper 允许客户端向服务端的某个Znode注册一个Watcher监听，可以理解为Watcher就是客户端注册在某个Znode上的触发器，当这个Znode节点发生变化时（增删改查），就会触发Znode对应的注册事件，注册的客户端就会收到通知，然后做出业务的改变。</p><p><strong>监听触发流程：</strong></p><ul><li><p>ZooKeeper的Watcher机制主要包括客户端线程、客户端 WatcherManager、Zookeeper服务器三部分。</p></li><li><p>客户端向ZooKeeper服务器注册Watcher的同时，会将Watcher对象存储在客户端的WatchManager中。</p></li><li><p>当zookeeper服务器触发watcher事件后，会向客户端发送通知， 客户端线程从 WatcherManager 中取出对应的 Watcher 对象来执行回调逻辑</p></li></ul><h2 id="CAP定理是什么？"><a href="#CAP定理是什么？" class="headerlink" title="CAP定理是什么？"></a>CAP定理是什么？</h2><p>指的是在一个分布式系统中，Consistency（一致性）、</p><p>Availability（可用性）、Partitiontolerance（分区容错性），三者不可兼得，最多只可以同时实现两个。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><strong>实现分布式锁的三种方法</strong>：mysql、redis、Zookeeper</p><p>应用在单机部署的情况下，要保证资源在同一时刻只能被一个线程战友，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成<strong>分布式集群系统</strong>后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就<strong>需要一种跨机器的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题！</p><p><strong>分布式锁一般有如下的特点</strong>：</p><ul><li><strong>互斥性</strong>： 同一时刻只能有一个线程持有锁</li><li><strong>可重入性</strong>： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁</li><li><strong>锁超时</strong>：和J.U.C中的锁一样支持锁超时，防止死锁</li><li><strong>高性能和高可用</strong>： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效</li><li><strong>具备阻塞和非阻塞性</strong>：能够及时从阻塞状态中被唤醒</li></ul><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p><strong>获取锁</strong>：（假设共享资源是某个方法）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。</p><p><strong>释放锁</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">&#x27;method_name&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>存在问题</strong>：</p><p>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。<br>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。<br>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。<br>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p><p><strong>解决方案</strong>：<br>     1、数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。<br>     2、没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>     3、非阻塞的？搞一个while循环，直到insert成功再返回成功。<br>     4、非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p>谈起redis锁，下面三个，算是出现最多的高频词汇：</p><ul><li><strong>setnx</strong></li><li><strong>redLock</strong></li><li><strong>redisson</strong></li></ul><p><strong>setnx</strong></p><p>推荐使用set命令，后面跟上ex 和 nx 参数，即要设定过期时间，防止客户端还没释放锁就挂掉了，其他的客户端就抢不到锁了。</p><p>可以直接通过 <code>set key value px milliseconds nx</code> 命令实现加锁， 通过Lua脚本实现解锁</p><p>解释：ex：多少秒过期 ；px：多少毫秒过期 ； nx：如果键不存在则创建成功，否则失败</p><p><strong>redLock</strong></p><p>源码中<strong>加锁/释放锁</strong>操作都是用<strong>lua</strong>脚本完成的，封装的非常完善，开箱即用。</p><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</li></ol><p><strong>redisson</strong></p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a><strong>Zookeeper</strong></h3><p>Zookeeper使用<strong>临时顺序节点</strong>特性实现分布式锁的。</p><ul><li>获取锁过程 （创建临时节点，检查序号最小，其他的节点监听前一个节点）</li><li>释放锁 （删除临时节点，监听通知）</li></ul><h4 id="获取锁过程"><a href="#获取锁过程" class="headerlink" title="获取锁过程"></a>获取锁过程</h4><ul><li>当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点/locks。如果它（Client1）想获得锁，需要在locks节点下创建一个顺序节点lock1.如图</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/39e5ee84f901453fb894600c331693d6tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>接着，客户端Client1会查找locks下面的所有临时顺序子节点，判断自己的节点lock1是不是排序最小的那一个，如果是，则成功获得锁。</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/e958178a196742b480a20dff85dfef4ftplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点lock2</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/34a3a0f7221b4de79e1ed5595d7c177ctplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/a17880856e1546bba4f2571dbf8b3b38tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/abda17df527b4dbe8faa7e3a3a9e859etplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/5a8725119723434daddca761b0d7be83tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>我们再来看看释放锁的流程，zookeeper的<strong>客户端业务完成或者故障</strong>，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令 <img src="/images/kafka%E7%9B%B8%E5%85%B3/ecf2bec179f64ef79b180f66a327e634tplv-k3u1fbpfcp-watermark.awebp" alt="img"> 如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的 <img src="/images/kafka%E7%9B%B8%E5%85%B3/e87703be60a3407e9e570c86bd4c180dtplv-k3u1fbpfcp-watermark.awebp" alt="img"> lock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。 <img src="/images/kafka%E7%9B%B8%E5%85%B3/be3c7146f2934dd69a598cdf974ab390tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~</p><p><strong>从性能角度（从高到低）:</strong> 缓存 &gt; Zookeeper &gt;= 数据库</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录一点kafka相关面试题&lt;/p&gt;
&lt;p&gt;guide哥、3y哥，敖丙哥，入门必看，接着再看其他文章深入理解&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>11.01</title>
    <link href="http://example.com/2021/11/01/11-01/"/>
    <id>http://example.com/2021/11/01/11-01/</id>
    <published>2021-11-01T13:26:39.000Z</published>
    <updated>2022-02-20T01:57:35.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>呱呱呱</p></blockquote><a id="more"></a><p>down了down了。</p><p>其实也很正常，你个非科班的花俩月时间（而且还是断断续续的），就能找到好实习，如果有这么简单，要么你就是神仙，要么你当那些科班的学了好几年的是傻子呀~</p><p>不过话说回来，这段时间对于一些基础的知识认识更加清晰了，也积累了一些面试的经验（被面试毒打），总归是很不错的。</p><p>不免有一丝丝动摇了我未来的职业规划。</p><p>以后再说吧，总之还没有结束呢，还有一堆简历在池子里，看能不能被捞吧。。。</p><hr><p>虽然但是，为什么字节一面还给我过了。迷。。</p><p>准备接受第二顿毒打</p><hr><p>！！为啥字节二面也过了。。许愿三面过</p><hr><p>三面g</p><hr><p>读书能让人的心静下来，不要带着压力带着太强的目的性去读书，就会很快乐。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;呱呱呱&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis相关</title>
    <link href="http://example.com/2021/10/30/Redis%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/30/Redis%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-30T01:52:52.000Z</published>
    <updated>2021-11-24T02:17:44.420Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一点Redis相关面试题</p></blockquote><a id="more"></a><p><a href="https://www.nowcoder.com/discuss/780303?type=post&amp;order=time&amp;pos=&amp;page=0&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack">https://www.nowcoder.com/discuss/780303?type=post&amp;order=time&amp;pos=&amp;page=0&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</a> </p><p>待解决：</p><p>IO多路复用模型深入理解</p><p>Redis的集群和高可用，分布式缓存相关面试题</p><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><p>Redis（<code>Remote Dictionary Server</code>）是一个使用底层使用 <strong>C 语言编写</strong>的，高性能的、<strong>非关系型</strong>数据库，与mysql这种关系型数据库不同，Redis存取的是<strong>键值对</strong>，并且Redis 的数据是存在<strong>内存中</strong>的，所以读写速度非常快，被广泛应用于缓存方向。并且，我们知道内存中的数据是有限的，因此Redis提供了内存淘汰机制，而且Redis提供了<strong>持久化机制</strong>，可以将数据写入磁盘中，保证了数据的安全。</p><p>Redis中存储的是键值对，可以存储键和五种不同类型的值，键的类型只能为字符串，值支持五种数据类型：String、List、Hash、Set、SortedSet。</p><p>Redis还可以用来作<strong>缓存</strong>、<strong>分布式锁</strong>、<strong>消息队列</strong>，支持不同的业务场景。</p><p><strong>分布式锁：</strong></p><p>set key value EX seconds nx </p><p>redlock  </p><p>redission</p><p><strong>消息队列：</strong></p><ul><li>通过List类型中的lpush、rpop命令实现 </li></ul><p>但使用 List 同样存在一定的问题，比如消息不支持重复消费、没有按照主题订阅的功能、不支持消费消息确认等。</p><ul><li><p>通过发布-订阅模式，可以让一个消费者订阅多个生产者</p><p>发布消息，publish channel “message”</p><p>订阅消息，subscribe channel</p></li></ul><h2 id="Redis优缺点？（Redis的功能和不足）"><a href="#Redis优缺点？（Redis的功能和不足）" class="headerlink" title="Redis优缺点？（Redis的功能和不足）"></a>Redis优缺点？（Redis的功能和不足）</h2><p><strong>优点</strong>：</p><ol><li><strong>基于内存操作</strong>，内存读写速度很快。 </li><li>Redis是<strong>单线程</strong>的，避免线程切换开销及多线程的竞争问题。Redis的单线程指一个线程处理所有网络请求，但是Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。 </li><li>有一套<strong>过期数据的删除策略和内存淘汰机制</strong>保证内存空间。</li><li><strong>支持多种数据类型</strong>，包括String、List、Hash、Set、SortedSet等。 </li><li><strong>支持持久化</strong>。Redis支持<strong>RDB</strong>和<strong>AOF</strong>两种持久化机制，可以有效地避免数据丢失问题。 </li><li><strong>支持事务</strong>。Redis的所有操作命令都是原子性的， <strong>Redis的事务不支持原子性。</strong></li><li><strong>支持主从复制</strong>。主节点会自动将数据同步到从节点，可以进行读写分离。 </li></ol><blockquote><p>读写分离：</p><p>让主数据库进行增、改、删操作，而从数据库进行查询操作，主从数据库之间还需要进行数据的同步</p></blockquote><h2 id="为什么Redis这么快？"><a href="#为什么Redis这么快？" class="headerlink" title="为什么Redis这么快？"></a>为什么Redis这么快？</h2><ul><li><p><strong>基于内存</strong>：Redis的数据存在内存中，读写速度快。</p></li><li><p><strong>单线程实现</strong>（ Redis 6.0以前）：Redis使用单线程处理请求，避免了多个线程之间线程切换和加锁释放锁花销</p></li><li><p><strong>IO多路复用模型</strong>：Redis 采用 IO 多路复用技术。IO 多路复用机制是指一个线程处理多个 IO 流，简单来说就是<code>IO</code>多路复用程序会同时监听多个客户端请求，当哪个客户端执行操作后会将其交给相应的事件处理器。</p></li><li><p><strong>高效的数据结构</strong>：Redis 每种数据类型底层都做了优化，操作起来很简单</p></li></ul><h2 id="Redis单线程模型介绍（完成未理解）"><a href="#Redis单线程模型介绍（完成未理解）" class="headerlink" title="Redis单线程模型介绍（完成未理解）"></a>Redis单线程模型介绍（完成未理解）</h2><p><strong>为什么Redis选择单线程模型呢？</strong></p><p>Redis 选择使用单线程模型处理客户端的请求，主要还是因为 CPU 不是 Redis 的瓶颈，而Redis 的瓶颈在于内存的大小和网络带宽。因此，使用单线程已经足够快了，多线程会有性能提升，但不是很明显，而且多线程就会存在线程上下文切换和锁的问题，综合来看，使用单线程处理请求就已经够了。</p><p>事实上也是有多线程的，而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p><p><strong>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</strong>（I/O多路复用解决了什么问题？）</p><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <strong>I/O 多路复用</strong>就是为了解决这个问题而出现的。</p><p><strong>IO多路复用技术的理解</strong></p><p>IO 多路复用机制是指一个线程处理多个 IO 流，简单来说就是<code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当哪个socket执行操作后会将其交给相应的事件处理器。</p><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p><strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><p><strong>为什么说Redis是单线程模型呢？</strong></p><p>我们说Redis是单线程的，指的是执行 <strong>Redis 命令的核心模块</strong>是单线程的，而不是整个 Redis 实例就一个线程，比如说我们在持久化的时候也会新开一个子线程去处理。</p><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为<strong>文件事件处理器</strong>。它的组成结构为4部分：<strong>多个套接字、IO多路复用程序、文件事件分派器、事件处理器</strong>。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型”</p><p><code>IO</code>多路复用程序会同时监听<strong>多个<code>socket</code>**，当被监听的<code>socket</code>准备好执行<code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code>等操作时，与这些操作相对应的文件事件就会产生。</strong><code>IO</code>多路复用程序<strong>会把所有产生事件的<code>socket</code>压入一个队列中，然后有序地每次仅一个<code>socket</code>的方式传送给文件事件分派器，</strong>文件事件分派器<strong>接收到<code>socket</code>之后会根据<code>socket</code>产生的事件类型调用对应的</strong>事件处理器**进行处理。</p><p> Redis通过socket与客户端进行连接，并将服务器对socket的操作抽象为文件事件。redis通过单线程，并通过I/O多路复用来处理来自客户端的多个连接请求，当产生连接后，i/o多路复用程序，会将产生事件的套接字放置一个队列，通过队列以有序、同步的、每次一个套接字的方式向文件事件分派发器传送套接字。当上一个套接字的事件被处理完毕后，I/O多路复用才会向文件分派器传送下一个套接字。服务端通过监听这些事件，并完成相应的处理。被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作，与操作相关的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p>可以看出，文件事件处理器（file event handler）主要是包含4个部分：</p><ul><li>多个 socket（客户端连接）  <strong>socket是什么东东？</strong></li><li>IO多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket关联到相应的事件处理器）</li><li>·事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><img src="/images/Redis%E7%9B%B8%E5%85%B3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jldml2ZWRzdW4=,size_16,color_FFFFFF,t_70.png" alt="https://img-blog.csdnimg.cn/20190822004147554.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jldml2ZWRzdW4=,size_16,color_FFFFFF,t_70" style="zoom: 50%;" /><h2 id="为什么又说Redis中有多线程呢？"><a href="#为什么又说Redis中有多线程呢？" class="headerlink" title="为什么又说Redis中有多线程呢？"></a>为什么又说Redis中有多线程呢？</h2><p>在Redis 4.0 版本开始就有多线程的概念了，比如 Redis 通过<strong>多线程方式在后台删除一些比较大的键值对</strong></p><p>在Redis 6.0 版本 里的多线程主要是为了提高网络IO读写性能， 执行命令的核心模块还是单线程的，因为Redis性能主要受限于内存和网络IO。</p><p>IO 多线程处理模式默认是不开启的，需要去配置文件中开启并配置线程数</p><p><strong>为什么网络处理要引入多线程？</strong></p><p>前面有提到过，<strong>Redis 的瓶颈并不在 CPU，而在内存和网络。</strong></p><p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p><h2 id="Redis的数据结构和应用场景"><a href="#Redis的数据结构和应用场景" class="headerlink" title="Redis的数据结构和应用场景"></a>Redis的数据结构和应用场景</h2><p>Redis有5种数据类型：String 、List（双向链表）、Hash（键值对）、Set（不重复）、SortedSet（排序不重复）</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/1289934-20190621163930814-1395015700.png" alt="img"></p><p><strong>String</strong></p><p>String是最简单的Key-value类型，存储的是字符串。一个字符串类型的值能存储最大容量是<strong>512M</strong>。</p><p>底层是一个简单的动态字符串，和C语言的字符串有区别，空间不足会自动扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line">exists key</span><br><span class="line">strlen key</span><br><span class="line">del key</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong>：一般用在需要计数的场景，比如用户的访问次数、文章的点赞数等等</p><p><strong>List</strong></p><p>List是一个双向链表</p><p><strong>应用场景</strong>：发布与订阅</p><p><strong>rpush 和 lpop 实现队列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush key value1 value2 Value3 从右边添加</span><br><span class="line">lpop key     从左边取出</span><br><span class="line">&quot;value&quot; </span><br><span class="line">lrange key 0 1  从左到右查看  ,0 是开始， 1是结束</span><br><span class="line">&quot;value2&quot; &quot;value3&quot; </span><br><span class="line">lrange key 0 -1 查看列表中所有元素  -1是倒数第一个</span><br></pre></td></tr></table></figure><p><strong>rpush 和 rpop实现栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpush myList2 value1 value2 value3</span><br><span class="line">rpop myList2  # 将 list的头部(最右边)元素取出</span><br><span class="line">&quot;value3&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105165407904.png" alt="image-20211105165407904"></p><p><strong>Hash</strong></p><p>Hash 它的 value 是一个键值对。适用于存储对象，方便修改对象的某个属性值。</p><p><strong>应用场景</strong>：存储对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset userInfoKey name &quot;guide&quot; description &quot;dev&quot; age &quot;24&quot; </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存 在。 (integer) 1 </span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name # 获取存储在哈希表中指定字段的值。 </span><br><span class="line">&quot;guide&quot; </span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age </span><br><span class="line">&quot;24&quot; </span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey # 获取在哈希表中指定 key 的所有字段和值</span><br></pre></td></tr></table></figure><p>**Set **</p><p>set主要存取不重复的元素。还提供了<strong>取交集、并集、差集</strong>的操作。</p><p><strong>使用场景</strong>：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 # 添加元素进去</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 # 不允许有重复元素</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet # 查看 set 中所有的元素</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard mySet # 查看 set 的⻓度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并</span><br><span class="line">存放在 mySet3 中</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>Sorted Set</strong></p><p>和 set 相比，sorted set 增加了⼀个权重参数 score，使得集合中的元素能够按 score 进行排序，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 的TreeSet 。</p><p><strong>适用场景</strong>：适用于排行榜这个场景，比如玩家游戏分数排行，微博热搜排行，最新评论按时间排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 # ⼀次添加多个元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset # 查看 sorted set 中的元素数量</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 # 查看某个 value 的权重</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange myZset 0 -1 # 顺序输出某个范围区间的元素，0 -1 表示输出所有元</span><br><span class="line">素</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange myZset 0 1 # 顺序输出某个范围区间的元素，0 为 start 1 为</span><br><span class="line">stop</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure><p><strong>sorted set 的底层实现</strong></p><p>SortedSet底层使用到了<strong>skipList跳跃表</strong>这种数据结构</p><p>跳表是为了让链表的查找更快而诞生的一种数据结构，最底层链表包括全部的元素，在底层链表的基础上向上抽取出一些节点形成一个多层的链表，也叫做一级索引、二级索引，可以提高我们的查找效率。</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/151152187209308.jpg" alt="img"></p><p>当我们查找时，从最上层开始查找，如果发现当前值比目标值大就往下一层并往后搜索，平均的时间复杂度是O（logn）。</p><p>与红黑树相比，逻辑更加简单，实现和维护起来也更加方便。跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><h2 id="Redis为什么要给数据设置过期时间？"><a href="#Redis为什么要给数据设置过期时间？" class="headerlink" title="Redis为什么要给数据设置过期时间？"></a>Redis为什么要给数据设置过期时间？</h2><p><strong>如何设置过期时间</strong>？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set aa bb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire aa 60  # 设置过期时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl aa   # 查看过期时间</span><br><span class="line">(integer) 58</span><br><span class="line">127.0.0.1:6379&gt; persist aa  # 移除过期时间，设为永不过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex aa 100 bb  # set 和 expire 的合并操作</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li>内存有限，如果缓存中的所有数据都是一直保存的话，内存会不足</li><li>用于一些要求数据有时效性的场景，比如验证码功能，我们希望它只是在一段时间内有效</li></ul><p><strong>Redis如何判断数据是否过期呢？</strong></p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105182448638.png" alt="image-20211105182448638"></p><p>在内部有一个<strong>过期字典</strong>来判断这个键是否过期。过期字典存储的是每个键的过期时间，字典中 key 是设置过期时间的键， value 是过期时间的时间戳）</p><ol><li><strong>检查这个键是否在过期字典中，如果存在，那么取出这个键的过期时间</strong></li><li><strong>和当前 UNIX 时间戳比较，如果大于，则键过期。</strong></li></ol><h2 id="过期数据的删除策略是怎样的？（3种）"><a href="#过期数据的删除策略是怎样的？（3种）" class="headerlink" title="过期数据的删除策略是怎样的？（3种）"></a>过期数据的删除策略是怎样的？（3种）</h2><p>目前来说有三种删除策略： </p><ul><li><strong>定时删除：在设置键的过期时间时，创建一个定时器，当到达键过期时间时就会通过定时器去删除键</strong>。</li><li><strong>惰性删除：是每次获取键时，会判断是否过期，如果过期则删除</strong>。</li><li><strong>定期删除：每隔一段时间，随机抽取一些设置了过期时间的键进行检查，如果过期则删除。</strong></li></ul><p><strong>定时删除策略</strong></p><p> 优点是：对内存友好。因为通过定时器，当一个键到达过期时间时就会立马被删除，直接就释放了内存。</p><p> 缺点是：对 CPU 不友好。因为如果过期键比较多，那么删除这些过期键会占用相当一部分CPU时间。如果服务器将大量的CPU时间用来删除过期键，那么服务器的响应时间和吞吐量就会受到影响。</p><p><strong>惰性删除策略</strong></p><p>优点：对 CPU 时间友好。程序只会在取出键时才会判断是否删除，并且只作用到当前键上，其他过期键不会花费 CPU 时间去处理。</p><p>缺点：对内存不友好。如果数据库有很多的过期键，而这些过期键又恰好一直没有被访问到，那这些过期键就会一直占用着内存资源，造成内存空间浪费。</p><p><strong>定期删除策略</strong></p><p>因为key太多，如果全盘扫描所有的key会非常耗性能，所以是随机抽取一些key来删除。这样就有可能删除不完，需要惰性删除配合。</p><p><strong>Redis实际使用的是惰性删除+定期删除的策略。</strong></p><p>但是这样的删除策略还是有问题的，因为无论是惰性删除还是定期删除，都会发生漏掉过期 key 的情况。这样累积下来就导致大量过期 key 堆积在内存里，导致内存不足，这时候我们就需要用<strong>Redis内存淘汰机制</strong>。</p><p><strong>在持久化和数据恢复阶段，对过期key也有一些特殊的处理。</strong></p><p><strong>RDB</strong></p><p>从内存数据库持久化数据到RDB文件：持久化key之前，会检查是否过期，过期的key不进入RDB文件 </p><p>从RDB文件恢复数据到内存数据库：数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。</p><p><strong>AOF</strong></p><p>从内存数据库持久化数据到AOF文件：当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令） 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）</p><p> AOF重写：重写时，会先判断key是否过期，已过期的key不会重写到aof文件</p><h2 id="Redis内存淘汰机制（8种）"><a href="#Redis内存淘汰机制（8种）" class="headerlink" title="Redis内存淘汰机制（8种）"></a>Redis内存淘汰机制（8种）</h2><p><strong>当MySQL里有2000W数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</strong></p><p>答：redis内存数据集大小上升到一定大小的时候，就会施行<strong>数据淘汰策略。</strong></p><p>当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略。（4种volatile开头的，3种allkeys开头的，还有一种拒绝写入）lru、lfu、ttl、random</p><p>没有配置时，<strong>默认为no-eviction</strong>。</p><ul><li><p>volatile-lru    从<strong>已设置过期时间</strong>的数据集中挑选<strong>最近最少使用</strong>的数据淘汰</p></li><li><p>volatile-lfu    从<strong>已设置过期时间</strong>的数据集中挑选<strong>最不经常使用</strong>的数据淘汰</p></li><li><p>volatile-ttl    从<strong>已设置过期时间</strong>的数据集中挑选<strong>将要过期</strong>的数据淘汰</p></li><li><p>volatile-random    从<strong>已设置过期时间</strong>的数据集中挑选<strong>任意</strong>数据淘汰</p></li><li><p>allkeys-lru    从所有key中淘汰<strong>最近最少</strong>使用的Key（最常用的）</p></li><li><p>allkeys-lfu    从所有key中淘汰<strong>最不经常使用</strong>的Key</p></li><li><p>allkeys-random    从所有key中<strong>随机</strong>选择key淘汰</p></li><li><p>no-eviction    当内存不足以写入新数据时，新写入操作会报错</p></li></ul><p>volatile为前缀的策略都是从 <strong>已设置过期的数据集</strong> 中进行淘汰。<br>allkeys为前缀的策略都是 <strong>面向所有key</strong> 进行淘汰。<br>LRU（least recently used）最近最少用到的。<br>LFU（Least Frequently Used）最不常用的。<br>它们的触发条件都是Redis使用的内存达到阈值时。</p><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><p>持久化就是把<strong>内存的数据写到磁盘中</strong>，防止Redis服务器发生故障导致内存数据丢失。</p><p>Redis 的持久化机制有两种，第一种是<strong>RDB快照</strong>，第二种是 <strong>AOF 日志</strong>。</p><ul><li><p>RDB快照就是将<strong>内存中的数据</strong>以快照的方式写入到二进制文件中，并保存到磁盘。</p></li><li><p>AOF日志就是将<strong>每个操作指令</strong>以日志的方式记录到文件中，并保存到磁盘。</p></li></ul><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><p><code>RDB</code>是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个<code>dump.rdb</code>文件。Redis 重启会加载<code>dump.rdb</code>文件恢复数据。</p><img src="/images/Redis%E7%9B%B8%E5%85%B3/rdb%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="img" style="zoom:80%;" /><p><strong>BGSAVE命令执行流程</strong></p><ul><li><p>执行<code>BGSAVE</code>命令 ，Redis 父进程判断当前<strong>是否子进程正在执行持久化任务</strong>，如果存在，<code>BGSAVE</code>命令直接返回。 </p></li><li><p>父进程执行<code>fork</code>操作<strong>创建子进程</strong>（这个fork的过程会短暂阻塞），之后<strong>父进程继续接收并处理客户端的请求</strong>，而<strong>子进程开始将内存中的数据写进硬盘的二进制文件</strong>；</p></li><li><p>当子进程写完所有数据后会<strong>用该二进制文件替换旧的 RDB 文件</strong>。</p></li></ul><p><strong>触发机制</strong></p><p>RDB持久化触发机制分为：<strong>手动触发</strong>和<strong>自动触发</strong> </p><p><strong>手动触发</strong></p><p>用户执行<code>SAVE</code>或<code>BGSAVE</code>命令。</p><p><code>SAVE</code>命令的执行过程会阻塞所有客户端的请求，我们一般不采用这种方式。</p><p><code>BGSAVE</code>命令可以在后台异步操作，快照的同时服务器还可以继续响应客户端的请求</p><p>因此手动执行快照时推荐使用<code>BGSAVE</code>命令。</p><p><strong>自动触发</strong></p><p>有以下情况会自动触发RDB快照：</p><ul><li>我们可以在redis.conf这个配置文件中配置，比如SAVE 100 10，100秒内至少有10个键被修改则进行快照。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作</span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br><span class="line"># 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、</span><br><span class="line"># 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave</span><br></pre></td></tr></table></figure><ul><li><p>执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，那么会自动执行一次bgsave</p></li><li><p>主从同步的时候，主节点会自动执行BGSAVE命令生成 RDB 文件并发送给从节点。</p></li></ul><p><strong>RDB的优缺点</strong></p><p><strong>优点</strong></p><ul><li>Redis恢复数据时，加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的是内存数据，而AOF文件中存储的是一条条命令，需要重演命令。</li></ul><p><strong>缺点</strong></p><ul><li>RDB<strong>无法做到实时持久化</strong>，若在两次bgsave持久化操作间宕机，则会丢失增量数据，不适用于实时性要求较高的场景</li><li>RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，<strong>存在老版本 Redis 无法兼容新版 RDB 格式的问题</strong>。</li></ul><h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>AOF日志就是以日志的方式将<strong>每个操作指令</strong>记录到文件中，并保存到磁盘。Redis 重启后会根据日志文件的内容重新执行这些指令。与RDB快照的方式相比，AOF<strong>解决了数据持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p><p><strong>默认情况下Redis没有开启AOF方式的持久化</strong>，可以通过<code>appendonly</code>参数启用：<code>appendonly yes</code></p><p><strong>AOF执行流程：</strong></p><ul><li><p>AOF并不会每次都把命令直接写入文件中，因为这样会导致磁盘IO负担加重，它会首先将写入命令会追加到  缓冲区中。 </p></li><li><p>AOF 缓冲区到达一定容量后会根据<strong>对应的策略</strong>向硬盘同步。 （这里有三种策略将缓存区中的命令同步到硬盘中）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 同样我们可以配置缓存同步的策略</span><br><span class="line">appendfsync always  &#x2F;&#x2F;每次发生数据变更会被立即记录到磁盘，数据完整性好但性能差，不建议配置</span><br><span class="line">appendfsync everysec  &#x2F;&#x2F;每秒同步一次，这样最多丢失1s的记录，建议配置</span><br><span class="line">appendfsync no   &#x2F;&#x2F;Redis不直接调用文件同步，而是让操作系统来决定何时同步磁盘</span><br></pre></td></tr></table></figure><ul><li>当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。</li></ul><p><strong>AOF日志重写机制：</strong></p><p>随着 AOF 文件保存的数据越来越大，需要定期对 AOF 文件进行重写。</p><p>Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的AOF文件。</p><p><strong>AOF的优缺点</strong></p><p><strong>优点：</strong></p><ul><li>AOF可以更好地实时持久化，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据。</li></ul><p><strong>缺点：</strong></p><ul><li><p>Redis进行数据恢复时，AOF要重演命令，与RDB相比要慢。</p></li><li><p>AOF方式生成的日志文件太大，需要不断AOF重写</p></li></ul><h3 id="RDB和AOF如何选择？"><a href="#RDB和AOF如何选择？" class="headerlink" title="RDB和AOF如何选择？"></a>RDB和AOF如何选择？</h3><p>通常来说，应该<strong>同时使用两种持久化方案，以保证数据安全。</strong></p><ul><li>如果数据不敏感，且可以从其他地方重新生成，可以关闭持久化。 </li><li>如果数据比较重要，且能够承受几分钟的数据丢失，比如缓存等，只需要使用RDB即可。 </li><li>如果是用做内存数据，要使用Redis的持久化，建议是RDB和AOF都开启。 </li><li>如果只用AOF，优先使用everysec的配置选择，因为它在可靠性和性能之间取了一个平衡。 </li></ul><p><strong>当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。</strong></p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="Redis-事务介绍"><a href="#Redis-事务介绍" class="headerlink" title="Redis 事务介绍"></a>Redis 事务介绍</h3><ul><li><p>Redis 的事务是通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 这四个命令来完成的。</p></li><li><p>使用MULTI命令后开启事务后，可以输入多个命令，Redis不会立即执行这些命令，而是将这些命令放入队列中，当调用了EXEC命令将执行所有命令，使用discard命令会清除队列中的命令。</p></li><li><p>Redis 的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</p></li><li><p><strong>Redis不支持回滚操作，因此Redis事务不满足原子性</strong></p></li></ul><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>使用MULT命令后开启事务可以输入多个命令。Redis不会立即执行这些命令，而是将这些命令放入队列中，当调用了EXEC命令将执行所有命令，使用discard命令会清楚掉队列中的命令。</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-6c4bb09d4f8596d3e6c8ab86d35a721d_1440w.jpg" alt="img"></p><p>1）<strong>MULTI</strong>：用于标记事务块的开始。Redis 会将后续的命令逐个放入队列中，然后使用 EXEC 命令原子化地执行这个命令序列。</p><blockquote><p>127.0.0.1:6379&gt; multi # 开启事务<br>OK<br>127.0.0.1:6379&gt; set k1 alan # 设置 k1<br>QUEUED # k1 加入队列<br>127.0.0.1:6379&gt; set k2 tom # 设置 k2<br>QUEUED # k2 加入队列</p></blockquote><p>2）<strong>EXEC</strong>：在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。</p><blockquote><p>127.0.0.1:6379&gt; exec<br>\1) OK<br>\2) OK</p></blockquote><p>使用 EXEC 命令原子化地执行这个命令序列，刚刚我们设置了 k1 和 k2 两条命令，执行EXEC 命令后，给我们反馈了两个 OK，说明上述两条命令全部执行成功。</p><p>3）<strong>DISCARD</strong>：清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</p><blockquote><p>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; set k3 lucy<br>QUEUED<br>127.0.0.1:6379&gt; set k4 jack<br>QUEUED<br>127.0.0.1:6379&gt; discard<br>OK</p></blockquote><p>4）<strong>WATCH</strong>：可以<strong>监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行</strong>（类似于乐观锁）。执行EXEC命令之后，就会自动取消监控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch name     &#x2F;&#x2F;&#96;watch name&#96;开启了对&#96;name&#96;这个&#96;key&#96;的监控 </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name 1     &#x2F;&#x2F; 开启事务之前设置了 name 的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi         &#x2F;&#x2F; 开启事务a </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name 2    &#x2F;&#x2F; 在事务a中修改了 name 的值</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set gender 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec         &#x2F;&#x2F; 使用&#96;EXEC&#96;命令提交事务 </span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get gender    &#x2F;&#x2F; 使用命令&#96;get gender&#96;发现不存在，即事务a没有执行 </span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>5）<strong>UNWATCH</strong>：可以取消WATCH命令对key的监控，所有监控锁将会被取消。</p><h3 id="事务失败处理（两种错误处理）"><a href="#事务失败处理（两种错误处理）" class="headerlink" title="事务失败处理（两种错误处理）"></a>事务失败处理（两种错误处理）</h3><p>格式错误会命令会回滚；格式正确类型错误，不会回滚。</p><p><strong>1）Redis 格式错误（语法错误）</strong> ：那么事务中的命令都会被回滚</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-3dc3673aa2e049602c211ab8d6df666b_1440w.jpg" alt="img"></p><p>在一个事务中，当命令出现错误时，后续命令正确依旧是可以添加到命令队列中去，但是使用 EXEC 命令执行命令队列的时候，就会报错，并且队列中正确的命令不会被执行。</p><p><strong>2）Redis 格式正确，类型错误</strong>  ：除了错误的那一句，其他的命令都会正常执行，不满足回滚操作</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-341eb047ef02f8013c4a5b33aacbb9aa_1440w.jpg" alt="img"></p><p>这种错误不是命令错误，而是因为对命令理解不透彻出现的使用错误，在执行过程中会报错，因为 username1 不是 list 类型，它只是一个 string 类型。有一点需要注意，从结果可以看出，第一条命令是执行成功了的，所有我们使用”get username1”命令，返回了”alan”结果，<strong>这也证明了 Redis 是不支持事务回滚的</strong>。</p><p><strong>3）为什么 Redis 不支持事务回滚？</strong></p><p>（1）Redis为了性能更好就是忽略了事务回滚</p><p>（2）大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，应该在开发阶段就应该被发现而不是在生产过          程中。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透：</strong>用户发起大量请求，去查缓存，发现缓存中没有，接着去查数据库，发现数据库中也没有，也就是说没有经过缓存这一层，导致数据库压力过大。</p><p><strong>解决方案：</strong></p><p><strong>首先对请求做参数校验，</strong>如果参数不合法直接拒绝该请求：比如用户id不能小于0，邮箱格式不对等等。</p><p>1.<strong>缓存无效的key</strong></p><p>如果大量的请求都是查询同一个key的话，就主动把这个key写入到 Redis中去并设置过期时间，这种方式可以解决请求的key变化不频繁的情况。如果每次是不同请求的key，会导致 Redis中缓存大量无效的key，就不可行了。</p><p>2.<strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，底层是一个二进制的位数组（数组值只有0和1）加上几个哈希函数，通过它我们可以非常方便地<strong>判断一个给定数据是否存在于海量数据中</strong>。我们需要的就是判断请求的key是否合法。</p><p>具体是这样做的：把所有<strong>可能存在的请求的值都存放在布隆过滤器</strong>中，当用户请求发过来，先判断用户请求的值是否存在于布隆过滤器中。不存在的话，直接过滤掉就不会去查找缓存中的数据；存在的话才会走下面的流程。这样就减轻了数据库的压力。</p><p>使用布隆过滤器可能会漏掉少部分不合法的请求，有一定的误判概率</p><p><strong>布隆过滤器原理：</strong></p><p>当一个元素加入布隆过滤器时：</p><p>1.使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（哈希函数不止一个，得到的哈希值也就不止一个，这些<strong>哈希值代表位数组的下标</strong>）。</p><p>2.根据得到的哈希值，在<strong>位数组</strong>中把对应下标的值标为1。</p><p>我们再来看一下，当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作</p><p>1.对给定元素进行相同的哈希计算；</p><p>2.得到值之后判<strong>断位数组中的对应位置的元素是否都为1，如果值都为1，那么说明这个值在布隆过滤器中</strong>，如果存在一个值不为1，说明该元素不在布隆过滤器中。</p><p>但是存在这样一种情况：<strong>不同的元素可能通过哈希计算出来的位置相同。</strong>那么有的不合法的请求也会被判断为合法的，</p><p><strong>解决方法</strong>：可以适当增加<strong>位数组的大小</strong>或者<strong>调整我们的哈希函数</strong>来降低概率</p><p><strong>缺点</strong>：不能删除里面的元素，因为不同的元素有些位置是相同的，我们删除其中某一位时，可能把其他元素也删除了。</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211108111923205.png" alt="image-20211108111923205"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>：我们对缓存设置了相同的过期时间，导致缓存在同一时间大面积失效，请求在短时间内全部落到了数据库上，可能导致数据库崩溃</p><p><strong>举个例子</strong>：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><p><strong>解决方案：</strong></p><p>1.我们可以设置不同的缓存失效时间，比如我们可以在原有的缓存时间基础上增加一个随机值，这样每一个缓存的过期时间就会错开。</p><p>2.缓存预热，在正式部署之前，先把数据先预先访问一遍，这样部分大量访问的数据就会加载到缓存中</p><p>4.或者消息队列限流避免同时处理大量的请求。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿</strong>是指一个<code>key</code>非常热点，大量请求集中对这一个key进行访问，当<strong>这个key在失效的瞬间</strong>，大量持续的请求就击穿缓存，直接请求数据库，数据库的访问压力瞬间增大。有点像袋子里面装着水，袋子破了一个洞，大量的水从洞中漏出。</p><p>缓存击穿和缓存雪崩还是有点类似的，不过击穿是一个key失效，雪崩是大量key同时失效</p><p>造成缓存击穿的原因有以下两个：</p><ol><li>该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）</li><li>添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）</li></ol><p>解决方案：</p><p>1.加锁，在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。</p><p>2.设置这个热点数据永不失效，当然这种情况需要考虑更新缓存。</p><h2 id="Redis高可用（未完成）"><a href="#Redis高可用（未完成）" class="headerlink" title="Redis高可用（未完成）"></a>Redis高可用（未完成）</h2><p>高可用通常是指，<strong>通过设计减少系统不能提供服务的时间。</strong>（让系统尽可能处于可用的状态）</p><p>如果在实际生产中，如果redis只部署一个节点，当机器故障时，整个系统都不能提供服务了。这就是我们常说的单点故障。</p><p>如果redis部署了多台，当一台或几台故障时，整个系统依然可以对外提供服务，这样就提高了服务的可用性。</p><p>redis高可用的三种模式：<strong>主从模式，哨兵模式，集群模式。</strong></p><h3 id="Redis主从模式"><a href="#Redis主从模式" class="headerlink" title="Redis主从模式"></a>Redis主从模式</h3><p><strong>主从复制介绍：</strong></p><p>Redis为了保证系统的高可用，避免单点故障，一般需要部署多台机器。</p><p>因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。redis提供了Redis提供了主从复制的(replication)功能，当一台redis主数据库中的数据发生了变化，这个变化会被自动的同步到其他的redis从数据库中。</p><p>redis多机器部署时，这些机器节点会被分成两类，一类是主数据库（master），一类是从数据库（slave）。</p><p>主数据库可以进行读写操作，<strong>当主数据库的数据发生变化时会自动将数据同步到从数据库</strong>。从数据库一般是只读的，它会接收主数据库同步过来的数据。一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。也就是所谓的<strong>一主多从</strong>结构。<br><img src="/images/Redis%E7%9B%B8%E5%85%B3/format,png.png" alt="一主多从"></p><p><strong>主从复制过程：</strong>（没看懂）</p><p>1.当启动一个从节点时，它会发送一个 <code>PSYNC</code> 命令给主节点； </p><p>2.如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件； </p><p>3.同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， 主节点会将<code>RDB</code>文件发送给从节点，从节点会先将<code>RDB</code>文件<strong>写入本地磁盘，然后再从本地磁盘加载到内存中</strong>； </p><p>4.接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据； </p><p>5.如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。</p><h3 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h3><p><strong>哨兵模式介绍：</strong></p><p>主从模式下要是发生了故障主节点宕机了，哨兵机制会自动选举主节点并将其他的从节点指向新的主节点。</p><p>客户端连接Redis的时候，先连接哨兵，哨兵会告诉客户端Redis主节点的地址，然后客户端连接上Redis并进行后续的操作。当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。</p><p><strong>哨兵模式过程：</strong></p><h3 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h3><p>哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是存在主节点的写能力、容量受限于单机配置的问题。而集群模式实现了Redis的分布式存储，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。</p><p>Redis cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p><strong>三种模式的特点：</strong></p><ul><li><strong>主从模式</strong> 可以实现读写分离，数据备份。但是并不是「高可用」的</li><li><strong>哨兵模式</strong> 可以看做是主从模式的「高可用」版本，其引入了Sentinel对整个Redis服务集群进行监控。但是由于只有一个主节点，因此仍然有写入瓶颈。</li><li><strong>Cluster模式</strong> 不仅提供了高可用的手段，同时数据是分片保存在各个节点中的，可以支持高并发的写入与读取。当然实现也是其中最复杂的。</li></ul><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><p>主要是解决了分布式缓存不均衡的问题</p><p>在单点架构中，如果一个服务器宕机了，整个系统就不可用了，所以我们一般使用的是多点的分布式架构。</p><p>当我们使用分布式架构的时候，希望<strong>每台服务器缓存的数据能够均衡一点</strong>，而一致性Hash算法就是解决这个问题。</p><p><strong>第一种方式</strong>：<strong>hash（图片名称）% N</strong></p><p>我们对图片名称hash，并对服务器数量取余，就可以随机分散在不同服务器上了</p><p><strong>缺点</strong>：如果我们服务器数量发生改变，那么所有缓存的位置都需要重新计算搬移。</p><p>因此，我们提出了一致性</p><p><strong>第二种方式</strong>：<strong>hash（服务器A的IP地址） %  2^32</strong></p><p>考虑一个圆环，上面有2^32个点，先将服务器经过hash计算后映射到圆环上。接着将图片用同样的方式映射到圆环上，存储到顺时针移动碰到的第一个服务器。</p><p>这时候，如果某一台服务器不可用了，将这台服务器存储的数据再顺时针移动到下一台服务器即可。</p><p><strong>缺点</strong>：存在Hash环的偏斜，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211109113800911.png" alt="image-20211109113800911"></p><p><strong>第三种方式</strong>：设置虚拟节点，将原有的物理节点通过虚拟的方法复制出来，让服务器分布相对均匀些</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211109113834444.png" alt="image-20211109113834444"></p><h2 id="Redis如何保证缓存和数据库的一致性"><a href="#Redis如何保证缓存和数据库的一致性" class="headerlink" title="Redis如何保证缓存和数据库的一致性"></a>Redis如何保证缓存和数据库的一致性</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录一点Redis相关面试题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>智力题</title>
    <link href="http://example.com/2021/10/30/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <id>http://example.com/2021/10/30/%E6%99%BA%E5%8A%9B%E9%A2%98/</id>
    <published>2021-10-30T01:52:52.000Z</published>
    <updated>2021-11-10T09:13:07.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录几个智力题</p></blockquote><a id="more"></a><h3 id="分石子问题"><a href="#分石子问题" class="headerlink" title="分石子问题"></a><strong>分石子问题</strong></h3><p>总共有30个石子，每次取1或者2块，先到30的就能赢，怎样才能赢？</p><p>30%（1+2）= 0   那么后拿的人一定赢，只要每次与先拿的人加起来的个数为3.</p><p>假如31个石子呢？</p><p>31%（1+2）= 1 那么先拿的人一定赢，先拿的第一次拿一个，就和上面的类似了。</p><h3 id="按灯泡问题"><a href="#按灯泡问题" class="headerlink" title="按灯泡问题"></a>按灯泡问题</h3><p>如果100个灯泡连成环，按下一个灯泡，它旁边两个灯泡的状态也会发生变化，问如何让100个灯泡全亮？</p><p><strong>步骤一：将灯泡变为全亮或只剩一个为暗</strong></p><p>从 1 循环到 98 ，遇到暗的则按它下一个，使之变亮。循环完毕，1 ~ 98 必然全亮。99 和 100可能为亮亮、暗亮、亮暗、暗暗四种状态。</p><ul><li>若为亮亮，皆大欢喜，满足题目要求</li><li>暗亮、亮暗，达到只剩一个为暗的状态；</li><li>若为暗暗。则按下编号 100 的灯泡，使编号 99 、100 变为亮，编号 1 的灯泡变为暗，从而达到只剩一个为暗的状态。</li></ul><p><strong>步骤二：将灯泡变为全暗</strong></p><p>由于灯泡环形摆放，我们指定暗的灯泡编号为 1 ，将剩下 99 个亮着的灯泡每 3 个为一组。按下每组中间的灯泡后，使得所有灯泡变为暗。</p><p><strong>步骤三：将灯泡变为全亮</strong></p><p>将所有灯泡按一下，灯泡变为全亮。（每个灯泡除了自己主动，还有旁边灯泡触发，即每个灯泡被按了3次，就会由全灭变成全亮）</p><h3 id="有100只狼和1只羊"><a href="#有100只狼和1只羊" class="headerlink" title="有100只狼和1只羊"></a>有100只狼和1只羊</h3><p><strong>规则：</strong></p><p>1、草原上有狼和羊，狼可以选择吃羊，也可以选择吃草，但会优先选择吃羊</p><p>2、一只狼只能吃一只羊，一只羊只会被一只狼吃掉</p><p>3、吃完羊的狼，自己会变成一只羊，可以被其他狼吃掉</p><p>4、狼比起吃羊，更害怕变成羊后被吃掉</p><p> <strong>问题：100只狼和1只羊在一起，这只羊会不会被吃掉？</strong></p><p> 思路：</p><p>如果1羊，1狼。那么狼必然会吃掉羊。 如果1羊，2狼。那么狼吃完羊后，就会被另外一只狼吃掉，因此两只狼都不敢吃羊。因此羊不会被吃。 如果1羊，3狼。那么狼吃完羊后，另外两只狼会面临上一种情况，不敢吃这个新生成的羊，因此原来的羊会被吃掉。 依次类推，<strong>如果是偶数只狼，那么羊不会被吃。如果是奇数只狼，那么羊会被吃掉</strong></p><h3 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a>倒水问题</h3><p>一个3L，一个5L，如何倒出4L水？</p><ul><li>倒满5L，倒进3L，5L中剩2L</li><li>3L倒掉，将5L中的2L倒进3L，此时3L中有2L，5L中没有</li><li>倒满5L，当3L满的时候，5L还剩4L</li></ul><h3 id="毒药问题"><a href="#毒药问题" class="headerlink" title="毒药问题"></a>毒药问题</h3><p>1000瓶药水里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在24小时后试出那瓶有毒？</p><p>答案：log2 1000 向上取整 ≈ 10只。</p><p>解析：<strong>二进制思想。</strong></p><p>老鼠表示二进制中每一位，二进制转化为10进制代表瓶子编号。</p><p>即老鼠表示二进制去对应10进制的瓶子编号</p><p><code>0 000 000 001</code>表示 1 号老鼠，喝了药水 1 。</p><p><code>0 000 000 010</code>表示 2 号老鼠，喝了药水 2 。</p><p><code>0 000 000 011</code>表示 1 号、 2 号老鼠，喝了药水 3 。</p><p>… …</p><p><code>1 111 101 000</code>表示 4、6、7、8、9、10号老鼠，喝了药水 1000。</p><p>按照上述的方法依次喝</p><p>第一回合，1 号老鼠喝药水 1</p><p>第二回合，2 号老鼠喝药水 2</p><p>…</p><p>第一千回合，4、6、7、8、9、10号老鼠喝药水 1000</p><p>喝完一天时，看 10 只老鼠的状态，根据老鼠状态就知道哪瓶药水有毒了。</p><p><strong>比如最后只是 2 号老鼠死了，那就说明第2瓶药水有毒；如果1、2号老师死了，说明第3瓶药水有毒。如果4、6、7、8、9、10死了，那就说明第1000瓶药水有毒！</strong></p><h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><h3 id="12个小球找一个重量不同的球"><a href="#12个小球找一个重量不同的球" class="headerlink" title="12个小球找一个重量不同的球"></a>12个小球找一个重量不同的球</h3><p>这个问题的思想是采用分治的思想</p><p>1.将12个小球分为三组（因为分成两组不能找到重量不一样的球在哪组），为A组、B组、C组<br>2.将三组球分别两两称重，找到重量和另外两组不同的那一组（只要有两组可以使天平平衡，重量不致的球必然在第三组）。假设坏的球在C组<br>3.将C组的球分成两组C1和C2，每组两个球，这时从A组和B组里找到两个正常的球，分别和C1和C2去称，天平不能平衡说明重量不一致的球就在哪组。假设在C14.将C1组的球分别和正常的球去称，天平不平衡时就能找到重量与其他不一致的球</p><h3 id="设计一个排行榜"><a href="#设计一个排行榜" class="headerlink" title="设计一个排行榜"></a>设计一个排行榜</h3><p>mysql</p><p>如果想要<strong>计算排第几名就找出他分数高的有几个，再加上自身个数就好了</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>)+<span class="number">1</span> <span class="keyword">as</span> <span class="string">&#x27;排名&#x27;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">test</span></span><br><span class="line">  <span class="keyword">WHERE</span> score&gt;(<span class="keyword">SELECT</span> score <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;李四&#x27;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，该sql语句会进行全表的扫描，只适用于数据量不是很大的表</p><p>redis</p><p>用SortedSet，底层是一个跳表</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录几个智力题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B8%85%E6%A5%9A%E7%9A%84%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2021/10/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B8%85%E6%A5%9A%E7%9A%84%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE/</id>
    <published>2021-10-27T07:33:11.850Z</published>
    <updated>2021-11-23T09:05:13.793Z</updated>
    
    <content type="html"><![CDATA[<p> IO的方式一般分为几种，<strong>同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO</strong></p><p><strong>用户态和内核态</strong></p><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是<strong>特权级不同</strong>。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：<strong>系统调用，异常和中断。</strong></p><p><strong>用户态和内核态的切换</strong></p><p>当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。</p><p>用户态切换到内核态的 3 种方式</p><p>（1）<strong>系统调用</strong></p><p>这是用户态进程<strong>主动要求</strong>切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如 fork（）就是执行了一个创建新进程的系统调用。系统调用的机制核心是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</p><p>（2）<strong>异常</strong></p><p>当 cpu 在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。</p><p>（3）<strong>外围设备的中断</strong></p><p>当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。</p><p>这三种方式是系统在运行时由用户态切换到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，切换方式都不一样，但从最终实际完成由用户态到内核态的切换操作来看，步骤又是一样的，都相当于执行了一个中断响应的过程。系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本一致。</p><p><strong>java并发：</strong></p><p>两个线程交替打印奇数和偶数：</p><p>采用synchronized + wait + notify</p><p>在一个循环中，先打印，再唤醒另一个线程，再wait当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Process</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">               <span class="keyword">while</span>(num &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印&quot;</span> + num++);</span><br><span class="line">                   lock.notify();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       lock.wait();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintThread thread = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>threadlocal有了解吗？</p><p>线程局部变量，为每个线程提供了属于自己的局部变量，这个变量在线程之间是相互隔离的。</p><p>底层是用ThreadLocalMap实现的，Map的key是线程对象，value是你要保存的对象</p><p>进入某个线程后，就可以从map中取得之前存储相应线程关联的对象</p><p><strong>框架相关</strong>：</p><p><strong>算法：</strong></p><p>查找数组中第k大的数（快排思想，每次求得一个）</p><p>另一棵树的子树</p><p>递归实现冒泡排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; IO的方式一般分为几种，&lt;strong&gt;同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户态和内核态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户态和内核态是操作系统的两种运行级别，两者最大的区别就是&lt;strong&gt;特权</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/26/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E4%B8%80%E9%9D%A2/"/>
    <id>http://example.com/2021/10/26/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E4%B8%80%E9%9D%A2/</id>
    <published>2021-10-26T09:07:41.735Z</published>
    <updated>2021-11-01T04:00:41.461Z</updated>
    
    <content type="html"><![CDATA[<p>京东零售java后台开发一面     1h   10月26日16:00~17:00</p><ol><li>自我介绍</li><li>java基本数据类型（8种）</li><li>String是基本数据类型吗？</li><li>介绍一下final（变量、方法、类）</li><li><strong>输入3X0.1，返回的是什么类型（不会。。）</strong></li><li>instanceof有什么作用？</li><li>枚举类中的两个对象作比较，用equals还是== ？（不是很懂，）</li><li><strong>java中创建对象有几种方式？（new、反射（两种）、clone方法、反序列化）</strong></li><li><strong>介绍一下java的异常体系</strong></li><li><strong>自定义异常如何实现？继承Exception和继承RuntimeException有什么区别？</strong></li><li>对java集合类的理解</li><li>HashMap数组下标如何计算？（三步）</li><li>为什么不直接用Object的HashCode方法，还要右移和取模？</li><li>解决哈希冲突有哪些方法？HashMap中如何解决哈希冲突？（答了拉链法和开放定址法）</li><li>为什么HashMap选择拉链法而不选择开放定址法？</li><li>对HashMap的key有什么要求吗？（我答的通常使用不变的对象作为key）</li><li>java中实现多线程的方法（4种，面试官说线程池不算一种方法）</li><li>线程池怎么创建？（不是很熟悉，）</li><li>有三个线程ABC按顺序执行。比如说A-》B-》C（面试官提到用join方法）</li><li>线程通信和调度方法有哪些？</li><li>wait和sleep方法的区别？</li><li>线程有哪些状态？（我答的6个）</li><li>调用wait和sleep是进入哪个状态？</li><li>MySQL的索引作用？</li><li>主键索引是唯一索引吗？</li><li><strong>我们怎么创建索引？（创建表时加索引，创建完表后再加索引语句create index index_name on student(字段名)）</strong></li><li><strong>怎么知道索引是否创建成功（当时忘了，使用explain）</strong></li><li>数据库事务的四大特性</li><li>谈谈你对隔离性的理解</li><li>谈谈脏读、不可重复读、幻读的区别</li><li>说一下Spring的IOC和AOP</li><li>Spring里面注入的几种方式（）通过成员变量和构造器注入</li><li>@Autowired（有了解过在构造器上用@Autowired吗？）</li><li>Mybatis里面有哪些常用标签？</li><li>MySQL的联合查询如何实现？</li><li>知道Union和UnionAll有什么区别？（将两个表查询的结果集合并在一起）</li><li>去重的标准是什么？</li><li>MyBatis的的$和#有什么区别？</li><li>估计你的实习周期有多长？</li><li>反问</li></ol><p>把一些语气词去掉，不要显得自己不是很确认的样子。。</p><p>比如说 吧，应该是这样的，大概，就按照自己的理解去说就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;京东零售java后台开发一面     1h   10月26日16:00~17:00&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;java基本数据类型（8种）&lt;/li&gt;
&lt;li&gt;String是基本数据类型吗？&lt;/li&gt;
&lt;li&gt;介绍一下final（变量、方法、类）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/25/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/"/>
    <id>http://example.com/2021/10/25/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/</id>
    <published>2021-10-25T08:54:32.276Z</published>
    <updated>2021-11-20T07:53:03.947Z</updated>
    
    <content type="html"><![CDATA[<p>小米java后台开发一面  1h   10月25日15:30~16:30</p><p>结果：一面挂（其实我感觉答的还可以。。除了最后的算法题没完全写对，我也不晓得为啥会挂）</p><ol><li>自我介绍</li><li>介绍一下面向对象的特点（封装、继承、多态）</li><li>Object类的常用方法（只知道hashcode equals hashCode）</li></ol><p>getClass、clone、hashCode、 equals、 toString、  finalize、 wait notify notifyall </p><ol><li><p>String对象为什么不可变（不清楚，只回答了源码用final修饰）</p></li><li><p>equals方法和hashCode方法</p></li><li><p>有重写过equals方法吗？重写了equals方法一定要重写hashCode方法吗？</p></li><li><p>讲一下java接口</p></li><li><p>讲一下java集合中的Collection和Map两个接口（要按照什么样的思路来讲的话比较好呢？讲List、Set、Queue这三个子接口。我是先介绍特点再介绍下面的子接口或者子类</p></li><li><p>讲ArrayList和LinkedList（先从宏观上讲一遍，也就是那三个区别，再从底层讲一下）</p><p>ArrayList 的底层存储、构造函数、扩容过程。LinkedList底层</p></li><li><p>java中创建多线程的方法（4种，可以详细 讲一讲每种是怎么创建的。用线程池创建线程的方法、自定义的忘了怎么说了）</p></li><li><p>有哪些方法可以解决多线程并发安全问题？（我答的synchronized、volatile、锁机制、JUC包下的原子操作类和一些线程安全的并发集合类）</p></li><li><p>介绍一下ReentrantLock和synchronized的区别（中断方式没讲明白、）</p></li><li><p><strong>介绍一下ReentrantLock的底层实现</strong></p></li><li><p><strong>AQS讲一下</strong></p></li><li><p>线程池的参数</p></li><li><p>MySQL引擎介绍一下</p></li><li><p>MySQl引擎的数据结构（B+树）</p></li><li><p>还有哪些数据结构，为什么不用这些数据结构（<strong>为什么不用哈希表</strong>，而用B+树）</p></li><li><p>MySQL的事务隔离</p></li><li><p>MySQL的默认级别是可重复读，但为什么可以解决幻读问题？（MVCC+临键锁）</p></li><li><p><strong>讲一下临键锁</strong></p></li><li><p>意向锁（流程讲一下）</p></li><li><p>JVM的内存结构（讲一下流程和5个区域的作用）</p></li><li><p><strong>讲一下OOM，什么情况下会发生OOM</strong></p></li><li><p>讲一下Spring（这个框架有什么用，核心思想IOC和AOP，先答解耦，再详细答每个思想）</p></li><li><p><strong>Spring事务</strong>（不会）</p></li><li><p>算法题–反转链表Ⅱ</p></li><li><p>反问（1.面试哪些地方不足   2.面试官介绍部门是做什么的，说是小米商城的交易中台服务）</p></li></ol><p>总结：口头禅太多，知识点大概都答上来了，但是总结的有点凌乱。</p><p><strong>有这些口头禅</strong>：就是 、额 、可能、如果。。。的话、然后还有一个、好像</p><p><strong>解决方法</strong>：</p><p>额-》回答问题使先思考一会儿再答，不用着急</p><p>xxx就是-》xxx，他的意思是  或者   xxx的意思是</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小米java后台开发一面  1h   10月25日15:30~16:30&lt;/p&gt;
&lt;p&gt;结果：一面挂（其实我感觉答的还可以。。除了最后的算法题没完全写对，我也不晓得为啥会挂）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;介绍一下面向对象的特点（封装、继承、多态）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/25/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/25/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-25T04:11:13.609Z</published>
    <updated>2021-11-24T09:44:53.915Z</updated>
    
    <content type="html"><![CDATA[<p>面试官，您好！我叫彭博。来自北京邮电大学，我的专业是信息工程 ，目前大四，专业排名10%，想要应聘贵公司后端实习生的岗位。</p><p>在校期间，我学习了   Java、    MySQL   、数据结构算法等必备知识，在技能方面还是符合这个岗位的。我也参加过一些比赛并取得一定的成绩，像美国大学生数学建模竞赛等，让我明白了团结和分工的重要性，在获奖的同时也锻炼了自己的实践能力。像平时我也会写一些博客整理记录下自己所学的知识。</p><p>通过自身的努力，我也获得了很多次的奖学金，担任过大班体育委员、团支书等职务，这也让我认识到付出就有收获。在生活上我是一个比较积极乐观的人，一般会通过运动唱歌的的方式来放松自己。如果有幸能够进入到贵公司，   <strong>在工作中我也会积极主动地迎难而上，认真地完成每一项任务。</strong>以上就是我的自我介绍，面试官好，我介绍完了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试官，您好！我叫彭博。来自北京邮电大学，我的专业是信息工程 ，目前大四，专业排名10%，想要应聘贵公司后端实习生的岗位。&lt;/p&gt;
&lt;p&gt;在校期间，我学习了   Java、    MySQL   、数据结构算法等必备知识，在技能方面还是符合这个岗位的。我也参加过一些比赛并取</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git、Maven、postman的理解</title>
    <link href="http://example.com/2021/10/24/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/24/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-24T12:49:40.000Z</published>
    <updated>2021-11-23T02:14:45.189Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>几个开发中常用工具的使用</p></blockquote><a id="more"></a><h2 id="git简要介绍"><a href="#git简要介绍" class="headerlink" title="git简要介绍"></a>git简要介绍</h2><p>Git官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>Git图标：<img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/Git%E5%9B%BE%E6%A0%87.jpeg" alt="Git图标" style="zoom:80%;" /></p><p>Git 是一个<strong>开源的分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git版本控制</p><ul><li>个人操作</li><li>团队协作：记录每次修改的情况。</li></ul><p><strong>什么是版本控制呢？</strong></p><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3-1610510235263.jpg" alt="版本迭代" style="zoom:50%;" /><h2 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h2><p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/%E6%B5%81%E7%A8%8B.png" alt="git工作流程"></p><p>名词解释：</p><ul><li>workspace：工作区</li><li>staging area：暂存区/缓存区</li><li>local repository：或本地仓库</li><li>remote repository：远程仓库</li></ul><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><h3 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Adding files&quot;</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone</span><br></pre></td></tr></table></figure><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">注：一个^表示后退一步，n 个表示后退 n 步</span><br></pre></td></tr></table></figure><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>一般我们在pom.xml文件中导入jar包的，只要我们确定maven坐标，就可以从远程仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/915951-20161205142602226-1306419231.png" alt="maven仓库"></p><p><strong>本地仓库</strong>是指存在于我们本机的仓库，在我们加入依赖时候，首先会跑到我们的本地仓库去找，如果找不到则会跑到远程仓库中去找。</p><p><strong>远程仓库</strong>是指其他服务器上的仓库，包括全球中央仓库，公司内部的私服，又或者其他公司提供的公共库。</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>而Postman就是一个能够产生各种类型http请求的工具，并能设置请求的参数。</p><p>比如我们能发送我们常用的Post请求和Get请求。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;几个开发中常用工具的使用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql基础知识</title>
    <link href="http://example.com/2021/10/23/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/10/23/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-10-23T09:53:17.000Z</published>
    <updated>2021-11-23T10:30:42.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记一下常见的MySQL语句</p></blockquote><a id="more"></a><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160254539-1309074983.png" alt="img"></p><p>语法格式：</p><p>select 字段 from 表名 where 条件 group by 分组字段 having 分组条件 order by 排序字段 排序规则 limit 分页参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表  from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><h3 id="创建数据库（Create）"><a href="#创建数据库（Create）" class="headerlink" title="创建数据库（Create）"></a>创建数据库（Create）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database db_name;  -- 创建数据库</span><br><span class="line">mysql&gt; show databases;           -- 显示所有的数据库</span><br><span class="line">mysql&gt; drop database db_name;    -- 删除数据库</span><br><span class="line">mysql&gt; use db_name;              -- 选择数据库</span><br><span class="line">mysql&gt; create table tb_name (字段名 varchar(20), 字段名 char(1));   -- 创建数据表模板</span><br><span class="line">mysql&gt; show tables;              -- 显示数据表</span><br><span class="line">mysql&gt; desc tb_name；            -- 显示表结构</span><br><span class="line">mysql&gt; drop table tb_name；      -- 删除表</span><br></pre></td></tr></table></figure><p>​    例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建学生表*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">     Sno <span class="built_in">char</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</span><br><span class="line">     Sname <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">     Ssex <span class="built_in">char</span>(<span class="number">2</span>),</span><br><span class="line">     Sage <span class="built_in">smallint</span>,</span><br><span class="line">     Sdept <span class="built_in">char</span>(<span class="number">20</span>)</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><h3 id="插入数据（Insert）"><a href="#插入数据（Insert）" class="headerlink" title="插入数据（Insert）"></a>插入数据（Insert）</h3><p> insert into 表名 values （值1，值2）语句用于向表格中插入新的行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：*/</span></span><br><span class="line">mysql&gt; insert into tb_name values (value1,value2,value3,...);</span><br><span class="line"><span class="comment">/*第二种形式需要指定列名及被插入的值：*/</span></span><br><span class="line">mysql&gt; insert into tb_name (column1,column2,column3,...) values (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>​     例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*插入数据*&#x2F;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student values ( 20180001,张三,男,20,CS）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student values ( 20180002,李四,男,19,CS）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180003,王五,男,18,MA）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180004,赵六,男,20,IS）;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>update 表名 set 字段1=值1，字段值2=值2，where 条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 将id为2的age改为22，sex改为男</span><br><span class="line">update stu set age&#x3D;22,sex&#x3D;&#39;男&#39; where id&#x3D;2;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>delete from 表名 [where 条件]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 删除stu表中id值为11的数据</span><br><span class="line">delete from stu where id&#x3D;11;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值为12到17的数据</span><br><span class="line">delete from stu where id between 12 and 17;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值大于10的数据</span><br><span class="line">delete from stu where id&gt;10;</span><br></pre></td></tr></table></figure><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表  from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><h3 id="where-查询"><a href="#where-查询" class="headerlink" title="where 查询"></a><strong>where 查询</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 查询stu表中 age &gt; 22的数据</span><br><span class="line">select * from stu where age&gt;22;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 name&#x3D;某个条件值 的数据</span><br><span class="line">select * from stu where name&#x3D;&#39;yyx&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的数据</span><br><span class="line">select * from stu where age between 22 and 25;</span><br><span class="line">select * from stu where age &gt;&#x3D; 22 and age&lt;&#x3D; 25;</span><br><span class="line">-- 查询 stu 表中 年龄不在22到25之间的数据</span><br><span class="line">select * from stu where age not between 22 and 25;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的女生信息</span><br><span class="line">select * from stu where age between 22 and 25 and sex&#x3D;&#39;女&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 users 表中 年龄为22或者25 的女生信息，必须要加小括号，因为and的优先级高于or</span><br><span class="line">select * from users where (age&#x3D;22 or age &#x3D; 25) and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><h3 id="like查询"><a href="#like查询" class="headerlink" title="like查询"></a>like查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- like 语句  like某个确定的值 和。where name &#x3D; &#39;王五&#39; 是一样</span><br><span class="line">select * from stu where name like &#39;yyx&#39;;</span><br><span class="line"></span><br><span class="line">-- % 代表任意个字符  _ 代表单个字符</span><br><span class="line"></span><br><span class="line">-- 使用 % 模糊搜索。%代表任意个任意字符</span><br><span class="line">    -- 查询name字段中包含x的</span><br><span class="line">    select * from stu where name like &#39;%x%&#39;;</span><br><span class="line">    -- 查询name字段中最后一个字符 为 u的</span><br><span class="line">    select * from stu where name like &#39;%u&#39;;</span><br><span class="line">    -- 查询name字段中第一个字符 为 q 的</span><br><span class="line">    select * from stu where name like &#39;q%&#39;;</span><br><span class="line">-- 使用 _ 单个的下划线。表示一个任意字符，使用和%类似</span><br><span class="line">    -- 查询表中 name 字段为两个字符的数据</span><br><span class="line">    select * from users where name like &#39;__&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 name 字段最后为j，的两个字符的数据</span><br><span class="line">select * from users where name like &#39;_j&#39;;</span><br></pre></td></tr></table></figure><h3 id="Mysql中的统计函数（聚合函数）"><a href="#Mysql中的统计函数（聚合函数）" class="headerlink" title="Mysql中的统计函数（聚合函数）"></a>Mysql中的统计函数（聚合函数）</h3><p>可以使用like语句进行某个字段的模糊搜索，</p><p>例如： 查询 name字段中包含五的数据</p><p><strong>count(),max(),min(),sum(),avg()</strong></p><h3 id="count统计数量"><a href="#count统计数量" class="headerlink" title="count统计数量"></a>count统计数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 计算 users 表中 最大年龄，最小年龄，年龄和及平均年龄</span><br><span class="line">select max(age),min(age),sum(age),avg(age) from stu;</span><br><span class="line">-- 上面数据中的列都是在查询时使用的函数名，不方便阅读和后期的调用，可以通过别名方式 美化</span><br><span class="line">select max(age) as max_age,min(age) as min_age,</span><br><span class="line">sum(age) as sum_age,avg(age) as avg_age from stu;</span><br><span class="line">-- 统计 stu 表中的数据量</span><br><span class="line">select count(*) from stu;</span><br><span class="line">select count(id) from stu;</span><br><span class="line">-- 上面的两个统计，分别使用了 count(*) 和 count(id),结果目前都一样，有什么区别？</span><br><span class="line">-- count(*) 是按照 users表中所有的列进行数据的统计，只要其中一列上有数据，就可以计算</span><br><span class="line">-- count(id) 是按照指定的 id 字段进行统计，也可以使用别的字段进行统计，</span><br><span class="line">-- 但是注意，如果指定的列上出现了NULL值，那么为NULL的这个数据不会被统计</span><br><span class="line">-- 假设有下面这样的一张表需要统计</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line">| id | name     | age | sex  | classid |</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line">|  1 | zhangsan |  20 | 男   |       1 |</span><br><span class="line">|  2 | yyx      |  22 | 男   |       1 |</span><br><span class="line">|  3 | lj       |  20 | 男   |       1 |</span><br><span class="line">|  4 | zhaoliu  |  25 | 女   |       1 |</span><br><span class="line">|  5 | uu01     |  26 | 男   |       1 |</span><br><span class="line">|  6 | uu02     |  28 | 男   |       2 |</span><br><span class="line">|  7 | qq02     |  24 | 男   |       2 |</span><br><span class="line">|  8 | uu03     |  32 | 女   |       2 |</span><br><span class="line">|  9 | qq03     |  23 | 女   |       2 |</span><br><span class="line">| 10 | aa       |  19 | 男   |       2 |</span><br><span class="line">| 25 | bb       |  20 | NULL |       2 |</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line"></span><br><span class="line">-- 如果按照sex这一列进行统计，结果就是10个而不是11个，因为sex这一列中有NULL值存在</span><br><span class="line">select count(sex) from stu;</span><br><span class="line">+------------+</span><br><span class="line">| count(sex) |</span><br><span class="line">+------------+</span><br><span class="line">|         10 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>*<em>count(1)  count(</em>)  count(列名) 三者的区别**</p><p>都是返回结果集的行数</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，<strong>不会忽略为NULL的值。</strong>  把null所在行也计算</li><li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略为NULL的值</strong>。</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li></ul><p>结论：使用count(1)和count(*)在性能上是差不多的，而count(字段)会判断一下字段是否为空，性能差，结果不一样</p><p>MySQL对count(*)做了优化，</p><p><strong>count(可空字段) &lt; count(非空字段) = count(主键 id) &lt; count(1) ≈ count(*)</strong></p><h3 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h3><p> group by 语句根据一个或多个列对结果集进行分组</p><p>一般情况下，是用与数据的统计或计算，配合聚合函数使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 统计 stu 表中 男女生人数,</span><br><span class="line">-- 很明显按照上面的需要，可以写出两个语句进行分别统计</span><br><span class="line">select count(*) from stu where sex&#x3D;&#39;女&#39;;</span><br><span class="line">select count(*) from stu where sex&#x3D;&#39;男&#39;;</span><br><span class="line">-- 可以使用分组进行统计，更方便</span><br><span class="line">select sex,count(*) from stu group by sex;</span><br><span class="line">+------+----------+</span><br><span class="line">| sex  | count(*) |</span><br><span class="line">+------+----------+</span><br><span class="line">| NULL |        1 |</span><br><span class="line">| 男   |        7 |</span><br><span class="line">| 女   |        3 |</span><br><span class="line">+------+----------+</span><br><span class="line">-- 统计1班和2班的人数</span><br><span class="line">select classid as &#39;班级&#39;,count(*) from stu group by classid;</span><br><span class="line">+--------+----------+</span><br><span class="line">| 班级   | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      1 |        5 |</span><br><span class="line">|      2 |        6 |</span><br><span class="line">+--------+----------+</span><br><span class="line">-- 分别统计每个班级的男女生人数</span><br><span class="line">select classid,sex,count(*) from stu group by classid,sex;</span><br><span class="line">+---------+------+----------+</span><br><span class="line">| classid | sex  | count(*) |</span><br><span class="line">+---------+------+----------+</span><br><span class="line">|       1 | 男   |        4 |</span><br><span class="line">|       1 | 女   |        1 |</span><br><span class="line">|       2 | NULL |        1 |</span><br><span class="line">|       2 | 男   |        3 |</span><br><span class="line">|       2 | 女   |        2 |</span><br><span class="line">+---------+------+----------+</span><br><span class="line"># 注意，在使用。group by分组时，一般除了聚合函数，其它在select后面出现的字段都需要出现在grouop by后面</span><br></pre></td></tr></table></figure><h3 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h3><p> having时在分组聚合计算后，对结果再一次进行过滤，类似于where。 </p><p>where过滤的是行数据，having过滤的是分组数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 要统计班级人数</span><br><span class="line">select classid,count(*) from stu group by classid;</span><br><span class="line"></span><br><span class="line">-- 统计班级人数，并且要人数达到5人及以上</span><br><span class="line">select classid,count(*) as num from stu group by classid having num &gt;&#x3D;5;</span><br></pre></td></tr></table></figure><h3 id="orded-by"><a href="#orded-by" class="headerlink" title="orded by"></a>orded by</h3><p>ORDER BY 语句用于<strong>根据指定的列对结果集进行排序</strong>。ORDER BY 语句默认按照升序对记录进行排序。</p><p>如您希望按照降序对记录进行排序，可以使用 ASC（升序）、DESC(降序) 关键字。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>查询数据表前几条或者后几条记录，LIMIT可以很好的满足需求。</p><p>limit子句用于限制查询结果返回的数量，常用于分页查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询10条数据，索引从0到9，第1条记录到第10条记录   </span><br><span class="line"># 第一个数类似于数组的下标，从0开始计数，第二个数为记录总条数</span><br><span class="line">select * from t_user limit 10;</span><br><span class="line">select * from t_user limit 0,10;    # 从第1条开始，一共有10条</span><br><span class="line"></span><br><span class="line"># 查询8条数据，索引从5到12，第6条记录到第13条记录</span><br><span class="line">select * from t_user limit 5,8;     # 从第6条开始，一共有8条</span><br></pre></td></tr></table></figure><p><strong>分页需求：</strong></p><p>通过传递<strong>页码（curPage）</strong>和<strong>每页记录条数（pageSize）</strong>两个参数去<strong>分页查询</strong>数据库表中的数据。</p><p>比如：</p><p>查询第1条到第10条的数据的sql是：<code>select * from table limit 0,10</code>;  -&gt;对应我们的需求就是查询第一页的数据：<code>select * from table limit (1-1)*10,10;</code></p><p>查询第11条到第20条的数据的sql是：<code>select * from table limit 10,10</code>; -&gt;对应我们的需求就是查询第二页的数据：<code>select * from table limit (2-1)*10,10</code>;</p><p>查询第21条到第30条的数据的sql是：<code>select * from table limit 20,10</code>; -&gt;对应我们的需求就是查询第三页的数据：<code>select * from table limit (3-1)*10,10</code>;</p><p>这样可以按页去查询数据，比如说查询哪一页的数据，指定页码和每页容纳多少条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curPage是当前第几页；pageSize是一页多少条记录</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">limit</span>(curPage<span class="number">-1</span>)*pageSize,pageSize;</span><br></pre></td></tr></table></figure><h3 id="课后练习题（-分割线-）"><a href="#课后练习题（-分割线-）" class="headerlink" title="课后练习题（***分割线*****）"></a>课后练习题（*<strong>**</strong>分割线*<strong>****</strong>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 统计班级 classid为2的男女生人数？</span><br><span class="line">select sex,count(*) where classid&#x3D;2 group by sex;</span><br><span class="line"></span><br><span class="line">-- 2. 获取每个班级的 平均年龄，并按照平均年龄从大到小排序</span><br><span class="line">select classid,avg(age) as avg_age from stu group by classid order by avg_age desc;</span><br><span class="line"></span><br><span class="line">-- 3. 统计每个班级的人数，按照从大到小排序</span><br><span class="line">select classid,count(*) as &#39;人数&#39; from stu group by classid order by count(*) desc;</span><br></pre></td></tr></table></figure><h3 id="varchar和char的区别？"><a href="#varchar和char的区别？" class="headerlink" title="varchar和char的区别？"></a>varchar和char的区别？</h3><ul><li>varchar表示变长，char表示长度固定。如char（5），无论插入的字符长度是多少，长度都是5，插入字符长度小于5，则<strong>用空格补充。</strong>对于varchar（5），如果插入的字符长度小于5，则存储的字符长度就是插入字符的长度，<strong>不会填充</strong>。</li><li>存储容量不同，对于char来说，最多能存放的字符个数为255，对于varchar，最多能存放的字符个数是65532</li><li>存储速度不同，char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而varchar空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。</li></ul><h3 id="查询表的字段属性"><a href="#查询表的字段属性" class="headerlink" title="查询表的字段属性"></a>查询表的字段属性</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">desc table_name     <span class="comment">-- 这里的desc是describe的意思，就是描述表的字段信息</span></span><br><span class="line">creat index nameIndex on student(name);</span><br><span class="line">creat unique index ageIndex on student(age);</span><br><span class="line">desc student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出字段类型、是否为空、Key的类型</span></span><br><span class="line">Field   Type            Null  Key</span><br><span class="line">id    int(11)        NO  PRI</span><br><span class="line">namevarchar(255)Yes  MUL(可以重复)</span><br><span class="line">age    int(11)        YES  UNI(不可重复)</span><br><span class="line">gendervarchar(255)YES</span><br></pre></td></tr></table></figure><h3 id="什么是子查询？"><a href="#什么是子查询？" class="headerlink" title="什么是子查询？"></a>什么是子查询？</h3><p>把一个查询的结果在另一个查询中使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询年纪最大的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age=(<span class="keyword">SELECT</span> <span class="keyword">max</span>(age)<span class="keyword">from</span> <span class="keyword">user</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age, sex) = (<span class="keyword">SELECT</span> age, sex <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&quot;zhangsan&quot;</span>）                               </span><br></pre></td></tr></table></figure><h3 id="MySQL的几种连接查询"><a href="#MySQL的几种连接查询" class="headerlink" title="MySQL的几种连接查询"></a>MySQL的几种连接查询</h3><p>MySQL的连接查询主要可以分为<strong>外连接</strong>，<strong>内连接</strong>，<strong>交叉连接</strong></p><p><strong>表测试数据：</strong></p><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027113245206.png" alt="image-20211027113245206"></p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>从左表中取出每一条记录，去右表中与所有的记录进行匹配，保留匹配成功的记录，并将两份记录拼接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内连接</span></span><br><span class="line"><span class="comment">-- select * from student inner join class; --结果与交叉连接相同</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">class</span> <span class="keyword">on</span> student.cid = class.cid;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160249740-1441543214.png" alt="image"></p><p>说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p><p><img src="/images/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/3.png" alt="img"></p><h4 id="外连接（左外连接和右外连接）"><a href="#外连接（左外连接和右外连接）" class="headerlink" title="外连接（左外连接和右外连接）"></a>外连接（左外连接和右外连接）</h4><p>与内连接不同的是主表记录不管匹配符不符合都保留，方式有<strong>左外连接、右外连接,左外连接是保留左表，右外连接是保留右表</strong></p><ul><li><p>语法：</p></li><li><ul><li>左外连接：<code>select 字段列表 from 左表 left join 右表 on 左表.字段 = 右表.字段;</code></li><li>右外连接：<code>select 字段列表 from 左表 right join 右表 on 左表.字段 = 右表.字段;</code></li></ul></li><li><p><strong>左外连接</strong></p></li><li><pre><code class="sql">select * from student left join class on student.cid = class.cid;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ![image](&#x2F;images&#x2F;mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&#x2F;1053079-20180411160252239-1394678105.png)</span><br><span class="line"></span><br><span class="line">- **右外连接**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sql</span><br><span class="line">  select * from student right join class on student.cid &#x3D; class.cid;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160254539-1309074969.png" alt="image"></p></li></ul><h3 id="Union和Union-All的区别（联合查询语句）"><a href="#Union和Union-All的区别（联合查询语句）" class="headerlink" title="Union和Union All的区别（联合查询语句）"></a>Union和Union All的区别（联合查询语句）</h3><p><strong>作用：</strong></p><p>union和union all的作用都是<strong>将两个结果集合并到一起。</strong>但要注意用于选择的两个语句选择的字段数要相等（否则无法连接），字段类型可以不相等。</p><p><strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">column</span>,......from table1   <span class="keyword">UNION</span> [<span class="keyword">all</span>]   <span class="keyword">select</span>  <span class="keyword">column</span>,...... <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027112104524.png" alt="image-20211027112104524"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,gender <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">class</span>;</span><br><span class="line"><span class="comment">-- 因为class就两个字段，所以第一个只选出两个字段</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027112145964.png" alt="image-20211027112145964" style="zoom: 67%;" /><p><strong>区别：</strong></p><ul><li>union会对结果<strong>去重并排序</strong>，union all直接直接返回合并后的结果，不去重也不进行排序。</li><li>union all的性能比union性能好。</li></ul><h3 id="如何优化Limit分页？"><a href="#如何优化Limit分页？" class="headerlink" title="如何优化Limit分页？"></a>如何优化Limit分页？</h3><p><strong>数据量大的时候limit分页速度为什么会变慢？</strong></p><p><strong>如何优化？</strong></p><h3 id="SQL语句执行的很慢的原因"><a href="#SQL语句执行的很慢的原因" class="headerlink" title="SQL语句执行的很慢的原因"></a>SQL语句执行的很慢的原因</h3><ul><li>可能是执行的时候遇到了锁</li><li>可能是字段上没有索引或者字段有索引但是没用上索引（比如不满足最左匹配准则）</li></ul><h3 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h3><p>查询中用到的关键词主要包含六个，并且他们的顺序依次为</p><p>select–from–where–group by–having–order by </p><p><strong>这六个关键词的执行顺序 与sql语句的书写顺序并不是一样</strong>的，其中select和from是必须的，其他关键词是可选的，按照下面的顺序来执行：</p><p>from–where–group by–having–select–order by,</p><p>from:需要从哪个数据表检索数据</p><p>where:过滤表中数据的条件</p><p>group by:如何将上面过滤出的数据分组</p><p>having:对上面已经分组的数据进行过滤的条件 （对分组后的数据进行统计）</p><p>select:查看结果集中的哪个列，或列的计算结果</p><p>order by :按照什么样的顺序来查看返回的数据</p><h3 id="一条select语句的执行流程"><a href="#一条select语句的执行流程" class="headerlink" title="一条select语句的执行流程"></a>一条select语句的执行流程</h3><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjgwMDU1,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><strong>连接</strong>：</p><p>当客户端连接 MySQL 时，会发出连接请求到连接器，连接器此时就会去验证这个连接的账号密码，如果账号密码正确，连接器会到权限表里面查询出该账号<strong>所拥有的权限</strong></p><p>在数据库中有两种连接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">短连接:每次执行完很少的几次查询就断开连接，下次想查询时，就要重新建立一个</span><br><span class="line"></span><br><span class="line">长连接:如果客户端持续有请求，那就一直使用同一个连接</span><br></pre></td></tr></table></figure><p>建立连接是比较麻烦的，首先要发送请求吧，发送了请求要去验证账号密码吧，验证完了要去看你所拥有的权限吧，所以在使用过程中，尽量使用长连接。</p><p>但是使用长连接又有新的问题：有时候，你会发现 MySQL 占用内存，因为是长连接嘛，所以它会在断开的时候才将资源释放掉。</p><p>这个时候可以考虑下面两种方案：<br>1、定期断开长连接<br>2、如果使用的是 MySQL 5.7 或者更高版本，可以在每次执行一个比较大的操作之后，通过执行 mysql_reset_connection 来重新初始化连接资源，这个过程不需要重新连接和权限验证缓存</p><p><strong>缓存</strong></p><p>首先看缓存里面有没有执行过这条SQL语句，如果有直接给客户端返回结果。如果缓存中没有的话，那就去分析器。</p><p>但是查询缓存不建议使用， 因为在MySQL中对某张表进行了更新操作，那么所有的查询缓存就会失效，对于更新频繁的数据库来说，查询缓存的命中率很低。</p><p>注： MySQL 8.0 版本直接将查询缓存的功能给删掉了。</p><p><strong>分析器</strong></p><p>分为<strong>词法分析</strong>和<strong>语法分析</strong></p><p>分析器首先会进行”词法分析”,词法分析就是 select * from T where id=1; ，它会将 select 识别出来，哦，这是一个查询语句，接下来会将 T 也识别出来，哦，你是想要在这个表中做查询，然后将 where 后面的条件也识别出来，原来我需要去查找这些内容</p><p>OK ,“词法分析”之后，接下来是“语法分析”，语法分析主要就是分析输入的 SQL 语句合不合法<br>1）是否使用了错误的关键字；<br>2）使用的关键字顺序是否正确；<br>3）检查数据表和数据列是否存在等</p><p><strong>优化器</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="string">` `</span>* <span class="string">``</span><span class="keyword">from</span><span class="string">` `</span><span class="keyword">user</span><span class="string">` `</span><span class="keyword">where</span><span class="string">` `</span><span class="keyword">id</span> &gt; <span class="number">1</span> <span class="string">``</span><span class="keyword">and</span><span class="string">` `</span><span class="keyword">name</span><span class="string">` `</span>= <span class="string">``</span><span class="string">&#x27;大彬&#x27;</span><span class="string">``</span>;</span><br></pre></td></tr></table></figure><p>比如说where后面的查询条件有多个，优化器判先断执行哪个查询条件是最优的</p><p>比如说多表连接查询的时候，优化器会判断先关联哪儿个表效率会比较高呀。</p><p><strong>执行器</strong></p><p>执行器首先要做的是检查是否有权限访问这张表， 无权限，就返回没有权限的错误；若有权限，就根据相应的存储引擎去执行操作。</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>攻击者通过SQL语句欺骗服务器而得到非授权的查询，进而获取数据库信息</p><p>大部分的sql注入是因为程序要接受客户端传来的参数，而这些参数是组成sql语句的一部分，改变了正常的sql语句结构所导致</p><p>解决方法：</p><ol><li>在执行SQL语句之前，先检查客户端传来的参数类型和格式是否符合预期的格式，同时要过滤掉一些非法的字符等等。</li><li>使用预编译语句，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构</li></ol><h3 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h3><p>MySQL触发器指通过事件触发而执行，而不是主动调用；它会事先为某张表绑定一段代码，当表中的某些内容发生改变（增、删、改）的时候，系统会自动触发代码并执行。</p><p>我们需要指定绑定的表、改变之前触发还是改变之后触发、触发之后该怎么做</p><p>下面这个例子：当我们在student表中插入一个学生时，就需要在成绩表中插入对应的学生信息。</p><ol><li><strong>create</strong> <strong>trigger</strong> ins_stu </li><li><strong>after</strong> <strong>insert</strong> <strong>on</strong> student <strong>for</strong> each row  </li><li><strong>begin</strong> </li><li>   <strong>insert</strong> <strong>into</strong> cj ( stu_id, stu_name) </li><li>​    <strong>values</strong>( new.stuid, new.username); </li><li><strong>end</strong>; </li></ol><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p>即第一范式要求确保表中每列的原子性，也就是不可拆分；第二范式要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖；第三范式确保主键列之间没有传递函数依赖关系，也就是消除传递依赖</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记一下常见的MySQL语句&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>linux常用指令</title>
    <link href="http://example.com/2021/10/23/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2021/10/23/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2021-10-23T08:50:29.000Z</published>
    <updated>2021-10-23T09:53:39.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些linux常用指令</p></blockquote><a id="more"></a><p><strong>查看运行的进程</strong>： ps    </p><ul><li><p>ps -ef  查看所有进程信息</p><p>-e 显示所有进程。<br>-f 全格式。</p></li><li><p>ps -ef | grep java    查看java进程信息</p></li></ul><p><strong>结束进程</strong>：kill   pid     </p><ul><li><p>kill -9 pid 强制结束进程   </p></li><li><p>kill -15 pid 默认方式，正常结束进程</p></li></ul><p>kill原理：kill 命令会向操作系统发送一个信号（多是终止信号）和目标进程的 PID，然后系统根据收到的信号类型，对指定进程进行相应的操作。我们的 -9 -15 都是信号类型</p><p><strong>查看与某台机器的连接情况</strong> ：ping</p><p>命令：ping ip</p><p><strong>查看每个进程的运行情况</strong>：top</p><p>类似于windows的资源管理器</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>目录切换：cd       cd / 切换到根目录    、  cd ../ 切换到上一级目录 或者  cd ..</p><p>目录查看：ls        ls -a查看当前目录下的所有目录和文件（包括隐藏的文件）</p><p>创建目录：mkdir     mkdir   aaa 在当前目录下创建一个名为aaa的目录</p><p>删除目录：rm     rm 文件名   删除当前目录下的文件  、   rm -r aaa   递归删除当前目录下的aaa目录   </p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>新建文件：touch       touch  aa.txt   在当前目录创建一个名为aa.txt的文件    </p><p>删除文件：rm</p><p>修改文件：vi  进入文件    按 i 进入编辑模式   按wq保存并退出</p><p>查看文件：more</p><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><p>命令：tar -zcvf  打包压缩后的文件名  要打包的文件</p><p>例子：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar</p><p>tar -zcvf ab.tar  *</p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>grep：匹配文件中的文本</p><p> grep  ‘test’  file    匹配file文件中 含有 text 的文本</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些linux常用指令&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/21/%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/10/21/%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/</id>
    <published>2021-10-21T01:30:23.489Z</published>
    <updated>2021-10-26T14:31:44.291Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">网址</th><th>公司名称</th><th>投递时间</th><th>面试时间</th><th>面试状态</th><th>一面</th></tr></thead><tbody><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_d6gl0x8oliko?pcm=pc_SearchList%EF%BC%88%E5%AE%9E%E4%B9%A0%E5%83%A7%EF%BC%89">https://www.shixiseng.com/intern/inn_d6gl0x8oliko?pcm=pc_SearchList（实习僧）</a></td><td>猿辅导</td><td>10月21日 9:32</td><td></td><td>被拒</td><td>无</td></tr><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_lpevnzwllesy?pcm=pc_SearchList">https://www.shixiseng.com/intern/inn_lpevnzwllesy?pcm=pc_SearchList</a> （实习僧）</td><td>小米</td><td>10月21日9:42</td><td></td><td>等待约面</td><td>一面挂</td></tr><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_pzv2tkpt7pxv?pcm=pc_SearchList">https://www.shixiseng.com/intern/inn_pzv2tkpt7pxv?pcm=pc_SearchList</a> （实习僧）</td><td>京东</td><td>10月21日9:45</td><td></td><td>等待约面</td><td>等消息</td></tr><tr><td align="left"><a href="https://nowpick.nowcoder.com/w/intern/detail?jobId=61053&amp;deliverSource=2&amp;pageSource=5004%EF%BC%88%E7%89%9B%E5%AE%A2%EF%BC%89%E6%B2%A1%E6%9C%89%E5%9B%9E%E5%93%8D">https://nowpick.nowcoder.com/w/intern/detail?jobId=61053&amp;deliverSource=2&amp;pageSource=5004（牛客）没有回响</a></td><td>滴滴</td><td>10月21日 9:54</td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">学长内推</td><td>字节</td><td>10月22日10:00</td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">实习僧</td><td>百度</td><td></td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">实习僧</td><td>快手</td><td></td><td></td><td>等待约面</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;网址&lt;/th&gt;
&lt;th&gt;公司名称&lt;/th&gt;
&lt;th&gt;投递时间&lt;/th&gt;
&lt;th&gt;面试时间&lt;/th&gt;
&lt;th&gt;面试状态&lt;/th&gt;
&lt;th&gt;一面&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10.18</title>
    <link href="http://example.com/2021/10/18/10-18/"/>
    <id>http://example.com/2021/10/18/10-18/</id>
    <published>2021-10-18T12:58:44.000Z</published>
    <updated>2022-05-09T01:59:39.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕叽咕叽</p><p>看了几篇字节的面经，有那么点感觉好像面试题都答得上来了，至少题目都还见过，只是记得熟不熟的问题。</p><p>我飘了，快来骂醒我！！</p><p>许愿许愿，搞定了就来还愿</p></blockquote><a id="more"></a><p>10.24更</p><p>笑死，根本学不完，飘不起来。</p><hr><p>看到一个帖子，其实感触还蛮深。。。</p><p>想要说点什么</p><p><img src="/images/10-18/image-20211024100435602.png" alt="image-20211024100435602"></p><hr><p>2022.2.20更</p><p>中国人尤喜欢造神，硬将一个人推入神坛，只是将结果摆在大众面前，但往往淡化其成功的背景因素。突然想到了一个词，奉为圭臬。一个人在某个领域的成功，并不代表其在其他领域也是行家。造神往往伴随而来的就是跌下神坛，人们给的期望越高，这种人设往往越容易破灭，其实那个人还是自己，但是人们眼中那种完美的形象却不复存在了。</p><hr><p>2022.5.9更</p><p>我不知道，有时候仔细想想，确实应该更爱自己，有的东西并不是付出了就有回报，你不会只是喜欢一个虚妄中的形象吧，很可笑</p><p>你在期待着什么，或许就不应该有太多期待，做好自己的事情。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕叽咕叽&lt;/p&gt;
&lt;p&gt;看了几篇字节的面经，有那么点感觉好像面试题都答得上来了，至少题目都还见过，只是记得熟不熟的问题。&lt;/p&gt;
&lt;p&gt;我飘了，快来骂醒我！！&lt;/p&gt;
&lt;p&gt;许愿许愿，搞定了就来还愿&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock介绍</title>
    <link href="http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T08:50:25.000Z</published>
    <updated>2021-11-23T08:48:17.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下</p></blockquote><a id="more"></a><p>Lock是一个接口，Reentrantlock是Lock的一个主要实现类。</p><p><strong>ReentrantLock</strong> 类内部总共存在<strong>Sync</strong>、<strong>NonfairSync</strong>、<strong>FairSync</strong>三个类，<strong>NonfairSync</strong>与 <strong>FairSync</strong>类继承自 <strong>Sync</strong>类，<strong>Sync</strong>类继承自 <strong>AbstractQueuedSynchronizer</strong>抽象类（AQS）</p><h2 id="synchronized与ReentrantLock的区别（5点）"><a href="#synchronized与ReentrantLock的区别（5点）" class="headerlink" title="synchronized与ReentrantLock的区别（5点）"></a>synchronized与ReentrantLock的区别（5点）</h2><p>共同点：都是可重入锁、都是排它锁。</p><p>可重入锁：当前线程获取该锁后还可以再次获取，不会发生阻塞。</p><p>独占锁：一个锁只能被一个线程所占有。</p><p>① <strong>底层实现上来说</strong></p><ul><li>synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过获取和释放monitor对象来实现，</li><li>ReentrantLock 是JUC.lock包下的一个类，是<strong>API层面</strong>的锁。</li></ul><p>② <strong>是否可手动释放：</strong></p><ul><li>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动释放锁。</li><li> ReentrantLock则需要用户去手动加锁释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法来加锁和释放锁</li></ul><p>③ <strong>是否公平锁</strong></p><p>​    公平锁介绍：多个线程等待同一个锁时，必须<strong>按照申请锁的时间顺序获得锁</strong></p><ul><li><p>synchronized为非公平锁 </p></li><li><p>ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空<strong>默认false非公平锁</strong>，true为公平锁。</p></li></ul><p>④ <strong>是否可中断</strong></p><p>​    可中断介绍：</p><p>​    线程A和B都要获得同一把锁，假设A获取了锁，那么B将一直等待A释放锁。</p><p>   使用 synchronized ，如果A不释放，B将一直等下去，等待过程不能被中断</p><p>   使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p><ul><li>synchronized是不可中断类型的锁。</li><li>ReentrantLock可以中断，可通过<strong>tryLock</strong>(long timeout,TimeUnit unit)设置超时方法（超时没有获得锁就中</li></ul><p>断）或者将<strong>lockInterruptibly</strong>()放到代码块中，调用<strong>interrupt</strong>方法进行中断。</p><p>⑤ <strong>锁是否可绑定条件Condition</strong></p><ul><li>synchronized不能绑定；     </li><li>ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的<strong>精确唤醒</strong>，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。</li></ul><h2 id="Reentrantlock的底层实现"><a href="#Reentrantlock的底层实现" class="headerlink" title="Reentrantlock的底层实现"></a>Reentrantlock的底层实现</h2><p><strong>ReentrantLock</strong> 类内部总共存在<strong>Sync</strong>、<strong>NonfairSync</strong>、<strong>FairSync</strong>三个类，<strong>NonfairSync</strong>与 <strong>FairSync</strong>类继承自 <strong>Sync</strong>类，<strong>Sync</strong>类继承自 <strong>AbstractQueuedSynchronizer</strong>抽象类</p><p><strong>底层主要是AQS+CAS操作，AQS=双向链表+volatile类型的state状态量</strong></p><p>先讲一下AQS，AQS（AbstractQueuedSynchronizer）抽象队列同步器，是一个双向链表+volatile类型的state状态量所构成。</p><p>双向链表是由一个个Node组成的，没有抢到锁的线程被封装成Node节点放入队列中，每个Node节点有两个指针，分别指向前驱结点和后继结点，同时还存有一个Thread的变量，代表封装的线程，需要注意的是，这些变量也都是Volatile类型的，主要是为了保证对其他线程可见。</p><p>state主要是表示是否有线程获取到锁了，当有线程获取到锁时，state=1，如果获取到锁的线程再次加锁，state加一；同理当释放锁时，state减一。当state=0时，会唤醒队列中的下一个节点。</p><p>lock（）：</p><p><strong>通过 compareAndSetState 尝试获取到锁</strong></p><ul><li><strong>如果获取到锁，那么将该锁的持有线程设置为当前线程。且当前同步状态为1，即state = 1</strong></li><li><strong>如果没有获取到锁，则进入acquire(1)方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层排队过程如下：</strong></p><p>主要分为抢到锁的线程，和没有抢到锁在队列里面排队的线程</p><p>首先A抢到锁了，state=1，当前线程改为A线程。</p><p>如果B线程再来抢锁，通过CAS操作先去判断state的值，发现state!=0; 去队列里面排队，排队之前并不会直接用头指针指向B线程所在的节点，而是先创建一个空节点，我们称这个空间点叫做哨兵节点，在哨兵节点创建完毕后，再把自己连接在哨兵结点之后。即先设置哨兵节点，再设置B节点</p><p>如果C再来抢锁，通过CAS，发现state!=0;去队列里面排队，发现头结点已经指向了一个哨兵节点，就不用再设置哨兵节点了，去B节点后面排队。</p><p>（排队的过程还涉及再次抢锁，如果没有进入park状态，等待A线程释放锁唤醒）</p><p>接着A线程释放锁，将state设为0，将B线程唤醒，同时受理窗口改为B线程，队列中的B节点Thread设置为null，并用头结点指向，那么开始的哨兵节点由于没有对象指向就变成了垃圾被GC掉。</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026103743409.png" alt="image-20211026103743409"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104027910.png" alt="image-20211026104027910"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104154035.png" alt="image-20211026104154035"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104257380.png" alt="image-20211026104257380"></p><p>第一次排队的节点是一个空节点</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026110225172.png" alt="image-20211026110225172"></p><p>如果队列中再来一个节点</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026110508921.png" alt="image-20211026110508921">    </p><p>B节点出队后，设置成了null，相当于是新的哨兵节点。而原来得哨兵节点没有任何引用指向它，就被GC掉</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026112122771.png" alt="image-20211026112122771"></p><p>按照自己理解的Reentrantlock的加锁和解锁过程：</p><p><strong>底层主要是AQS+CAS操作，AQS=双向链表+state状态量</strong></p><p>主要分为抢到锁的线程，和没有抢到锁在队列里面排队的线程</p><p>首先A抢到锁了，state=1，受理窗口改为A线程。</p><p>如果B线程再来抢锁，通过CAS，发现state!=0;去队列里面排队，排队之前先设置哨兵节点，在设置B节点</p><p>如果C再来抢锁，通过CAS，发现state!=0;去队列里面排队，发现头结点已经指向了一个哨兵节点，就不用再设置哨兵节点了，去B节点后面排队。</p><p>（排队的过程还涉及再次抢锁，如果没有抢到就进入park状态，等待A线程释放锁唤醒）</p><p>接着A线程释放锁，将state设为0，将B线程唤醒，同时受理窗口改为B线程，队列中的B节点Thread设置为null，并用头结点指向，那么开始的哨兵节点由于没有对象指向就变成了垃圾被GC掉。</p><p>。。。</p><h3 id="countdownlatch"><a href="#countdownlatch" class="headerlink" title="countdownlatch"></a>countdownlatch</h3><p>允许一个或多个线程等待，直到其他线程中执行的一个放行操作完后，等待线程才会继续往下执行的同步辅助。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java中几种锁的介绍</title>
    <link href="http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T07:25:38.000Z</published>
    <updated>2021-11-21T09:25:09.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中一些锁的介绍</p></blockquote><a id="more"></a><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>乐观锁</strong>：乐观锁认为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，但是在修改的时候会判断一下在此期间别的线程有没有修改过数据。</p><p>乐观锁的实现方式一般有两种：<strong>版本号机制</strong>和<strong>CAS操作</strong>。在Java中java.util.concurrent.<strong>atomic包下面的Atomic操作类就是使用了乐观锁</strong>，<strong>而Atomic操作类的底层正是用到了“CAS机制”。</strong></p><p><strong>悲观锁</strong>：每次在拿数据的时候都会加锁，其他线程拿不到锁就阻塞，直到持有锁的线程释放锁。</p><p>比如<strong>java中的synchronized的就是一种悲观锁。</strong>数据库中的表锁行锁也是一种悲观锁。</p><p>采用悲观锁的一些问题（采用synchronized的一些问题）：</p><ul><li>在多线程竞争下，多次加锁释放锁会造成性能损耗</li><li>如果一个线程持有锁，其他的线程就都会阻塞，等待持有锁的线程释放锁。</li></ul><p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。</p><p>乐观锁就是：每次不加锁而是假设没有并发冲突去操作同一变量，如果有并发冲突导致失败，则重试直至成功。</p><p>主要就是两个步骤：<strong>冲突检测和数据更新</strong>。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，先来后到。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><p>简单来说就是：</p><p><strong>公平锁</strong> ：是指多个线程按照申请锁的顺序来获取锁，类回排队打饭先来后到。<br><strong>非公平锁</strong> ：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</p><p><strong>什么是饥饿？</strong></p><p>优先级高的线程能够插队并优先执行，这样如果<strong>优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。</strong>当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源。</p><p>ReentrantLock中就有相关公平锁，非公平锁的实现。默认是非公平锁，如果为设置为true就是公平锁。更深入的需要探寻其中的源码实现原理</p><h2 id="可重入锁和非重入锁"><a href="#可重入锁和非重入锁" class="headerlink" title="可重入锁和非重入锁"></a>可重入锁和非重入锁</h2><p>可重入锁：当前线程获取该锁后还可以再次获取，不会发生阻塞。</p><p>用一个简单的例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说A和B都是两个synchronized修饰的方法，在方法A中调用了方法B；有一个线程获取到了锁执行方法A，然后在执行方法B的时候就自动获取锁，去执行方法B；</p><p><strong>可重入锁可以避免线程死锁</strong>：</p><p>假如Synchronized不是可重入锁；那么该线程获取到执行A方法所需要的锁之后开始执行A方法；但是在执行过程中遇到了方法B；由于是不可重入锁；B方法也是被Synchronized关键字修饰；所以执行B方法也需要获取锁；但是此时A方法代码还未执行完成，继续占有锁；B方法就获取不到锁，被阻塞；A方法迟迟执行不完成，所以也就一直不释放锁；因此；就产生了死锁</p><p>synchronized和ReentrantLock都是可重入锁；当然ReentrantLock还可以设置成为公平锁，也就是不可重入锁；</p><p>不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;java中一些锁的介绍&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java线程池相关</title>
    <link href="http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-15T03:38:17.000Z</published>
    <updated>2021-11-20T15:11:27.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程池相关</p></blockquote><a id="more"></a><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a><strong>什么是线程池？</strong></h2><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>有了线程池后，如果我们要处理多线程的任务，直接从线程池中去取线程即可，而不用每个请求任务都创建和销毁线程，提高服务器的性能。</p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a><strong>为什么要使用线程池？</strong></h2><p>主要是省去了创建线程和销毁线程的过程，直接从线程池中去取线程即可。</p><p><strong>创建线程和销毁线程</strong>的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程太耗费性能，于是我们可以使用线程池技术把创建和销毁的线程的过程去掉，直接从线程池中取出线程</p><h2 id="线程池有什么作用？"><a href="#线程池有什么作用？" class="headerlink" title="线程池有什么作用？"></a><strong>线程池有什么作用？</strong></h2><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><h2 id="创建线程池的方法"><a href="#创建线程池的方法" class="headerlink" title="创建线程池的方法"></a>创建线程池的方法</h2><p>创建出来的线程池都实现了ExecutorService接口。常用方法有以下几个：</p><p>1、<strong>使用ThreadPoolExecutor类自定义线程池</strong></p><p>2、<strong>使用Executors类（四种线程池）</strong></p><p>Executors类为我们提供了四种常见的线程池，但本质上都是调用ThreadPoolExecutor的构造函数，只是构造函数的参数不同。使用Executors类创建线程池可能会造成OOM，比如说我们使用Exexutors类中的newFixedThreadPool，意思是创建一个固定大小的线程池，超过了这个大小就要在等待队列中排队，而等待队列的最大值是Integer.Max_Value，相当于无穷大，当我们不断创建线程执行的时候就会超出堆空间的内存，导致OOM的发生，所以建议使用自定义的ThreadPoolExecutor类，并设置等待队列的大小。</p><p>所以我们推荐使用ThreadPoolExecutor的方法，根据我们的需要自定线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.调用ThreadPoolExecutor的构造函数创建一个对象</span></span><br><span class="line"><span class="comment">//2.调用这个对象的execute方法，execute方法中一般是一个实现了runnable接口的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">            ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">60</span>, TimeUnit.MICROSECONDS, <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">                Runnable task = <span class="keyword">new</span> CustomTask(i);</span><br><span class="line">                <span class="comment">//将runnable对象作为参数传入pool.execute中。</span></span><br><span class="line">                pool.execute(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说几种常见的线程池及使用场景"><a href="#说说几种常见的线程池及使用场景" class="headerlink" title="说说几种常见的线程池及使用场景"></a><strong>说说几种常见的线程池及使用场景</strong></h2><p><strong>java.util.concurrent.Executors类为我们提供了创建线程池的简便方法。</strong></p><p>使用Executors可以创建我们常用的四种线程池：</p><p>（1）newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。不设上限，提交的任务将立即执行。</p><p>（2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>（3）newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>（4）newSingleThreadExecutor 创建一个单线程化的线程池执行任务。</p><blockquote><p>这几种线程池的源码都调用了ThreadPoolExecutor的构造函数</p></blockquote><p><strong>Executors的坏处</strong></p><p>正常来说，我们<strong>不应该使用这种方式创建线程池</strong>，应该使用<strong>ThreadPoolExecutor</strong>来创建线程池。Executors创建的线程池也是调用的ThreadPoolExcutor的构造函数。通过源码可以看出：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015164333196.png" alt="newFixedThreadPool"></p><p>我们也看到了这里面的LinkedBlockingQueue并没有指定队列的大小，是一个无界队列，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致OOM。所以我们一般要使用ThreadPoolExecutor这种方式来创建线程池。</p><p><strong>创建线程池的正确姿势：</strong></p><p>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>或者是使用开源类库：开源类库，如apache和guava等。</p><p><strong>五种线程池的使用场景</strong></p><p>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</p><p>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</p><p>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</p><p>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h2 id="线程池中的几种重要的参数（7个）"><a href="#线程池中的几种重要的参数（7个）" class="headerlink" title="线程池中的几种重要的参数（7个）"></a><strong>线程池中的几种重要的参数</strong>（7个）</h2><p><strong>ThreadPoolExecutors构造函数中7个重要的参数：</strong></p><ul><li><p>corePoolSize就是线程池中的核心线程数量，即使这些线程处理空闲状态，他们也不会被销毁</p></li><li><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p></li><li><p>keepAliveTime，非核心线程在空闲状态下的最大存活时间，超过这个时间，非核心线程就会被销毁</p></li><li><p>util，表示最长存活时间的单位。</p></li><li><p>workQueue，就是等待队列的大小，当核心线程数满了后其他请求就储存在任务队列中，等待被执行，按照FIFIO原则（先进先出）。</p></li><li><p>threadFactory，就是创建线程的线程工厂。</p></li><li><p>handler,是一种拒绝策略，当线程池中线程数量满了后，拒绝执行某些任务。（4种内置的拒绝策略）</p></li></ul><p><strong>线程池提交任务时的执行流程：</strong></p><p>当我们创建好线程池后，要向线程池提交任务时：</p><p>会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就使用一个核心线程来执行任务。</p><p>如果大于核心线程数，就会判断等待队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</p><p>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</p><p>如果已经达到了最大线程数，则执行指定的拒绝策略。</p><p><strong>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</strong></p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015180107031.png" alt="线程池提交任务时的执行流程"></p><p>举个例子：corePoolSize为2，maximumPoolSize为6，workQueue大小为5；</p><p><strong>第一步</strong>，任务0、1提交时，创建核心线程并执行<br><strong>第二步</strong>，任务2、3、4、5、6提交时，将其放在工作队列（工作队列能容纳5个线程）<br><strong>第三步</strong>，任务7、8、9、10提交时，创建线程并执行，直到池子满了（工作队列也满了，多一个线程就创建一个新线程，但总线程数不能大于maximumPoolSize）<br><strong>第四步</strong>，任务11、12、13、14、15被拒绝策略拒绝（什么时候被拒绝策略拒绝呢？当请求线程数&gt;工作队列容量+ maximumPoolSize时）<br><strong>第五步</strong>，执行缓存队列中的任务2、3、4、5、6</p><h2 id="线程池常用的阻塞队列（没有很理解）"><a href="#线程池常用的阻塞队列（没有很理解）" class="headerlink" title="线程池常用的阻塞队列（没有很理解）"></a>线程池常用的阻塞队列（没有很理解）</h2><ol><li><p><strong>LinkedBlockingQueue</strong></p><p>LinkedBlockingQueue，它的容量是 Integer.MAX_VALUE，为 2^31 -1 ，是一个非常大的值，可以认为是无界队列。</p><p>这里需要注意，FixedThreadPool 和 SingleThreadExecutor 线程池的线程数是固定的，其中maximumPoolSize这个参数是没有用的，因为阻塞队列根本就放不满，所以线程池只会创建核心线程数量的线程</p></li><li><p><strong>SynchronousQueue</strong><br> 第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。<br> 我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p></li><li><p><strong>DelayedWorkQueue</strong><br> 第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p></li></ol><p>下面是四种线程池对应的阻塞队列：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015181738391.png" alt="image-20211015181738391"></p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a><strong>线程池的拒绝策略</strong></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当线程池中最大线程数满了后，我们需要采取拒绝策略。</span><br><span class="line">在ThreadPoolExecutor中已经包含四种处理策略，默认为AbortPolicy策略，即丢弃任务并抛出异常。</span><br></pre></td></tr></table></figure><ul><li><p>AbortPolicy策略：丢弃任务并抛出RejectedExecutionException异常。</p></li><li><p>DiscardPolicy策略：丢弃任务，但是不抛出异常。</p></li><li><p>DiscardOlddestPolicy策略： 该策略将丢弃最老的一个请求，也就是工作队列中最前面的一个请求，并再次提交当前任务。</p></li><li><p>CallerRunsPolicy 策略：如果线程池未关闭，由调用线程（即提交任务的线程）执行此该请求</p></li></ul><p><strong>自定义拒绝策略</strong>：除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，只需实现RejectedExecutionHandler接口即可。</p><h2 id="线程池的执行任务和关闭"><a href="#线程池的执行任务和关闭" class="headerlink" title="线程池的执行任务和关闭"></a>线程池的执行任务和关闭</h2><p><strong>execute和submit用来执行线程池中的任务</strong></p><ul><li>execute（）方法用于不需要提交返回值的任务</li><li>submit（）方法用于需要提交返回值的任务。</li></ul><p><strong>线程池的关闭</strong></p><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><ul><li><p>shutdownNow（）方法的解释是：线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。</p></li><li><p>shutdown（）方法的解释是：线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。</p></li></ul><p><strong>初始化线程池时线程数的选择</strong></p><p>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</p><p>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</p><p>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线程池相关&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
