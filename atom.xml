<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pb</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-18T07:01:28.321Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://example.com/2021/09/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/09/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-17T03:45:51.000Z</published>
    <updated>2021-09-18T07:01:28.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回溯本质就是一颗递归树</p></blockquote><a id="more"></a><ul><li>排列问题</li><li>组合问题（查找叶子结点 ）</li><li>子集问题（查找每一个子节点）</li><li>分割问题（类似组合问题）</li></ul><p>组合问题都需要设置一个 startIndex， 保证每次搜索不能重复，排列则不需要</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</p><p>有同学问了，什么时候for可以从0开始呢？</p><p>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。</p><p>但是要清楚子集问题和组合问题、分割问题的的区别，<strong>子集是收集树形结构中树的所有节点的结果</strong>。</p><p><strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，<strong>一个维度是同一树枝上使用过，一个维度是同一树层上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p><strong>两种去重方式比较</strong>：</p><p>如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210917161342246.png" alt="树层上去重"></p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210917161411436.png" alt="树枝上去重"></p><p><strong>树层上对前一位去重非常彻底，效率很高</strong>，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><p>这两句话说的真好，我们都是在两个维度上面进行去重的，一个是同一层上，一个是一个树枝上。</p></blockquote><p>参考资料：代码随想录</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;回溯本质就是一颗递归树&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>9.11</title>
    <link href="http://example.com/2021/09/11/9-11/"/>
    <id>http://example.com/2021/09/11/9-11/</id>
    <published>2021-09-11T02:34:25.000Z</published>
    <updated>2021-09-11T03:04:15.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕咕一下</p></blockquote><a id="more"></a><p>最近事情蛮多。</p><p>前段时间忙着保研材料，感谢竞赛加分，算了下排名已经很稳很稳了。</p><p>其实你会发现，人的主观能动性所带来的的能量是非常巨大的。只要你想做什么事情，全面分析，一步一步开始做，做好长期的规划，最终的结果都是很好的。</p><p>我总是记得家里人说过的一句话，什么阶段就该做什么阶段的事情。身边的很多事例都证明了这句话的正确性。</p><p>一个阶段的结束又是另一个新阶段的开始。</p><p>可能是很久没写感想了，让我再写出什么刻骨铭心的感想也写不出来了，这段时间让思想变得简单点，再去做自己想做的事情。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕咕一下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="想法" scheme="http://example.com/categories/%E6%83%B3%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>两个大数求和</title>
    <link href="http://example.com/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <id>http://example.com/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/</id>
    <published>2021-09-04T13:47:54.000Z</published>
    <updated>2021-09-18T07:00:56.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果给出两个很大很大的整数，这两个数大到long类型也装不下，比如100位整数，如何求它们的和呢？</p></blockquote><a id="more"></a><p>采用字符串存储，逆序相加，最后的结果再逆序即可</p><p><img src="/images/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/image-20210904215330885.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bigNumberSum</span><span class="params">(String bigNumberA, String bigNumberB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.把两个大整数用数组逆序存储，数组长度等于较大整数位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLength = Math.max(bigNumberA.length(), bigNumberB.length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigNumberA.length(); i++)&#123;</span><br><span class="line">        arrayA[i] = bigNumberA.charAt(bigNumberA.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigNumberB.length(); i++)&#123;</span><br><span class="line">        arrayB[i] = bigNumberB.charAt(bigNumberB.length() - <span class="number">1</span>- i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构建result数组，数组长度等于较大整数位数+1，为了保证进位数能被存放下</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历数组，按位相加，每一个位置上的值=对应位数值相加再加上进位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLength; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arrayA[i] + arrayB[i] + carry;</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = tmp % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.如果最后一位进位为1,</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">        result[result.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        len = maxLength + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        len = maxLength ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.把result数组再次逆序并转成String（之前要判断首位是0还是1）</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        sb.append(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(bigNumberSum(<span class="string">&quot;426709752318&quot;</span>, <span class="string">&quot;95481253129&quot;</span>));</span><br><span class="line">    <span class="comment">//运行结果：522191005447</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简版大数相加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            res.append(tmp % <span class="number">10</span>);</span><br><span class="line">            i--; j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果给出两个很大很大的整数，这两个数大到long类型也装不下，比如100位整数，如何求它们的和呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql相关</title>
    <link href="http://example.com/2021/09/03/mysql%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/09/03/mysql%E7%9B%B8%E5%85%B3/</id>
    <published>2021-09-03T09:04:17.000Z</published>
    <updated>2021-09-03T13:14:27.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mysql一些面试题</p></blockquote><a id="more"></a><h2 id="mysql里面的数据类型"><a href="#mysql里面的数据类型" class="headerlink" title="mysql里面的数据类型"></a>mysql里面的数据类型</h2><p>主要有三种：<strong>数值</strong>、<strong>时间</strong>和**字符串(字符)**类型。</p><img src="/images/mysql/image-20210903171114888.png" alt="数据类型"  /><p><a href="https://zhuanlan.zhihu.com/p/50891083">https://zhuanlan.zhihu.com/p/50891083</a></p><h2 id="mysql-里面时间是怎么存储的"><a href="#mysql-里面时间是怎么存储的" class="headerlink" title="mysql 里面时间是怎么存储的"></a>mysql 里面时间是怎么存储的</h2><p>存储时间的类型：year、date、time、datetime、timestamp</p><p><strong>DATE</strong> - 以YYYY-MM-DD格式的日期，在1000-01-01和9999-12-31之间。 例如，1973年12月30日将被存储为1973-12-30。</p><p><strong>DATETIME</strong> - 日期和时间组合以YYYY-MM-DD HH:MM:SS格式，在1000-01-01 00:00:00 到9999-12-31 23:59:59之间。例如，1973年12月30日下午3:30，会被存储为1973-12-30 15:30:00。</p><p><strong>TIMESTAMP</strong> - 1970年1月1日午夜之间的时间戳，到2037的某个时候。这看起来像前面的DATETIME格式，无需只是数字之间的连字符; 1973年12月30日下午3点30分将被存储为19731230153000(YYYYMMDDHHMMSS)。</p><p><strong>TIME</strong> - 存储时间在HH:MM:SS格式。</p><p><strong>YEAR(M)</strong> - 以2位或4位数字格式来存储年份。如果长度指定为2(例如YEAR(2))，年份就可以为1970至2069(70〜69)。如果长度指定为4，年份范围是1901-2155，默认长度为4。</p><p><img src="/images/mysql/v2-63be71052bbe166d1d1bfdf63a0dc83a_1440w.jpg"></p><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种数据结构,可以帮助我们<strong>快速的进行数据的查找.</strong></p><p>拿字典作比方，字典目录的作用是快速定位某一个汉字，而索引的作用是快速定位所需数据</p><p>提出问题：为什么不用二叉搜索树？</p><p>创建索引需要两个条件，这就是：我要给谁–以什么实现方式–创建什么类型的索引</p><ol><li>给谁：就是给那个字段，这里可以是一个字段，也可以是多个字段；</li><li>实现方式：就是索引的数据结构，可以是BTREE、HASH；</li><li>类型：就是索引的类型，innoDB中一共支持四种索引类型，分别是普通索引、唯一索引、主键索引、全文索引。</li></ol><p>创建索引的字段：可以是一个字段，也可以是多个字段，在多个字段上使用时需要满足最左匹配原则。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>单值索引</li><li>主键索引</li><li>唯一索引</li><li>复合索引</li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有<strong>Hash索引,B+树索引</strong>等,而我 们经常使用的<strong>InnoDB存储引擎</strong>的默认索引实现为:B+树索引.</p><h2 id="聚簇索引非聚簇索引"><a href="#聚簇索引非聚簇索引" class="headerlink" title="聚簇索引非聚簇索引"></a>聚簇索引非聚簇索引</h2><p>一些关键词：</p><p>InnoDB、MyISAM</p><p>索引、B+树、聚簇索引、</p><p>事务、并发事务、事务回滚、隔离级别</p><p>mysql锁、锁算法、锁优化、</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;mysql一些面试题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>http相关内容</title>
    <link href="http://example.com/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</id>
    <published>2021-09-01T11:52:13.000Z</published>
    <updated>2021-09-05T02:07:20.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>http</p></blockquote><a id="more"></a><h2 id="在浏览器中输入url到显示页面的过程中发生了什么？"><a href="#在浏览器中输入url到显示页面的过程中发生了什么？" class="headerlink" title="在浏览器中输入url到显示页面的过程中发生了什么？"></a>在浏览器中输入url到显示页面的过程中发生了什么？</h2><p>1、通过DNS解析<strong>由域名找到对应的IP地址</strong> ，寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。  （DNS解析过程）</p><p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;（三次握手具体过程） </p><p>3、由浏览器发送一个HTTP请求 ，经过路由器的转发，通过服务器的防火墙，到达了服务器 </p><p>4、服务器处理该HTTP请求，返回一个HTML文件 </p><p>5、浏览器解析该HTML文件，并且显示在浏览器端</p><blockquote><p>DNS解析过程：</p></blockquote><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>超文本传输协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），属于应用层，端口号80</p><p>HTTP协议<strong>定义Web客户端如何向Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</strong></p><p>HTTP协议采用了<strong>请求/响应模型</strong>。<strong>客户端向服务器发送一个请求报文</strong>，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。<strong>服务器以一个状态行作为响应</strong>，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>请求报文结构</p><ul><li>HTTP请求体由：请求行 、请求头、请求内容实体组成的</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901204224623.png" alt="请求报文结构"></p><p>响应报文结构：</p><ul><li>响应报文包含三部分 状态行、响应首部字段、响应内容实体实现</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901204401019.png" alt="响应报文结构"></p><h2 id="常用的-HTTP-方法"><a href="#常用的-HTTP-方法" class="headerlink" title="常用的 HTTP 方法"></a>常用的 HTTP 方法</h2><ul><li>GET：GET方法用来请求URL指定的资源。指定的资源经服务器端解析后返回响应内容 </li><li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 </li><li>PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。 </li><li>HEAD：获得报文首部，与GET方法类似，只是不返回报文主体</li><li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 </li><li>OPTIONS：查询相应URI支持的HTTP方法。</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901200949347.png" alt="option方法作用"></p><h2 id="Get与Post的区别"><a href="#Get与Post的区别" class="headerlink" title="Get与Post的区别"></a>Get与Post的区别</h2><p>1、 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源</p><p>2、GET是<strong>幂等的，即读取同一个资源，总是得到相同的数据</strong>，而POST不是幂等 的，因为每次请求对资源的改变并不是相同的</p><p>3、就安全性而言，<strong>POST的安全性要比GET的安全性高</strong>，因为GET请求提交的数据将<strong>明文</strong>出现在URL上， 而且POST请求参数则被包装到<strong>请求体</strong>中，相对更安全。</p><p>4、从请求的大小看，<strong>GET请求的长度受限于浏览器或服务器对URL长度的限制</strong>，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p><h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901201650517.png" alt="状态码"></p><p>一些常见状态码的含义：</p><table><thead><tr><th>状态码</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>初始的请求已经接受，请客户端继续发送剩余部分</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>301</td><td>永久移动</td><td>请求的页面已永久跳转到新的url</td></tr><tr><td>401</td><td>未授权</td><td>请求要求用户进行身份演验证</td></tr><tr><td>403</td><td>禁止</td><td>服务器拒绝请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的页面</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理出现错误</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr></tbody></table><h2 id="什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h2><p><strong>概念</strong>：是指每一次的请求都是独立的，客户端第一次向服务器发送请求完成之后，再一次向服务器发送请求，服务器并不知道该客户端是刚才那个。</p><p><strong>解决方法</strong>：</p><p>使用Cookie和Session技术（引出这两个知识点）</p><h2 id="Cookie和Session技术"><a href="#Cookie和Session技术" class="headerlink" title="Cookie和Session技术"></a>Cookie和Session技术</h2><h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><p>1、端口：HTTP的URL由”http://起始且默认使用端口80，而HTTPS的URL由”https:/起始且默认使用端口443.</p><p>2、安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份。</p><p>HTTPS是运行在<strong>SSL</strong>之上的HTTP协议，SSL运行在TCP之上。所有传输的内容都经过加密，<strong>加密采用对称加密</strong>，但对<strong>称加密的密钥用服务器方的证书进行了非对称加密</strong>。所以说，<strong>HTTP安全性没有HTTPS高，但是HTTPS比HTTP耗费更多服务器资源。</strong></p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><blockquote><p>对称加密：密钥只有一个，加密解密为同一个密钥，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p>非对称加密：公钥所有人都可以获得，通信发送方获得接收方的公钥之后，就可以使用公钥进行加密，接收方收到通信内容后使用私钥解密。相对对称加密速度较慢。</p><p>SSL：安全套接层（Secure Sockets Layer ）</p><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901215413693.png"></p></blockquote><h2 id="HTTP长连接-短连接"><a href="#HTTP长连接-短连接" class="headerlink" title="HTTP长连接,短连接"></a>HTTP长连接,短连接</h2><p>HTTP的长连接和短连接<strong>本质上是TCP长连接和短连接</strong>。</p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>Keep-Alive不会永久保持连接，它有一个<strong>保持时间</strong>，可以在header当中进行设置的。实现长连接需要客户端和服务端都支持长连接。</p><h3 id="什么时候用长连接，短连接？"><a href="#什么时候用长连接，短连接？" class="headerlink" title="什么时候用长连接，短连接？"></a><strong>什么时候用长连接，短连接？</strong></h3><ol><li>长连接多用于<strong>操作频繁，点对点的通讯，而且连接数不能太多情况</strong>，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</li><li>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。<strong>所以并发量大，但每个用户无需频繁操作情况下需用短连好。</strong></li></ol><h3 id="长连接与短连接区别"><a href="#长连接与短连接区别" class="headerlink" title="长连接与短连接区别:"></a>长连接与短连接区别:</h3><p>**长连接:**连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）； </p><p>**短连接:**连接→数据传输→关闭连接；</p><h2 id="Http1-0-和-Http1-1-有什么区别？"><a href="#Http1-0-和-Http1-1-有什么区别？" class="headerlink" title="Http1.0 和 Http1.1 有什么区别？"></a>Http1.0 和 Http1.1 有什么区别？</h2><p>HTTP1.0出现早，主要用于一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ul><li>长连接 : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li>错误状态响应码 :<strong>在HTTP1.1中新增了24个错误状态响应码</strong>，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——应用层</title>
    <link href="http://example.com/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-09-01T09:07:44.000Z</published>
    <updated>2021-09-02T01:07:38.223Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之应用层</p></blockquote><a id="more"></a><h2 id="域名系统（DNS）"><a href="#域名系统（DNS）" class="headerlink" title="域名系统（DNS）"></a>域名系统（DNS）</h2><p>DNS 可以使用 <strong>UDP 或者 TCP</strong> 进行传输，使用的<strong>端口号都为 53。</strong>大多数情况下 DNS 使用 <strong>UDP 进行传输</strong>，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 <strong>TCP 进行传输：</strong></p><ul><li>如果返回的响应<strong>超过 512 字节</strong>（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><h2 id="文件传送协议（FTP）"><a href="#文件传送协议（FTP）" class="headerlink" title="文件传送协议（FTP）"></a>文件传送协议（FTP）</h2><p>FTP使用两个并行的TCP连接来传输文件，一个是控制连接，一个是数据连接。</p><ul><li><strong>控制连接</strong>：服务器打开<strong>端口号 21</strong> 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li><strong>数据连接</strong>：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有<strong>主动</strong>和<strong>被动</strong>两种模式：</p><ul><li><p><strong>主动模式</strong>：服务器端主动建立数据连接，其中服务器端的<strong>端口号为 20</strong>，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</p></li><li><p><strong>被动模式</strong>：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p></li></ul><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。</p><p>被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><h2 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了<strong>即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</strong></p><p>DHCP 配置的内容不仅是 IP 地址，还包括<strong>子网掩码</strong>、<strong>网关 IP 地址。</strong></p><h2 id="远程登录协议（TELNET）"><a href="#远程登录协议（TELNET）" class="headerlink" title="远程登录协议（TELNET）"></a>远程登录协议（TELNET）</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p><p>邮件协议包含发送协议和读取协议，<strong>发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</strong></p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20210901172320605.png"></p><h3 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1. SMTP"></a>1. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><h3 id="2-POP3"><a href="#2-POP3" class="headerlink" title="2. POP3"></a>2. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p><h3 id="3-IMAP"><a href="#3-IMAP" class="headerlink" title="3. IMAP"></a>3. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之应用层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历模板</title>
    <link href="http://example.com/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-09-01T02:04:34.000Z</published>
    <updated>2021-09-02T10:31:43.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树遍历模板</p></blockquote><a id="more"></a><p>使用迭代法：</p><p>前序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val);   <span class="comment">//中序相当于把这一句移到了下面代码块中间</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList();    <span class="comment">//在前序遍历的基础上换成了LinkedList</span></span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.addFirst(root.val);   </span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;   <span class="comment">//在前序遍历的基础上把左右子树的顺序换了一下</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;二叉树遍历模板&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络——传输层</title>
    <link href="http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <id>http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</id>
    <published>2021-08-31T13:18:15.000Z</published>
    <updated>2021-09-08T14:41:42.641Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之传输层</p></blockquote><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>我们知道<strong>网络层可以实现两个主机之间的通信</strong>。但是这并不具体，因为，真正进行通信的实体是在<strong>主机中的进程</strong>，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。<strong>IP协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。而端到端的通信才应该是应用进程之间的通信。</strong></p><p><strong>UDP</strong> 在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的<strong>速度比较快</strong>，比如一些对<strong>实时性要求较高的服务</strong>，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。</p><p><strong>TCP</strong> 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。</p><h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul><li>用户数据报协议 UDP（User Datagram Protocol）是<strong>无连接的</strong>，<strong>尽最大可能交付</strong>，<strong>不能保证可靠性</strong>，<strong>没有拥塞控制，面向报文</strong>（对于应用程序传下来的报文不合并也不拆分，<strong>只是添加 UDP 首部</strong>），支持一对一、一对多、多对一和多对多的交互通信。</li><li>传输控制协议 TCP（Transmission Control Protocol）是<strong>面向连接的</strong>，<strong>提供可靠交付</strong>，<strong>有流量控制，拥塞控制</strong>，提供全双工通信，<strong>面向字节流</strong>（把应用层传下来的报文看成字节流，把一个数据包拆分成若干组进行发送），每一条 TCP 连接只能是<strong>点对点的</strong>（一对一）。</li></ul><h2 id="TCP、UDP协议的区别"><a href="#TCP、UDP协议的区别" class="headerlink" title="TCP、UDP协议的区别"></a>TCP、UDP协议的区别</h2><ul><li>TCP是面向连接的，UDP是无连接的； </li><li>TCP是可靠的，UDP是不可靠的；</li><li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式； </li><li>TCP是面向字节流的，UDP是面向报文的； </li><li>TCP有流量控制、拥塞控制机制;UDP没有拥塞控制机制。</li><li>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</li></ul><h2 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h2><p>对某些<strong>实时性要求比较高</strong>的情况使用UDP，比如即时通信（QQ聊天），实时直播，视频会议，即使出现传输错误也可以容忍；</p><p>对<strong>数据准确性要求高，速度可以相对较慢</strong>的情况用TCP。比如: 文件传输、邮件的发送与接收等。</p><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><h3 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h3><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210831220758563.png" alt="TCP三次握手"  /><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK = 1，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><blockquote><p>有6种位码即tcp标志位</p><p>① SYN(synchronous建立联机)；</p><p>② ACK(acknowledgement 确认)</p><p>③ PSH(push传送)</p><p>④ FIN(finish结束)</p><p>⑤ RST(reset重置)</p><p>⑥ URG(urgent紧急)</p><p>Sequence number(顺序号码) //Acknowledge number(确认号码)</p></blockquote><h3 id="为什么要有第三次握手呢？"><a href="#为什么要有第三次握手呢？" class="headerlink" title="为什么要有第三次握手呢？"></a><strong>为什么要有第三次握手呢？</strong></h3><blockquote><p>主要防止在网络中滞留的已经失效的连接请求突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，在第二次握手时客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><p><a href="https://blog.csdn.net/scuzoutao/article/details/81774100">https://blog.csdn.net/scuzoutao/article/details/81774100</a></p><h3 id="第三次握手失败了怎么办？"><a href="#第三次握手失败了怎么办？" class="headerlink" title="第三次握手失败了怎么办？"></a><strong>第三次握手失败了怎么办？</strong></h3><p>当client与server的第三次握手失败了之后，即client发送至server的确认建立连接报文段未能到达server，server在等待client回复ACK的过程中超时了（超过了SYN timeout），<strong>那么server会向client发送一个RTS报文段并进入关闭状态</strong>，即：并不等待client第三次握手的ACK包重传，直接关闭连接请求，这主要是为了<strong>防止SYN泛洪攻击</strong>。</p><h3 id="三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？"><a href="#三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？" class="headerlink" title="三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？"></a>三次握手有什么缺陷可以被黑客利用，用来对服务器进行攻击？</h3><p><strong>SYN泛洪攻击</strong></p><p><strong>黑客仿造IP大量的向服务器发送TCP连接请求报文包，而当服务器返回ACK后，该攻击者就不对其进行再确认从而将server的半连接队列占满</strong>（上文所说的未连接队列，即server收到连接请求SYN之后将client加入半连接队列中），<strong>从而使得server拒绝其他正常的连接请求</strong>。即拒绝服务攻击</p><h3 id="怎么防范这种攻击？"><a href="#怎么防范这种攻击？" class="headerlink" title="怎么防范这种攻击？"></a>怎么防范这种攻击？</h3><p>对于SYN泛洪攻击的防范，优化主机系统设置是常用的手段。</p><ul><li><p>如<strong>降低SYN timeout时间</strong>，使得主机尽快释放半连接的占用；</p></li><li><p>又比如采用SYN cookie设置，如果<strong>短时间内连续收到</strong>某个IP的重复SYN请求，则认为受到了该IP的攻击，<strong>丢弃来自该IP的后续请求报文。</strong></p></li><li><p>此外合理地采用防火墙等外部网络安全设施也可缓解SYN泛洪攻击。</p></li></ul><blockquote><p>SYN timeout时间</p><p>客户端程序因为莫名崩溃等原因，收到SYN+ACK报文后不再回以ACK，服务端将如何处置呢？这时服务端会“优雅地”再等等，会不会是发送的包丢失了呢？于是重新发送一遍SYN+ACK，再收不到来自客户端的ACK响应的话，就把这次连接请求丢弃掉。这个过程大约会“优雅地”持续分钟级，这个持续时间被称作SYN timeout时间。</p></blockquote><h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p>连接的释放</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210831221447248.png" alt="TCP的四次挥手"></p><p>第一次挥手:客户端请求断开，向服务器发送了FIN=1。<br>就是我这边即将要把数据传输完了，我准备跟你断开连接了。</p><p>第二次挥手：服务端收到了FIN标志位后，并不会立即向客户端发送FIN标志位，而是发送一个ACK的应答信息。<br>相当于：你想要关闭的请求我已经收到，但是我可能还没有接受完你的数据，等我数据接受完了我会告诉你。</p><p>第三次挥手：当服务端将最后的数据发送完毕，不再需要连接时，发送连接释放报文，FIN=1。</p><p>第四次挥手：客户端收到请求后，发送一个确认断开连接的请求给服务端。这时候客户端进入<strong>TIME_WAIT状态</strong>，等待 <strong>2 MSL（最大报文存活时间）</strong>后释放连接。 </p><p><strong>为什么客户端最后还要等待2MSL？</strong></p><blockquote><p>MSL（Maximum Segment Lifetime），TCP允许设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>TCP利用<strong>滑动窗口机制</strong>实现流量控制，流量控制是为了<strong>控制发送方发送速率</strong>，<strong>保证接收方来得及接收。</strong></p><p>接收方发送的确认报文中的<strong>窗口字段</strong>（<strong>rwnd</strong>）可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p>rwnd = 0</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>若对网络中某<strong>资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏。这种现象称为<strong>拥塞</strong> (congestion)</p><p>出现拥塞的<strong>原因</strong>：∑对资源需求 &gt; 可用资源</p><p>拥塞往往会趋于恶化：如果网络出现拥塞，分组将会丢失，此时发送方会继续<strong>重传</strong>，从而导致网络拥塞程度更高。</p><p>TCP 主要通过四个算法来进行拥塞控制：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>、<strong>快恢复</strong>。</p><p>为了问题简单化，我们假定：</p><ul><li>数据是<strong>单方向传送</strong>，而另外一个方向只传送确认</li><li>接收方总是<strong>有足够大的接收缓存空间</strong>，因此不会发生流量控制；</li></ul><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方需要维护一个叫做<strong>拥塞窗口（cwnd）</strong>的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p><p>注意<strong>拥塞窗口与发送方窗口的区别</strong>：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口，考虑到接收方的接受能力，发送窗口可能小于拥塞窗口。<strong>发送窗口的上限=Min[rwnd,cwnd].</strong></p><p><strong>慢开始：</strong></p><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd <strong>加倍</strong>，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个<strong>慢开始门限 ssthresh</strong>，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了网络拥塞（其根据就是没有收到确认），令 ssthresh = cwnd / 2，cwnd = 1，然后重新执行慢开始。</p><p><strong>拥塞避免：</strong></p><p>拥塞避免算法思路：让拥塞窗口缓慢增长，即每经过一个往返时间就把发送方的<strong>拥塞窗口cwnd加1</strong>，而不是加倍。这样拥塞窗口按线性规律缓慢增长。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901155452218.png"></p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传和快恢复（FRR）能快速恢复丢失的数据包</p><p><strong>快重传</strong>：</p><p>快重传要求接收方在收到一个<strong>失序</strong>的报文段后就立即发出<strong>重复确认</strong>，发送方只要一连收到<strong>三个重复确认</strong>就应当立即重传对方尚未收到的报文段，不用<strong>重传计时器时间</strong>到期再重传（比如设置60s，如果60s发送端没有收到确认，则重传该数据）。</p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901161422815.png" alt="image-20210901161422815" style="zoom:80%;" /><p><strong>快恢复</strong>：</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时<strong>直接进入拥塞避免</strong>（cwnd每次加一而不是翻倍）。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/image-20210901161722077.png" alt="快恢复"></p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。<strong>慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</strong></p><ul><li></li></ul><h2 id="TCP-和-UDP分别对应的常见应用层协议"><a href="#TCP-和-UDP分别对应的常见应用层协议" class="headerlink" title="TCP 和 UDP分别对应的常见应用层协议"></a>TCP 和 UDP分别对应的常见应用层协议</h2><p>1、 <strong>TCP 对应的应用层协议：</strong> </p><ul><li>FTP：定义了<strong>文件传输协议</strong>，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服 务。下载文件，上传主页，都要用到FTP服务。 </li><li>Telnet：它是一种用于<strong>远程登陆</strong>的端口，用户可以以自己的身份远程连接到计算机上，通过这种端 口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将 23端口打开，对外提供服务。 </li><li>SMTP：定义了<strong>简单邮件传送协议</strong>，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常 见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口 设置这个栏，服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于<strong>接收邮件</strong>。通常情况下，POP3协议所用的是110端口。也是 说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登 陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进 入自己的邮-箱来收信）。 </li><li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议。</li></ul><p> 2、 <strong>UDP 对应的应用层协议：</strong> </p><ul><li>DNS：用于<strong>域名解析服务</strong>，将域名地址转换为IP地址。DNS用的是53号端口。 </li><li>SNMP：<strong>简单网络管理协议</strong>，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 </li><li>TFTP(Trival File Transfer Protocal)：<strong>简单文件传输协议</strong>，该协议在熟知端口69上使用UDP服务</li></ul><h2 id="TCP协议如何保证可靠传输"><a href="#TCP协议如何保证可靠传输" class="headerlink" title="TCP协议如何保证可靠传输"></a>TCP协议如何保证可靠传输</h2><ul><li><p><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据； </p></li><li><p><strong>对失序数据包重排序</strong>：既然TCP报文段作为IP数据报来传输，而IP数据报的到达<strong>可能会失序</strong>，<strong>TCP将对失序数据进行重新排序，然后才交给应用层；</strong> </p></li><li><p><strong>丢弃重复数据</strong>：对于重复数据，能够丢弃重复数据； </p></li><li><p><strong>超时重发</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能 及时收到一个确认，将重发这个报文段； </p></li><li><p><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓 冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使 用的流量控制协议是可变大小的滑动窗口协议</p></li><li><p><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之传输层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——网络层</title>
    <link href="http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2021/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-08-31T12:06:43.000Z</published>
    <updated>2021-09-04T01:59:41.680Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之网络层</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>网络层向上只提供<strong>简单灵活的、无连接的、尽最大努力交付</strong>的数据报服务，不提供服务质量的承诺。即<strong>不可靠传输</strong>，也就是所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的<strong>运输层负责可靠交付</strong>（包括差错处理、流量控制等） 。</li><li>网络在发送分组时<strong>不需要先建立连接</strong>。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li></ul><p>如何将异构的网络互相连接起来？则需要使用一些中间设备进行互连。</p><p>1.物理层中继系统：转发器 (repeater)</p><p>2.数据链路层中继系统：网桥或 桥接器 (bridge)。</p><p>3.网络层中继系统：路由器 (router)。</p><p>4.网桥和路由器的混合物：桥路器 (brouter)。</p><p>5.网络层以上的中继系统：网关 (gateway)。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="IP地址表示方法及其分类"><a href="#IP地址表示方法及其分类" class="headerlink" title="IP地址表示方法及其分类"></a>IP地址表示方法及其分类</h2><p>IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是<strong>唯一的 32 位的标识符</strong></p><h3 id="点分十进制"><a href="#点分十进制" class="headerlink" title="点分十进制"></a>点分十进制</h3><p>将32位二进制<strong>每8个为一组</strong>转化为10进制，每组用小数点隔开</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831201947844.png" alt="点分十进制"></p><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>将IP地址划分为若干个固定类。</p><ul><li>其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络</li><li>而另一个字段则是主机号 host-id，它标志该主机（或路由器）。</li></ul><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831202353408.png" alt="image-20210831202353408" style="zoom:80%;" /><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p>IP地址可分为<strong>ABCDE五类</strong></p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831202500778.png" style="zoom:80%;" /><h2 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h2><ul><li>IP 地址是<strong>网络层和以上各层使用的地址</strong>，是一种<strong>逻辑地址</strong>（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）。</li><li>硬件地址（或物理地址）是数据链路层和物理层使用的地址。</li><li>IP 地址放在 IP 数据报的首部</li><li>硬件地址则放在 MAC 帧的首部。</li></ul><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831202725519.png" style="zoom:80%;" /><h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><h3 id="ARP协议作用"><a href="#ARP协议作用" class="headerlink" title="ARP协议作用"></a>ARP协议作用</h3><p>通信时要使用两个地址：</p><ol><li>IP地址(网络层地址)</li><li>MAC地址(数据链路层地址)</li></ol><p><strong>地址解析协议ARP就是通过从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址</strong>。因为不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</p><p>ARP 实现由 <strong>IP 地址</strong>得到 <strong>MAC 地址</strong>。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831203333054.png" alt="ARP协议的作用"></p><h3 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h3><p>每一个<strong>主机</strong>都设有一个 <strong>ARP 高速缓存 (ARPcache)**，里面存有</strong>所在的局域网上<strong>的各主机和路由器的 **IP 地址到硬件地址的映射表。</strong></p><p><strong>作用</strong>：存放最近获得的 IP 地址到 MAC 地址的映射，以减少 ARP 广播的数量。为了减少网络上的通信量。</p><p><strong>流程</strong>：如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><p>注意：ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831203629409.png" alt="image-20210831203629409"></p><h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了<strong>更有效地转发 IP 数据报和提高交付成功的机会</strong>。它封装在 IP 数据报中，但是不属于高层协议。</p><p>ICMP 报文分为<strong>差错报告报文</strong>和<strong>询问报文。</strong></p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/image-20210831205116023.png" style="zoom:67%;" /><p>ICMP 的两种常见应用：<strong>Ping</strong> 和  <strong>Traceroute</strong>。</p><h3 id="PING-Packet-InterNet-Groper-的应用举例"><a href="#PING-Packet-InterNet-Groper-的应用举例" class="headerlink" title="PING (Packet InterNet Groper) 的应用举例"></a>PING (Packet InterNet Groper) 的应用举例</h3><ul><li><p>主要用来<strong>测试两台主机之间的连通性</strong>。</p></li><li><p>Ping 的原理是通过向目的主机发送 ICMP Echo request 报文，目的主机收到之后会发送 Echo reply报文。Ping 会根据时间和成功响应的次数估算出<strong>数据包往返时间</strong>以及<strong>丢包率</strong>。</p></li><li><p>Ping 是应用层直接使用网络层 ICMP 的例子，</p></li><li><p>它没有通过运输层的 TCP 或 UDP。</p></li></ul><h3 id="Traceroute-的应用举例"><a href="#Traceroute-的应用举例" class="headerlink" title="Traceroute 的应用举例"></a>Traceroute 的应用举例</h3><ul><li><p>用来<strong>跟踪一个分组从源点到终点的路径。</strong></p></li><li><p>traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p></li></ul><ul><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h2 id="虚拟专用网络-VPN"><a href="#虚拟专用网络-VPN" class="headerlink" title="虚拟专用网络 VPN"></a>虚拟专用网络 VPN</h2><p>vpn（Virtual Private Network）</p><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并<strong>不需要把所有的主机接入到外部的互联网中</strong>，机构内的计算机可以使用<strong>仅在本机构有效</strong>的 IP 地址（专用地址）。</p><h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来<strong>将本地 IP 转换为全球 IP。</strong></p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，<strong>使得多个专用网内部的主机共用一个全球 IP 地址</strong>。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之网络层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——数据链路层</title>
    <link href="http://example.com/2021/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://example.com/2021/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-08-29T12:19:48.000Z</published>
    <updated>2021-09-08T14:26:59.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刷了100道题，还是有点感觉了，除了dfs二叉树相关的。</p><p>背点面经</p></blockquote><a id="more"></a><p>参考下面这篇文章的</p><p><a href="https://www.nowcoder.com/discuss/711548?channel=-1&amp;source_id=profile_follow_post_nctrack">https://www.nowcoder.com/discuss/711548?channel=-1&amp;source_id=profile_follow_post_nctrack</a>  </p><p>1.操作系统</p><p>1.1 linux 杀掉一个进程，怎么操作？</p><p>ps -ef | grep 正则表达式     来查询进程pid  （其中-e为显示所有进程，-f为全格式显示。）</p><p>然后 kill pid</p><p>强制杀死 kill - 9 pid</p><p>其中默认是 kill pid  相当于 kill -15 pid， 默认信号是15，有时候程序接到这个信号时会先释放自己的资源，做一些准备工作然后再干净地退出，<strong>即有可能不会立马退出</strong></p><p>kill -9 会<strong>强制进程退出</strong></p><p>1.2 32、64位操作系统区别</p><p>32位就每次处理32个0和1的组合 4g内存（2^30 = 1GB ), 有外设需占用内存，实际可以使用的达不到4G。64位就每次处理64个0和1的组合 。所以说64位应该更快。</p><p>1.3 操作系统的虚拟内存管理</p><p>分页式内存管理和分段式内存管理</p><p>2.计网</p><p>2.1 浏览器提示找不到IP地址，怎么解决？</p><p>DNS解析  Domain Name System  域名系统</p><p>2.2 DNS解析过程</p><p>域名是为了方便记忆而专门建立的一套地址转换系统，要访问一台互联网上的服务器，最终还必须通过<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>来实现，域名解析就是将域名重新转换为IP地址的过程。一个域名对应一个IP地址，一个IP地址可以对应多个域名；所以多个域名可以同时被解析到一个IP地址。域名解析需要由专门的域名解析服务器(DNS)来完成。</p><p>使用的传输层协议： TCP、UDP</p><p>2.3 TCP如何保证可靠传输</p><hr><p>ISP   Internet Service Provider   互联网服务提供商</p><p>IXP  Internet Exchange Point   互联网交换中心</p><p>主机之间的通信方式：</p><p>c/s 模式</p><p>p2p模式</p><h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><p><strong>举个例子</strong>：</p><p>从A找到一条通往E的路径并建立会话的过程中，我们称之为<strong>电路交换</strong>的第一阶段—-<strong>建立连接</strong>。</p><p>之后A和E在通话的过程中会始终霸占着这条路径，数据传输的过程称为电路交换的第二阶段—-<strong>数据传输</strong>。</p><p>电路交换的第三阶段，也就是最后一个阶段—-<strong>释放连接</strong>。A和B只要有一方挂了电话，那便了开始释放连接。</p><p><strong>优点：</strong></p><p>1、传输速度快、高效。</p><p>2、实时。</p><p><strong>缺点：</strong></p><p>1、资源利用率低。（有可能占用着路线但没有进行通信）</p><p>2、新建连接需要占据一定的时间，甚至比通话的时间还长。</p><h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2. 分组交换"></a>2. 分组交换</h3><p>所谓分组，就是将一个数据包分成一个个更小的数据包。每个数据包由文件头和数据组成。分组交换采取<strong>存储转发</strong>传输的机制</p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831155035763.png" alt="数据包" style="zoom:67%;" /><p>举个例子：我们生活中邮局的信件传输</p><p><strong>缺点：</strong></p><p>1、不具有实时性。</p><p>2、存在延时。 （A通过中介B到达E，并不是实时传输的）</p><p>3、会造成通信阻塞。 （太多数据包丢给路由器B后会造成堵塞）</p><p>4、存在无用的重复数据。（每个小数据包中的文件头有许多重复的数据）</p><p>5、会出现丢包的情况。 （路由器B的容量是有限的，如果有太多的数据包丢给它，它可能会容纳不下造成丢包）</p><p><strong>致命的优点：</strong></p><p>1、设计简单 。</p><p>2、资源利用率很高。</p><h3 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h3><p>当然，还有一种<strong>报文交换</strong>的方式，就是一<strong>整个数据包存储转发</strong>的，不过这种方式使用的比较少</p><h3 id="4-三种交换方式示意图"><a href="#4-三种交换方式示意图" class="headerlink" title="4. 三种交换方式示意图"></a>4. 三种交换方式示意图</h3><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831155953905.png" alt="三种交换方式示意图" style="zoom:67%;" /><p>详细见下面的链接</p><p><a href="https://blog.csdn.net/m0_37907797/article/details/104228141">电路交换与分组交换有什么区别？</a></p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831153735903.png" alt="分层" style="zoom:67%;" /><p>1.<strong>三个体系的简要介绍：</strong></p><p>OSI由于体系比较复杂，而且设<strong>计先于实现</strong>，有许多设计过于理想，<strong>不太方便计算机软件实现</strong>，因而完全实现OSI参考模型的系统不多，应用的范围有限。</p><p>TCP/IP协议最早在计算机系统中实现，在Linux、Windows平台中都<strong>有稳定的实现</strong>，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP/IP协议已成为目前互联网事实上的国际标准和工业标准。</p><p>五层协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：<strong>物理层、数据链路层、网络层、运输层、应用层。</strong>（最底下两层可以称为网络接口层）</p><p>五层协议的体系结构只是为<strong>介绍网络原理而设计</strong>的，实际应用还是TCP/IP四层体系结构。</p><p>在互联网使用的各种协中最重要和最著名的就是 <strong>TCP/IP</strong> 两个协议。现在人们经常提到的TCP/IP 并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整<strong>个TCP/IP协议族。</strong></p><p>2.<strong>一些层的常用协议：</strong>　</p><p>数据链路层：ppp协议、CSMA/CD 协议</p><p>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（交换机）</p><p>传输层：TCP、UDP</p><p>应用层：FTP、HTTP、DNS、SMTP、Telnet、WWW、NFS</p><p>3.<strong>每一层大概的作用：</strong></p><p>4.<strong>数据在各层之间的传递过程</strong></p><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有<strong>下面三层协议（物理层、数据链路层、网络层），</strong>因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层主要有两个功能 ：<strong>帧编码</strong>和<strong>误差纠正控制</strong></p><p>数据链路层使用的信道主要有两种类型：<strong>点对点信道</strong>(PPP协议)和<strong>广播信道</strong>（CSMA/CD 协议）。</p><ul><li>数据链路层传送的是<strong>帧</strong>，那么就要考虑三个基本的问题。</li></ul><p><strong>1. 封装成帧</strong></p><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831170624807.png"></p><p><strong>2.透明传输问题</strong></p><p>透明指的是对外界是<strong>不可见的</strong>。</p><ul><li>SOH表示帧的首部开始</li><li>EOT表示帧的结束</li></ul><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831171037929.png" style="zoom:67%;" /><ul><li>思考：但是如果数据中的某个字节的二进制代码恰好和 SOH 或EOT 一样，数据链路层会不会错误地“找到帧的边界”？</li><li>答案：会的，这就是透明传输问题。</li></ul><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831171213023.png" style="zoom: 67%;" /><ul><li><p>解决方法：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符，接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831193739949.png" alt="解决"></p></li></ul><p><strong>3.差错检测</strong></p><p>目前数据链路层广泛使用了<strong>循环冗余检验（CRC）</strong>来检查比特差错。</p><h3 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用<strong>信道复用技术</strong>，一是使用 <strong>CSMA/CD 协议。</strong></p><p>信道复用技术：频分服用、时分复用、码分复用等</p><h3 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h3><p>一对一通信。 point to point</p><p>因为不会发生碰撞，因此也比较简单，使用 <strong>PPP 协议</strong>进行控制。</p><h3 id="3-CSMA-CD-协议"><a href="#3-CSMA-CD-协议" class="headerlink" title="3. CSMA/CD 协议"></a>3. CSMA/CD 协议</h3><p>CSMA/CD 含义： 载波监听多点接入 / 碰撞检测(Carrier Sense Multiple Access with CollisionDetection) 。</p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831165301685.png" style="zoom: 80%;" /><ul><li><strong>多点接入</strong> ：说明这是<strong>总线型网络</strong>，许多主机以多点的方式连接到总线上。</li><li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li><li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，<strong>但是由于电磁波的传播时延的存在，还是有可能会发生碰撞</strong>。</li></ul><h3 id="4-ppp协议"><a href="#4-ppp协议" class="headerlink" title="4. ppp协议"></a>4. ppp协议</h3><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是<strong>用户计算机和 ISP 进行通信时所使用的数据链路层协议。</strong></p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831194112245.png" alt="ppp协议" style="zoom:80%;" /><h2 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h2><p><strong>MAC层是数据链路层的两个子层之一。</strong></p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831195740975.png"></p><p>在局域网中，硬件地址又称为物理地址，或 <strong>MAC 地址。</strong></p><p>MAC 地址是<strong>链路层地址</strong>，长度为 <strong>6 字节</strong>（48 位），用于唯一标识<strong>网络适配器</strong>（网卡）。</p><p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的<strong>广播信道</strong>。</p><p>主要特点：</p><ul><li><p><strong>网络为一个单位所拥有</strong></p></li><li><p><strong>地理范围和站点数目均有限</strong>。</p></li></ul><p>什么是局域网？比如我们小时候上信息课的机房就是一个局域网。</p><p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p><p>可以按照网络拓扑结构对局域网进行分类：</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831194641442.png" alt="按拓扑结构分类"></p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是一种<strong>星型拓扑结构局域网</strong>。</p><p>早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了<strong>碰撞。</strong></p><p>目前以太网使用<strong>交换机</strong>替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机具有<strong>自学习能力</strong>，学习的是<strong>交换表</strong>的内容，<strong>交换表中存储着 MAC 地址到接口的映射</strong>。</p><p>正是由于这种自学习能力，因此交换机是一种<strong>即插即用设备，不需要网络管理员手动配置交换表内容。</strong></p><p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p><p><img src="/images/%E9%9D%A2%E5%90%91%E9%9D%A2%E7%BB%8F%E5%AD%A6%E4%B9%A0/image-20210831195056450.png" alt="交换机"></p><h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;刷了100道题，还是有点感觉了，除了dfs二叉树相关的。&lt;/p&gt;
&lt;p&gt;背点面经&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划问题</title>
    <link href="http://example.com/2021/08/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/08/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</id>
    <published>2021-08-01T10:07:15.000Z</published>
    <updated>2021-08-01T13:03:46.032Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果哪天我把动态规划弄明白了，我就去楼上楼吃顿好的</p></blockquote><a id="more"></a><p>强推！看这个入门 <a href="https://zhuanlan.zhihu.com/p/91582909%EF%BC%8C%E7%9C%8B%E5%AE%8C%E4%B9%8B%E5%90%8E%E8%BF%9E%E8%BF%87%E5%87%A0%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%BE%88%E5%9F%BA%E6%9C%AC%E7%9A%84%E9%A2%98%E7%9B%AE%E3%80%82">https://zhuanlan.zhihu.com/p/91582909，看完之后连过几题，可以解决很基本的题目。</a></p><p>如果想要深入需要多做题目练习。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果哪天我把动态规划弄明白了，我就去楼上楼吃顿好的&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java中,为什么byte类型的取值范围为-128~127?</title>
    <link href="http://example.com/2021/07/31/Java%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA-128-127/"/>
    <id>http://example.com/2021/07/31/Java%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA-128-127/</id>
    <published>2021-07-31T03:45:11.000Z</published>
    <updated>2021-08-01T01:49:48.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在java中，我们知道，byte类型是1字节8位的，取值范围是 -128~127，第一位是符号位。那么按理说0111 1111是最大值，表示127；1111 1111是最小值，表示 -127， 那么 -128是怎么来的呢？</p></blockquote><a id="more"></a><p>在解释这个问题之前我们需要了解几个概念：<strong>机器数</strong>、<strong>真值</strong>、<strong>原码</strong>、<strong>反码</strong>、<strong>补码</strong><br><strong>机器数</strong>：</p><p>一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1。</p><p>比如：十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。那么，这里的 00000011 和 10000011 就是机器数。</p><p><strong>真值</strong>：<br>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1</p><p><strong>原码</strong>：<br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>[+1]原 = 0000 0001<br>[-1]原 = 1000 0001<br>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]<br>即[-127 , 127]。原码是人脑最容易理解和计算的表示方式.</p><p><strong>反码</strong>：<br>反码的表示方法是:正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</p><p>[+1] = [00000001]原 = [00000001]反<br>[-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><p><strong>补码</strong>：<br>补码的表示方法是:</p><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补<br>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><p><strong>总结</strong>：</p><p>1.计算机系统中,数值一律用<strong>补码</strong>来表示(存储)。</p><p>2.正数：<br>正数的反码和补码都与原码相同</p><p>3.负数：<br>负数的反码：原码中除去符号位，其他的数值位取反，0变1，1变0。    负数的补码：反码+1</p><p>4.对于二进制，“减1取反”和“取反加1”的效果是一样的，所以<strong>补码的补码就是原码</strong>；</p><p>所以我们从负数的补码求它的原码时，只需要取反加一，而不需要减一取反（这样是对的，但是容易算错）</p><p>例如：</p><img src="/images/Java%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88byte%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA-128-127/image-20210731114909912.png" style="zoom:67%;" /><hr><p><strong>解释：为什么byte类型的取值范围为-128~127？</strong></p><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:</p><p>　　[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>　　所以不需要过多解释. 但是对于负数:</p><p>　　[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>　　可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p><p>　　首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.</p><p>　　于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p><p>　　如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.</p><p>　　为了解决原码做减法的问题, 出现了反码:</p><p>　　计算十进制的表达式: 1-1=0</p><p>　　1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p><p>　　发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现<strong>在”0”这个特殊的数值上.</strong> 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有**[0000 0000]原和[1000 0000]原两个编码表示0.**</p><p>　　于是补码的出现, 解决了0的符号以及两个编码的问题:</p><p>　　1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 =[0000 0001]反 + [1111 1110]反= [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p><p>这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用**[1000 0000]表示-128:**</p><p>　　(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p><p>　　-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以**-128并没有原码和反码表示**.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)，使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够<strong>多表示一个最低数</strong>. 这就是为什么8位二进制, **使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]**。</p><p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值。</p><p>参考文章：<a href="https://blog.csdn.net/qq_23418393/article/details/57421688">Java中，为什么byte类型的取值范围为-128~127?</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在java中，我们知道，byte类型是1字节8位的，取值范围是 -128~127，第一位是符号位。那么按理说0111 1111是最大值，表示127；1111 1111是最小值，表示 -127， 那么 -128是怎么来的呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>java中的位运算</title>
    <link href="http://example.com/2021/07/31/java%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2021/07/31/java%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-07-31T03:23:31.000Z</published>
    <updated>2021-08-30T03:37:06.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java提供的位运算符有：左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; ) 、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。</p></blockquote><a id="more"></a><h2 id="1、左移-lt-lt-一个数左移n位，相当于这个数乘上2的n次方"><a href="#1、左移-lt-lt-一个数左移n位，相当于这个数乘上2的n次方" class="headerlink" title="1、左移( &lt;&lt; )    一个数左移n位，相当于这个数乘上2的n次方"></a><strong>1、左移( &lt;&lt; )</strong>    一个数左移n位，相当于这个数乘上2的n次方</h2><p>Test1、将5左移2位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xcy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">5</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//运行结果是20</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是20，但是程序是怎样执行的呢？</p><p>首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):</p><p><code>0000 0000 0000 0000 0000 0000 0000 0101</code>           然后左移2位后，低位补0：</p><p><code>0000 0000 0000 0000 0000 0000 0001 0100</code>           换算成10进制为20</p><h2 id="2、右移-gt-gt-右移同理，只是方向不一样罢了-一个数右移n位，相当于这个数除上2的n次方"><a href="#2、右移-gt-gt-右移同理，只是方向不一样罢了-一个数右移n位，相当于这个数除上2的n次方" class="headerlink" title="2、右移( &gt;&gt; )   右移同理，只是方向不一样罢了     一个数右移n位，相当于这个数除上2的n次方"></a><strong>2、右移( &gt;&gt; )   右移同理，只是方向不一样罢了</strong>     一个数右移n位，相当于这个数除上2的n次方</h2><p>System.out.println(5&gt;&gt;2);//运行结果是1</p><p>还是先将5转为2进制表示形式：</p><p><code>0000 0000 0000 0000 0000 0000 0000 0101</code> 然后右移2位，高位补0：</p><p><code>0000 0000 0000 0000 0000 0000 0000 0001</code></p><h2 id="3、无符号右移-gt-gt-gt-没有无符号左移"><a href="#3、无符号右移-gt-gt-gt-没有无符号左移" class="headerlink" title="**3、无符号右移( &gt;&gt;&gt; ) **   没有无符号左移"></a>**3、无符号右移( &gt;&gt;&gt; ) **   没有无符号左移</h2><p>我们知道在Java中int类型占32位，可以表示一个正数，也可以表示一个负数。正数换算成二进制后的最高位为0，负数的二进制最高为为1</p><p>例如  -5换算成二进制后为：</p><p>1111 1111 1111 1111 1111 1111 1111 1011   (在计算机内存中负数用补码的形式保存)</p><p>我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xcy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">5</span>&gt;&gt;<span class="number">3</span>);<span class="comment">//结果是0</span></span><br><span class="line">System.out.println(-<span class="number">5</span>&gt;&gt;<span class="number">3</span>);<span class="comment">//结果是-1</span></span><br><span class="line">System.out.println(-<span class="number">5</span>&gt;&gt;&gt;<span class="number">3</span>);<span class="comment">//结果是536870911</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看它的移位过程(可以通过其结果换算成二进制进行对比)：</p><p>5换算成二进制： 0000 0000 0000 0000 0000 0000 0000 0101<br>5右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000        // (<strong>用0进行补位</strong>)</p><p> -5换算成二进制： 1111 1111 1111 1111 1111 1111 1111 1011<br>-5右移3位后结果为-1，-1的二进制为：  1111 1111 1111 1111 1111 1111 1111 1111   // (<strong>用1进行补位</strong>)<br>-5无符号右移3位后的结果 536870911 换算成二进制：  0001 1111 1111 1111 1111 1111 1111 1111   // (用0进行补位)</p><p>通过其结果转换成二进制后，我们可以发现，<strong>正数右移，高位用0补，负数右移，高位用1补，当负数使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)</strong></p><p><strong>注意：笔者在这里说的是右移，高位补位的情况。正数或者负数左移，低位都是用0补。</strong></p><h2 id="4、位与-amp"><a href="#4、位与-amp" class="headerlink" title="4、位与( &amp; )"></a><strong>4、位与( &amp; )</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xcy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">5</span> &amp; <span class="number">3</span>);<span class="comment">//结果为1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">还是老套路，将<span class="number">2</span>个操作数和结果都转换为二进制进行比较：</span><br><span class="line"><span class="number">5</span>转换为二进制：<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>转换为二进制：<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure><p>1转换为二进制：0000 0000 0000 0000 0000 0000 0000 0001</p><p><strong>位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0</strong></p><h3 id="一些性质：-（用这个性质可以用来计算一个数二进制中-1-的出现的次数）"><a href="#一些性质：-（用这个性质可以用来计算一个数二进制中-1-的出现的次数）" class="headerlink" title="一些性质： （用这个性质可以用来计算一个数二进制中 1 的出现的次数）"></a><strong>一些性质：</strong> （用这个性质可以用来计算一个数二进制中 1 的出现的次数）</h3><p>1.当一个数二进制最后一位为1时（相当于这个数为奇数时）， A &amp; 1 = 1</p><p>当一个数二进制最后一位为0时，（为偶数） ，A &amp; 1 = 0 </p><p>2.Brian Kernighan 算法进行优化，具体地，该算法可以被描述为这样一个结论：记 f(x)表示 x 和 x−1 进行与运算所得的结果（即 f(x)=x &amp; (x−1)），那么 f(x)恰为 x 删去其二进制表示中最右侧的 1 的结果。</p><p>比如 3 ： 011  </p><p>​        4 ： 100</p><p>​        5 ： 101</p><p>那么 4 &amp; 3 = 000     </p><p>​        5 &amp; 4 = 100     ，都是去掉了x二进制中最右侧的一个1的结果</p><h2 id="5、位或"><a href="#5、位或" class="headerlink" title="5、位或( | )"></a><strong>5、位或( | )</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xcy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">5</span> | <span class="number">3</span>);<span class="comment">//结果为7</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>转换为二进制：<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>转换为二进制：<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure><p>7转换为二进制：0000 0000 0000 0000 0000 0000 0000 0111</p><p><strong>位或操作：第一个操作数的的第n位于第二个操作数的第n位 只要有一个是1，那么结果的第n为也为1，否则为0</strong></p><h2 id="6、位异或"><a href="#6、位异或" class="headerlink" title="6、位异或( ^ )"></a>6、位异或( ^ )</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xcy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="number">5</span> ^ <span class="number">3</span>);<span class="comment">//结果为6</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0<strong>101</strong></p><p>3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0<strong>011</strong></p><p>6转换为二进制：0000 0000 0000 0000 0000 0000 0000 0<strong>110</strong></p><p>位异或：对应位相同则为0，对应为不同则为1</p><h3 id="位异或一些性质"><a href="#位异或一些性质" class="headerlink" title="位异或一些性质"></a><strong>位异或一些性质</strong></h3><p>1.任何数与0异或都是它本身   A ^ 0 = A</p><p>2.任何数与本身异或都是0      A ^ A = 0</p><p>3（1）交换律： A ^ B = B ^ A</p><p>  （2）结合律： ( A ^ B ) ^ C = A ^ ( B ^ C )</p><h3 id="位异或的例子"><a href="#位异或的例子" class="headerlink" title="位异或的例子"></a>位异或的例子</h3><p><strong>1.变量交换</strong></p><p>示例：将 a 和 b 两个变量值交换，例如： a = 3，b = 7，交换后，a = 7，b = 3。</p><p>只要连着三次 a ^ b即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规方法</span></span><br><span class="line"><span class="keyword">int</span> temp = a;  <span class="comment">// temp = 3</span></span><br><span class="line">a = b;         <span class="comment">// a = 7</span></span><br><span class="line">b = temp;      <span class="comment">// b = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或方法</span></span><br><span class="line">a = a ^ b;  <span class="comment">// a = 3 ^ 7</span></span><br><span class="line">b = a ^ b;  <span class="comment">// b = (3 ^ 7) ^ 7 = 3 ^ (7 ^ 7) = 3</span></span><br><span class="line">a = a ^ b;  <span class="comment">// a = (3 ^ 7) ^ (3 ^ 7 ^ 7) = (3 ^ 3) ^ (7 ^ 7) ^ 7 = 7</span></span><br></pre></td></tr></table></figure><p><strong>2.排除偶次重复</strong></p><p>示例：在一个整数数组中，仅存在一个不重复的数字，其余数字均出现两次（或偶数次），找出不重复数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异或方法：将所有整数异或，出现偶数次的整数会被抵消，最终留下不重复整数。</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; numArray.length; index++) &#123;</span><br><span class="line">    result = result ^ numArray[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>3.将数字1-1000存放在一个大小为1001的数组中，其中只有一个数字重复出现两次，找出重复数字</p><p>用0~1000 与这些数异或，只出现一次的数字都被抵消掉了，剩下的就是那个出现两次的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用0~1000 这1001个数与大小为1001的数组中的数异或</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    result = result ^ a[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.一个小知识点： 1^2^3…^999 = 0 </p><h2 id="7、位非-位非是一元操作符"><a href="#7、位非-位非是一元操作符" class="headerlink" title="7、位非( ~ )           位非是一元操作符"></a>7、位非( ~ )           位非是一元操作符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xcy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(~<span class="number">5</span>);<span class="comment">//结果为-6</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101</p><p>-6转换为二进制：1111 1111 1111 1111 1111 1111 1111 1010</p><p>位非：操作数的第n位为1，那么结果的第n位为0，反之。</p><h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>位运算符的<strong>优先级</strong></p><p>比如 a = a + b &amp; 1;  这样的话，会先计算 a + b ，在计算 他们的和与 1 的按位与</p><p>需要改成 a = a + ( b &amp; 1); 或者 a += b&1;  </p><p>原文链接：<a href="https://blog.csdn.net/xiaochunyong/article/details/7748713">https://blog.csdn.net/xiaochunyong/article/details/7748713</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java提供的位运算符有：左移( &amp;lt;&amp;lt; )、右移( &amp;gt;&amp;gt; ) 、无符号右移( &amp;gt;&amp;gt;&amp;gt; ) 、位与( &amp;amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="http://example.com/2021/07/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/07/30/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-30T08:24:04.000Z</published>
    <updated>2021-09-18T03:46:00.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总结一下各种排序算法，哈哈好像以前基本上都是用冒泡算法</p><p>想着到时候整个手撕快排不会就尴尬了</p></blockquote><a id="more"></a><p>默认从小到大排列</p><p><strong>哪些排序不会占用额外的内存空间？</strong>（待解决）  从空间复杂度来分析</p><p>各种排序的时间复杂度（不只是要死记，怎么推导）</p><p>快速排序和堆排序  ，这两种排序都要到了递归，如何理解？</p><p><img src="/images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210731105417188.png" alt="各种排序方式总结"></p><p><strong>名词解释：</strong></p><ul><li>n：数据规模</li><li>k：”桶”的个数</li><li>In-place：占用常数内存，不占用额外内存</li><li>Out-place：占用额外内存</li><li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。</p><p>想想这个名词的由来，像水里面的泡泡一样，越接近水面，泡泡越大。</p><p>思想：在每一躺中比较相邻的元素，第一个比第二个大，就交换他们两个，这样每趟都能保证最大的元素放在最后面</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>简要: <strong>从无序序列中分别取出最小值放到第一位、第二位、第三位…以此类推</strong></p><p>无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><p><img src="/C:/Users/1/Desktop/selectionSort.gif" alt="selectionSort"></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>简要：从无序序列中取出第一个插入到有序序列的正确位置。</p><p>将第一待排序序列<strong>第一个元素看做一个有序序列</strong>，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><p><img src="/C:/Users/1/Desktop/insertionSort.gif" alt="insertionSort"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>简要：<strong>分组的插入排序，改进版</strong></p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对<strong>几乎已经排好序的数据操作时，效率高</strong>，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”<strong>基本有序</strong>“时，再对全体记录进行依次直接插入排序。</p><p>在此我们选择增量 <strong>gap=length/2</strong>，缩小增量以 <strong>gap = gap/2</strong> 的方式，用序列 <strong>{n/2,(n/2)/2…1}</strong> 来表示。</p><p>（1）初始增量第一趟 <strong>gap = length/2 = 4</strong></p><img src="/images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210730200159718.png" alt="希尔排序1" style="zoom:67%;" /><p>（2）第二趟，增量缩小为 2</p><img src="/images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210730200333545.png" alt="希尔排序2" style="zoom:67%;" /><p>（3）第三趟，增量缩小为 1,此时相当于直接插入排序</p><img src="/images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210730200410694.png" alt="希尔排序3" style="zoom:67%;" /><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><p>采用了分治的思想</p><p><img src="/images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210730205716050.png" alt="归并排序"></p><p>看不懂递归的算法</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/C:/Users/1/Desktop/QuickSort.jpg" alt="QuickSort"></p><p>上面是<strong>一趟排序</strong>，实现基准值左边的数都比它小，基准值右边的数都比它大。</p><p>接着再对左右区间分别排序，直到每个区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] a = &#123;<span class="number">12</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">67</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">21</span>&#125;;</span><br><span class="line">    quickSort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i:a) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;   </span><br><span class="line"><span class="comment">//获得基准值的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里 left 和 right 都一样，因为此时left指针和right指针相遇</span></span><br><span class="line">    nums[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   下面这种是基于交换的快排    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray (<span class="keyword">int</span>[] nums) &#123;   </span><br><span class="line">quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = partition(nums,low,high);</span><br><span class="line">        quickSort(nums,low,index-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,index+<span class="number">1</span>,high);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivot = nums[low];</span><br><span class="line">        <span class="keyword">int</span> start = low;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[hight] &gt;= pivot) high--;           </span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= pivot) low++;</span><br><span class="line">            <span class="keyword">if</span> (low &gt;= high) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, low, high);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基准值归位</span></span><br><span class="line">        swap(nums,start,low);</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line"> &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>若遇到待排序序列为正序或者逆序，按一般的快排性能不好，退化为斜二叉树，性能类似于冒泡排序，因此我们随机选取基准值pivot，称为<strong>随机化快排</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机化快排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> index = randomPartition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//把基准值放到他应该在的位置，并返回其所在下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= pivot)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= pivot)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Random().nextInt(int num) : 返回一个 0 ~ num - 1 的随机整数。</span></span><br><span class="line">        <span class="keyword">int</span> randomNum = <span class="keyword">new</span> Random().nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="comment">//将这个随机下标与第一个数交换，后面的步骤就和一般的快排相同。</span></span><br><span class="line">        swap(nums, randomNum, left);</span><br><span class="line">        <span class="keyword">return</span> partition(nums, left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换nums[left] 和 nums[right] 的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>最优O(nlogn)，最坏O(n^2)，平均时间复杂度为O(nlogn)。</p><p>最优情况下，每次取的基准值都是待排序列的中间值，这样可以使递归树比较平衡。</p><p>最坏情况下，每次的待排序序列为正序或者逆序，基准值为最边上的值，需要n-1次递归调用，想象成一颗斜树。</p><p><strong>空间复杂度：</strong></p><p>主要是递归造成的栈空间的使用，最优O(logn)，最坏O(n)，平均空间复杂度为O(logn)。</p><p>最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)。</p><p>最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)。</p><p>由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种<strong>不稳定</strong>的排序方法</p><blockquote><p>稳定性：</p><p>数组中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！</p></blockquote><p>关于稳定性的讨论，我们举出一个反例即可：</p><p>[2, 3, 1, 1*]</p><p>一趟排序后 ： [1*, 1, 2, 3]</p><p>第二趟：[1*, 1, 2, 3] ，显然是不稳定的</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>什么是堆？</p><p>堆是一颗完全二叉树，<strong>每个结点大于等于其左右孩子结点的值，称为大顶堆；或者每个结点小于等于其左右孩子结点的值，称为小顶堆。</strong></p><p><img src="/images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210903214542526.png"></p><p><strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p><strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p><strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序</strong></p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>这篇文章写得很详细<a href="https://www.cnblogs.com/xiaochuan94/p/11198610.html">一文弄懂计数排序算法！</a></p><p>第一版是先找出最大值max，建立一个容量为 max + 1 的数组，<strong>但这样存在问题</strong></p><p>比如一组数据<code>&#123;101,109,108,102,110,107,103&#125;</code>，其中最大值为110，按照基础版的思路，我们需要创建一个长度为111的计数数组，但是我们可以发现，它前面的<code>[0,100]</code>的空间完全浪费了，那怎样优化呢？、</p><p>而且，这种方法不能处理负数， 当 max  &lt; 0 时，不可能创建一个容量为负数的数组</p><p>第二版找出<strong>最大值</strong>和<strong>最小值</strong>，建立一个大小为 max-min+1 容量大小的数组， 最后记得补上值。</p><p>这样可以克服第一种方法的两个问题</p><p><strong>适用情况：</strong></p><p><strong>一是需要排序的元素必须是整数，二是排序元素的取值要在一定范围内，并且比较集中</strong>。只有这两个条件都满足，才能最大程度发挥计数排序的优势。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>类似于一种改进的计数排序</p><img src="/images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/image-20210730223604342.png" alt="桶排序" style="zoom:67%;" /><p>步骤：</p><p>1.确定桶的数量</p><p>2.将数量放入不同的同中  （这两步需要确定放入规则，<strong>即什么范围的数放入哪个桶</strong>）</p><p>3.对每个桶中的数据采取排序  （自己选择排序方式），此时每个桶中的数据是有序的</p><p>4.对每个桶遍历，得到结果。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h2><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=num)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left]=nums[right];</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=num)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right]=nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left]=num;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=findIndex(nums,left,right);</span><br><span class="line">        quickSort(nums,left,index-<span class="number">1</span>);</span><br><span class="line">        quickSort(nums,index+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;总结一下各种排序算法，哈哈好像以前基本上都是用冒泡算法&lt;/p&gt;
&lt;p&gt;想着到时候整个手撕快排不会就尴尬了&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>7.30jvm学习</title>
    <link href="http://example.com/2021/07/30/7-30jvm%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/30/7-30jvm%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-30T01:52:52.000Z</published>
    <updated>2021-08-02T07:39:45.886Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jvm就硬背吧 （这10000字咋背呀^&gt;_&lt;^）</p></blockquote><a id="more"></a><p>面经知识点汇总：</p><p>hashmap、 hashtable、juc包下的东西concurrenthashmap</p><p>多线程：syn</p><p>操作系统：的线程和进程</p><p>jvm: gc、内存模型、类加载机制、jvm调优有哪些锁？</p><p>数据库：mysql和redis ，b和b+</p><p>算法：快排  、两个栈实现队列</p><p>linux：学了哪些命令？</p><p>设计模式：知道哪些？</p><p>有哪些锁？</p><hr><p>作者：牛客网<br>链接：<a href="https://www.zhihu.com/question/431895555/answer/1933089375">https://www.zhihu.com/question/431895555/answer/1933089375</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>这个并不一定所有公司都会问到，但为了确保万无一失，最好还是提前做好准备。这里分享一篇牛客大佬的<a href="https://link.zhihu.com/?target=https://www.nowcoder.com/discuss/627413">《面试小抄》之JVM篇21问与答</a>，帮助大家快速掌握JVM常考面试题。</p><p>本文包含了JVM中内存结构、垃圾回收算法、垃圾回收器、类加载、双亲委派模型、和JVM调优的常见面试题。</p><p>这是本期的 JVM面试题目录，不会的快快查漏补缺~</p><p><img src="https://pic2.zhimg.com/v2-3ef1f1697eac6bcbb6bd02dbf3a1b3b0_b.jpg" alt="img"><img src="https://pic2.zhimg.com/80/v2-3ef1f1697eac6bcbb6bd02dbf3a1b3b0_1440w.jpg" alt="img"></p><h2 id="1-什么是JVM内存结构？"><a href="#1-什么是JVM内存结构？" class="headerlink" title="1. 什么是JVM内存结构？"></a>1. 什么是JVM内存结构？</h2><p><img src="https://pica.zhimg.com/v2-1b82e0a874152d3a2903b6453507ca28_b.jpg" alt="img"><img src="https://pica.zhimg.com/80/v2-1b82e0a874152d3a2903b6453507ca28_1440w.jpg" alt="img"></p><p> jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区； </p><ul><li><p>程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址； </p></li><li><p>虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError； </p></li><li><p>本地方法栈：线程私有的，保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法； </p></li><li><p>堆：java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作； </p></li><li><p>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；</p></li></ul><h2 id="2-什么是JVM内存模型？"><a href="#2-什么是JVM内存模型？" class="headerlink" title="2. 什么是JVM内存模型？"></a>2. 什么是JVM内存模型？</h2><p><strong>Java 内存模型</strong>（下文简称 <strong>JMM</strong>）就是在底层处理器内存模型的基础上，定义自己的多线程语义。它明确指定了一组排序规则，来保证线程间的可见性。 </p><p>这一组规则被称为 <strong>Happens-Before</strong>, JMM 规定，要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 <strong>Happens-Before 关系</strong>： </p><ul><li><p><strong>单线程规则</strong>：一个线程中的每个动作都 happens-before 该线程中后续的每个动作 </p></li><li><p><strong>监视器锁定规则</strong>：监听器的<strong>解锁</strong>动作 happens-before 后续对这个监听器的<strong>锁定</strong>动作 </p></li><li><p><strong>volatile 变量规则</strong>：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作 </p></li><li><p><strong>线程 start 规则</strong>：线程 <strong>start()</strong> 方法的执行 happens-before 一个启动线程内的任意动作 </p></li><li><p><strong>线程 join 规则</strong>：一个线程内的所有动作 happens-before 任意其他线程在该线程 <strong>join()</strong> 成功返回之前 </p></li><li><p><strong>传递性</strong>：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C </p></li></ul><p>怎么理解 happens-before 呢？如果按字面意思，比如第二个规则，线程（不管是不是同一个）的解锁动作发生在锁定之前？这明显不对。happens-before 也是为了保证可见性，比如那个解锁和加锁的动作，可以这样理解，线程1释放锁退出同步块，线程2加锁进入同步块，那么线程2就能看见线程1对共享对象修改的结果。 </p><p><img src="https://pic3.zhimg.com/v2-482730855daadfef126758bb03353f9f_b.jpg" alt="img"><img src="https://pic3.zhimg.com/80/v2-482730855daadfef126758bb03353f9f_1440w.jpg" alt="img"></p><p> Java 提供了几种语言结构，包括 <em>volatile</em>, <em>final</em> 和 <em>synchronized</em>, 它们旨在帮助程序员向<strong>编译器</strong>描述程序的并发要求，其中： </p><ul><li><p><strong>volatile</strong> - 保证<strong>可见性</strong>和<strong>有序性</strong> </p></li><li><p><strong>synchronized</strong> - 保证<strong>可见性</strong>和<strong>有序性</strong>; 通过<strong>管程（Monitor）\</strong>保证一组动作的**原子性** </p></li><li><p><strong>final</strong> - 通过禁止<strong>在构造函数初始化</strong>和<strong>给 final 字段赋值</strong>这两个动作的重排序，保证<strong>可见性</strong>（如果 <strong>this 引用逃逸</strong>就不好说可见性了） </p></li></ul><p>编译器在遇到这些关键字时，会插入相应的内存屏障，保证语义的正确性。 </p><p>有一点需要<strong>注意</strong>的是，<strong>synchronized</strong> <strong>不保证</strong>同步块内的代码禁止重排序，因为它通过锁保证同一时刻只有<strong>一个线程</strong>访问同步块（或临界区），也就是说同步块的代码只需满足 <strong>as-if-serial</strong> 语义 - 只要单线程的执行结果不改变，可以进行重排序。 </p><p>所以说，Java 内存模型描述的是多线程对共享内存修改后彼此之间的可见性，另外，还确保正确同步的 Java 代码可以在不同体系结构的处理器上正确运行。</p><h2 id="3-heap-和stack-有什么区别？"><a href="#3-heap-和stack-有什么区别？" class="headerlink" title="3. heap 和stack 有什么区别？"></a>3. heap 和stack 有什么区别？</h2><p><strong>（1</strong>）申请方式 </p><p>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间 </p><p>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟 </p><p><strong>（2</strong>）申请后系统的响应 </p><p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 </p><p>heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 </p><p><strong>（3</strong>）申请大小的限制 </p><p>stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 </p><p>heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。 </p><p><strong>（4</strong>）申请效率的比较 </p><p>stack：由系统自动分配，速度较快。但程序员是无法控制的。 </p><p>heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。 </p><p><strong>（5</strong>）heap和stack中的存储内容 </p><p>stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 </p><p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 </p><p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p><h2 id="4-什么情况下会发生栈内存溢出？"><a href="#4-什么情况下会发生栈内存溢出？" class="headerlink" title="4. 什么情况下会发生栈内存溢出？"></a>4. 什么情况下会发生栈内存溢出？</h2><p>1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用； 2、当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题； 3、调整参数-xss去调整jvm栈的大小 </p><h2 id="5-谈谈对-OOM-的认识？如何排查-OOM-的问题？"><a href="#5-谈谈对-OOM-的认识？如何排查-OOM-的问题？" class="headerlink" title="5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？"></a>5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？</h2><p>除了程序计数器，其他内存区域都有 OOM 的风险。 </p><ul><li><p>栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM </p></li><li><p>Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效； </p></li><li><p>堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错； </p></li><li><p>方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等； </p></li><li><p>直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。 </p></li></ul><p>排查 OOM 的方法： </p><ul><li><p>增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录； </p></li><li><p>同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域； </p></li><li><p>使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。</p></li></ul><h2 id="6-谈谈-JVM-中的常量池？"><a href="#6-谈谈-JVM-中的常量池？" class="headerlink" title="6. 谈谈 JVM 中的常量池？"></a>6. 谈谈 JVM 中的常量池？</h2><p>JVM常量池主要分为<strong>Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池</strong>。 </p><ul><li><p><strong>Class文件常量池</strong>。class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 </p></li><li><p><strong>运行时常量池</strong>：运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。 </p></li><li><p><strong>全局字符串常量池</strong>：字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。  </p></li><li><p>基本类型包装类对象常量池：java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。 </p></li></ul><h2 id="7-如何判断一个对象是否存活？"><a href="#7-如何判断一个对象是否存活？" class="headerlink" title="7. 如何判断一个对象是否存活？"></a>7. 如何判断一个对象是否存活？</h2><p>判断一个对象是否存活，分为两种算法1：引用计数法；2：可达性分析算法； </p><p><strong>引用计数法</strong>： 给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收； 缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法； </p><p><strong>可达性分析法</strong> 从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种： </p><ul><li><p>虚拟机栈中引用的对象 </p></li><li><p>方法区类静态属性引用的变量 </p></li><li><p>方法区常量池引用的对象 </p></li><li><p>本地方法栈JNI引用的对象 </p></li></ul><p>但一个对象满足上述条件的时候，不会马上被回收，还需要进行两次标记；第一次标记：判断当前对象是否有finalize()方法并且该方法没有被执行过，若不存在则标记为垃圾对象，等待回收；若有的话，则进行第二次标记；第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃；如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收；</p><h2 id="8-强引用、软引用、弱引用、虚引用是什么，有什么区别？"><a href="#8-强引用、软引用、弱引用、虚引用是什么，有什么区别？" class="headerlink" title="8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？"></a>8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？</h2><ul><li><p>强引用，就是普通的对象引用关系，如 String s = new String(“ConstXiong”) </p></li><li><p>软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。SoftReference 实现 </p></li><li><p>弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。WeakReference 实现 </p></li><li><p>虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。PhantomReference 实现 </p></li></ul><h2 id="9-被引用的对象就一定能存活吗？"><a href="#9-被引用的对象就一定能存活吗？" class="headerlink" title="9. 被引用的对象就一定能存活吗？"></a>9. 被引用的对象就一定能存活吗？</h2><blockquote><p>  不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。 </p></blockquote><h2 id="10-Java中的垃圾回收算法有哪些？"><a href="#10-Java中的垃圾回收算法有哪些？" class="headerlink" title="10. Java中的垃圾回收算法有哪些？"></a>10. Java中的垃圾回收算法有哪些？</h2><p>java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法； <strong>标记清除法</strong>： 第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记； 第二步：在遍历一遍，将所有标记的对象回收掉； 特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC； </p><p><img src="https://pic4.zhimg.com/v2-f2311a4ca9e5ba6b9aa344214e9000c1_b.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-f2311a4ca9e5ba6b9aa344214e9000c1_1440w.jpg" alt="img"></p><p><strong>标记整理法</strong>： 第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记； 第二步：将所有的存活的对象向一段移动，将端边界以外的对象都回收掉； 特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生； </p><p><img src="https://pic2.zhimg.com/v2-64b3f99125a72f9ca238a736a46bdff7_b.jpg" alt="img"><img src="https://pic2.zhimg.com/80/v2-64b3f99125a72f9ca238a736a46bdff7_1440w.jpg" alt="img"></p><p><strong>复制算法</strong>： 将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除； 特点：不会产生空间碎片；内存使用率极低； </p><p><strong>分代收集算法</strong>： 根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收； </p><p><strong>对比</strong> </p><p><img src="https://pic2.zhimg.com/v2-8608f268f11f6220b43676e8009c22cd_b.jpg" alt="img"><img src="https://pic2.zhimg.com/80/v2-8608f268f11f6220b43676e8009c22cd_1440w.jpg" alt="img"></p><h2 id="11-有哪几种垃圾回收器，各自的优缺点是什么？"><a href="#11-有哪几种垃圾回收器，各自的优缺点是什么？" class="headerlink" title="11. 有哪几种垃圾回收器，各自的优缺点是什么？"></a>11. 有哪几种垃圾回收器，各自的优缺点是什么？</h2><p>垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1； </p><ul><li><p>Serial:单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，是client级别的默认GC方式。 </p></li><li><p>ParNew:Serial收集器的多线程版本，也需要stop the world，复制算 </p></li><li><p>Parallel Scavenge:新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量； </p></li><li><p>Serial Old:Serial收集器的老年代版本，单线程收集器，使用标记整理算法。 </p></li><li><p>Parallel Old：是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。 </p></li><li><p>CMS:是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片； </p></li><li><p>G1:标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率； </p></li></ul><p><strong>垃圾回收器间的配合使用图：</strong> </p><p><img src="https://pic4.zhimg.com/v2-25cb5804757e48387305cb1501739623_b.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-25cb5804757e48387305cb1501739623_1440w.jpg" alt="img"></p><p><strong>各个垃圾回收器对比</strong>： </p><p><img src="https://pic3.zhimg.com/v2-4579a5210bc3767590eb428bf5509b7a_b.jpg" alt="img"><img src="https://pic3.zhimg.com/80/v2-4579a5210bc3767590eb428bf5509b7a_1440w.jpg" alt="img"></p><h2 id="12-详细说一下CMS的回收过程？CMS的问题是什么？"><a href="#12-详细说一下CMS的回收过程？CMS的问题是什么？" class="headerlink" title="12. 详细说一下CMS的回收过程？CMS的问题是什么？"></a>12. 详细说一下CMS的回收过程？CMS的问题是什么？</h2><p>CMS(Concurrent Mark Sweep，并发标记清除) 收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。 </p><p>从名字就可以知道，CMS是基于“标记-清除”算法实现的。CMS 回收过程分为以下四步： </p><ol><li><p>初始标记 （CMS initial mark)：主要是标记 GC Root 开始的下级（注：仅下一级）对象，这个过程会 STW，但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。 </p></li><li><p>并发标记 (CMS concurrent mark)：根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。这个过程是多线程的，虽然耗时理论上会比较长，但是其它工作线程并不会阻塞，没有 STW。 </p></li><li><p>重新标记（CMS remark）：顾名思义，就是要再标记一次。为啥还要再标记一次？因为第 2 步并没有阻塞其它工作线程，其它线程在标识过程中，很有可能会产生新的垃圾。 </p></li><li><p>并发清除（CMS concurrent sweep）：清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的。</p></li></ol><p><strong>CMS 的问题：</strong> </p><p><strong>1. 并发回收导致CPU资源紧张：</strong> </p><p>在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：（CPU核数 + 3）/ 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。 </p><p><strong>2. 无法清理浮动垃圾：</strong> </p><p>在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。 </p><p><strong>3. 并发失败（Concurrent Mode Failure）：</strong> </p><p>由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX**:** CMSInitiatingOccupancyFraction 参数来设置。 </p><p>这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。 </p><p><strong>4.内存碎片问题：</strong> </p><p>CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。 </p><p>为了解决这个问题，CMS收集器提供了一个 -XX**:<strong>+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX</strong>:**CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。</p><h2 id="13-详细说一下G1的回收过程？"><a href="#13-详细说一下G1的回收过程？" class="headerlink" title="13. 详细说一下G1的回收过程？"></a>13. 详细说一下G1的回收过程？</h2><p>G1（Garbage First）回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。G1设计初衷就是替换 CMS，成为一种全功能收集器。G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于 标记-整理算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制算法实现的。 </p><p><strong>G1 回收过程</strong>，G1 回收器的运作过程大致可分为四个步骤： </p><ol><li><p>初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。 </p></li><li><p>并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。 </p></li><li><p>最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。 </p></li><li><p>清理阶段（会STW）：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。 </p></li></ol><h2 id="14-JVM中一次完整的GC是什么样子的？"><a href="#14-JVM中一次完整的GC是什么样子的？" class="headerlink" title="14. JVM中一次完整的GC是什么样子的？"></a>14. JVM中一次完整的GC是什么样子的？</h2><p>先描述一下Java堆内存划分。 </p><p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的 1/3，老年代默认占 2/3。 新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。 </p><p>新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。 </p><p>老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。 </p><p><img src="https://pic2.zhimg.com/v2-f2a086e09f8bb950b63381145f6f16c2_b.jpg" alt="img"><img src="https://pic2.zhimg.com/80/v2-f2a086e09f8bb950b63381145f6f16c2_1440w.jpg" alt="img"></p><p>再描述它们之间转化流程。 </p><ul><li><p>对象优先在Eden分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。 </p></li><li><ul><li><p>在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区； </p></li><li><p>  Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区； </p></li><li><p>  移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。GC年龄的阀值可以通过参数 -XX:MaxTenuringThreshold 设置，默认为 15； </p></li><li><p>  动态对象年龄判定：Survivor 区相同年龄所有对象大小的总和 &gt; (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 -XX:TargetSurvivorRatio 指定，默认为 50%； </p></li><li><p>  Survivor 区内存不足会发生担保分配，超过指定大小的对象可以直接进入老年代。 </p></li></ul></li><li><p>  大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 </p></li><li><p>  老年代满了而<strong>无法容纳更多的对象</strong>，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – <strong>包括年轻代和老年代</strong>。</p></li></ul><h2 id="15-Minor-GC-和-Full-GC-有什么不同呢？"><a href="#15-Minor-GC-和-Full-GC-有什么不同呢？" class="headerlink" title="15. Minor GC 和 Full GC 有什么不同呢？"></a>15. Minor GC 和 Full GC 有什么不同呢？</h2><p>Minor GC：只收集新生代的GC。 </p><p>Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式。 </p><p><strong>Minor GC触发条件：</strong>当Eden区满时，触发Minor GC。 </p><p><strong>Full GC触发条件</strong>： </p><ul><li><p>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。 </p></li><li><p>老年代空间不够分配新的内存（或永久代空间不足，但只是JDK1.7有的，这也是用元空间来取代永久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率）。 </p></li><li><p>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。 </p></li><li><p>调用System.gc时，系统建议执行Full GC，但是不必然执行。 </p></li></ul><h2 id="16-介绍下空间分配担保原则？"><a href="#16-介绍下空间分配担保原则？" class="headerlink" title="16. 介绍下空间分配担保原则？"></a>16. 介绍下空间分配担保原则？</h2><p>如果YougGC时新生代有大量对象存活下来，而 survivor 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。 </p><p>在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 survivor 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。 </p><p>在允许担保失败并尝试进行YoungGC后，可能会出现三种情况： </p><ul><li><p>① YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中 </p></li><li><p>② YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。 </p></li><li><p>③ YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。 </p></li></ul><p>通过下图来了解空间分配担保原则： </p><p><img src="https://pic2.zhimg.com/v2-230afbe3d56d81be16ec7cd9b4d126d9_b.jpg" alt="img"><img src="https://pic2.zhimg.com/80/v2-230afbe3d56d81be16ec7cd9b4d126d9_1440w.jpg" alt="img"></p><h2 id="17-什么是类加载？类加载的过程？"><a href="#17-什么是类加载？类加载的过程？" class="headerlink" title="17. 什么是类加载？类加载的过程？"></a>17. 什么是类加载？类加载的过程？</h2><p>虚拟机把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象； </p><p>类的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示： </p><p><img src="https://pica.zhimg.com/v2-428183fb231daeaf4571dabf2a19af8c_b.jpg" alt="img"><img src="https://pica.zhimg.com/80/v2-428183fb231daeaf4571dabf2a19af8c_1440w.jpg" alt="img"></p><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） </p><p>类加载过程如下： </p><ul><li><p>加载，加载分为三步： 1、通过类的全限定性类名获取该类的二进制流； 2、将该二进制流的静态存储结构转为方法区的运行时数据结构； 3、在堆中为该类生成一个class对象； </p></li><li><p>验证：验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全； </p></li><li><p>准备：为class对象的静态变量分配内存，初始化其初始值； </p></li><li><p>解析：该阶段主要完成符号引用转化成直接引用； </p></li><li><p>初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程； </p></li></ul><h2 id="18-什么是类加载器，常见的类加载器有哪些？"><a href="#18-什么是类加载器，常见的类加载器有哪些？" class="headerlink" title="18. 什么是类加载器，常见的类加载器有哪些？"></a>18. 什么是类加载器，常见的类加载器有哪些？</h2><p>类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器；类加载器分为以下四种： </p><ul><li><p>启动类加载器（BootStrapClassLoader）：用来加载java核心类库，无法被java程序直接引用； </p></li><li><p>扩展类加载器（Extension ClassLoader）：用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类； </p></li><li><p>系统类加载器（AppClassLoader）：它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的； </p></li><li><p>自定义类加载器：由java语言实现，继承自ClassLoader； </p></li></ul><p><img src="https://pic4.zhimg.com/v2-64c33143d2d28029df7e6ea37659dce0_b.jpg" alt="img"><img src="https://pic4.zhimg.com/80/v2-64c33143d2d28029df7e6ea37659dce0_1440w.jpg" alt="img"></p><h2 id="19-什么是双亲委派模型？为什么需要双亲委派模型？"><a href="#19-什么是双亲委派模型？为什么需要双亲委派模型？" class="headerlink" title="19. 什么是双亲委派模型？为什么需要双亲委派模型？"></a>19. 什么是双亲委派模型？为什么需要双亲委派模型？</h2><p>当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类； </p><p>为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。 </p><p>补充：<strong>那怎么打破双亲委派模型</strong>？ </p><p>自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。 </p><h2 id="20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？"><a href="#20-列举一些你知道的打破双亲委派机制的例子，为什么要打破？" class="headerlink" title="20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？"></a>20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</h2><ul><li><p>JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。 </p></li><li><p>Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。<br>  tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的： </p></li></ul><ul><li><ul><li><p>对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。 </p></li><li><p>与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏； </p></li><li><p>热部署。 </p></li></ul></li></ul><p>tomcat类加载器如下图： </p><p><img src="https://pic2.zhimg.com/v2-0f8b46ab0eef7d30938798eebb401dbb_b.jpg" alt="img"><img src="https://pic2.zhimg.com/80/v2-0f8b46ab0eef7d30938798eebb401dbb_1440w.jpg" alt="img"></p><ul><li><p>OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。 </p></li><li><p>JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。 </p></li></ul><h2 id="21-说一下-JVM-调优的命令？"><a href="#21-说一下-JVM-调优的命令？" class="headerlink" title="21.说一下 JVM 调优的命令？"></a>21.说一下 JVM 调优的命令？</h2><ul><li><p>jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 </p></li><li><p>jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 </p></li><li><p>jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。 </p></li><li><p>jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。 </p></li><li><p>jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jvm就硬背吧 （这10000字咋背呀^&amp;gt;_&amp;lt;^）&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>cpu、寄存器、缓存、内存概念</title>
    <link href="http://example.com/2021/07/28/cpu%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/07/28/cpu%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/</id>
    <published>2021-07-28T07:44:54.000Z</published>
    <updated>2021-09-03T11:56:42.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在看内存结构的时候，经常会出现这些词，来看看他们的概念</p></blockquote><a id="more"></a><img src="/images/cpu%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/image-20210728154648631.png" alt="image-20210728154648631" style="zoom: 80%;" /><p>ROM(read-only memory):</p><p>RAM(read access memory):</p><p><strong>那么cache是属于cpu还是属于内存的呢？</strong>（待解决）</p><p><strong>CPU</strong></p><p>​    CPU是<strong>中央处理器</strong>的简称，它可以从<strong>内存</strong>和<strong>缓存</strong>中读取指令，放入<strong>指令寄存器</strong>，并能够发出控制指令来完成一条指令的执行。<strong>但是CPU并不能直接从硬盘中读取程序或数据。</strong></p><p><a href="https://blog.csdn.net/qq_34720818/article/details/108410627">https://blog.csdn.net/qq_34720818/article/details/108410627</a>  介绍磁盘和内存的关系</p><p><strong>内存</strong></p><p>​    内存作为与CPU直接进行沟通的部件，所有的程序都是在内存中运行的。其作用是暂时存放CPU的运算数据，以及与硬盘交换的数据。也是相当于CPU与硬盘沟通的桥梁。只要计算机在运行，CPU就会把需要运算的数据调到内存中进行运算，运算完成后CPU再将结果传出来。    </p><p><img src="/images/cpu%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/image-20210903195459628.png" alt="image-20210903195459628"></p><p><strong>缓存</strong></p><p>​    缓存是CPU的一部分，存在于CPU里。由于CPU的存取速度很快，而内存的速度很慢，为了不让CPU每次都在运行相对缓慢的内存中操作，缓存就作为一个<strong>中间者</strong>出现了。有些常用的数据或是地址，就直接存在缓存中，这样，下一次调用的时候就不需要再去内存中去找了。因此，CPU每次回先到自己的缓存中寻找想要的东西（一般80%的东西都可以找到），找不到的时候再去内存中获取。</p><p>​    最初的缓存生产成本很高，价格昂贵，所以为了存储更多的数据，又不希望成本过高，就出现了二级缓存的概念，他们采用的并不是一级缓存的SRAM（静态RAM），而是采用了性能比SRAM稍差一些，但是比内存更快的DRAM（动态RAM）</p><p><img src="/images/cpu%E3%80%81%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%81%E7%BC%93%E5%AD%98%E3%80%81%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5/image-20210903195605963.png" alt="image-20210903195605963"></p><p><strong>硬盘</strong></p><p>​      我们都知道内存是掉电之后数据就消失的部件，所以，长期的数据存储更多的还是依靠硬盘这种本地磁盘作为存储工具。</p><p><strong>简单的概括：</strong></p><p>CPU运行时首先会去自身的缓存中寻找，如果没有再去内存中找。</p><p>硬盘中的数据会先写入内存才能被CPU使用。</p><p>缓存会记录一些常用的数据等信息，以免每次都要到内存中，节省了时间，提高了效率。</p><p>内存+缓存 -&gt; 内存储空间 </p><p>硬盘 -&gt; 外存储空间</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在看内存结构的时候，经常会出现这些词，来看看他们的概念&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>7.28java多线程学习</title>
    <link href="http://example.com/2021/07/28/7-28java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/28/7-28java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-28T02:42:49.000Z</published>
    <updated>2021-07-28T02:53:38.725Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>连续学习7天应该能召唤7龙珠吧</p></blockquote><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;连续学习7天应该能召唤7龙珠吧&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>7.27java基础学习</title>
    <link href="http://example.com/2021/07/27/7-27java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/27/7-27java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-27T01:47:41.000Z</published>
    <updated>2021-07-30T02:35:40.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>资本是靠自己挣来的，不是靠别人得到的</p></blockquote><a id="more"></a><p>感觉有点慢，还是需要<strong>加快速度</strong> + 针对性复习，  你想想 java基础、集合、多线程、jvm、数据库、框架、算法题</p><p>集合这里耗了两天，还是有些源码没理解，多线程刚开始看，各种锁和同步机制，jvm里面也全是概念的需要背诵</p><p>项目还没开始做。。。</p><p>每天10h学习能保证吗？有效率的10h，我知道非科班学起来慢，但是人总得有个能成功的念想吧，没有什么事是能随随便便成功的，别嘻嘻哈哈了，每个阶段该干嘛干嘛</p><h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><ul><li>进程是程序的一次执行过程，是操作系统<strong>资源分配的基本单位</strong>，而线程是<strong>任务调度和执行的基本单位</strong></li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段和堆栈，进程的切换花销比较大</li><li>一个进程中可以有多个线程，（通过CPU调度，在每个时间片中只有一个线程执行），线程之间共享进程的<strong>堆和方法区资源</strong>，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。线程之间的切换花销比较小</li><li>线程是进程划分成的更小的运行单位，也被称为<strong>轻量级进程</strong>，线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li></ul><h2 id="并发与并行的关系"><a href="#并发与并行的关系" class="headerlink" title="并发与并行的关系"></a>并发与并行的关系</h2><p>并发： 在一个时间段，多个任务都在执行</p><p>并行：在一个时刻上，多个任务同时执行</p><p>因为cpu在多个进程之间得到切换速度很快，所以看起来是同时运行的</p><h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><p>从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。</p><p>从互联网的发展趋势来看：现在的系统要求的并发量越来越大，使用多线程机制可以大大提高系统整体的并发能力以及性能。</p><p>同时多线程可以<strong>提高CPU利用率</strong>。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU只会一个CPU核心被利用到，而创建多个线程就可以让多个CPU核心被利用到，这样就提高了CPU的利用率。</p><h2 id="使用多线程带来的问题"><a href="#使用多线程带来的问题" class="headerlink" title="使用多线程带来的问题"></a>使用多线程带来的问题</h2><p>我们使用多线程是想要提高程序的<strong>执行效率</strong>提高程序<strong>运行速度</strong>，也可能<strong>内存泄漏</strong>、<strong>上下文切换</strong>、<strong>死锁</strong></p><p>（后面会一一介绍到）</p><h2 id="线程的生命周期和所处状态"><a href="#线程的生命周期和所处状态" class="headerlink" title="线程的生命周期和所处状态"></a>线程的生命周期和所处状态</h2><p>线程的生命周期包含5个阶段，包括：<strong>新建</strong>、<strong>就绪</strong>、<strong>运行</strong>、<strong>阻塞</strong>、<strong>销毁</strong>。</p><ul><li><strong>新建</strong>：就是刚使用new方法，新建出来一个线程；</li><li><strong>就绪</strong>：就是调用的线程的**start()**方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</li><li><strong>运行</strong>：当就绪的线程被调度并获得CPU资源时，便进入运行状态。（run方法定义了线程的操作和功能;</li><li><strong>阻塞</strong>：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify()或者notifyAll()方法。唤醒的线程不会立刻运行，它们要再次等待CPU分配资源进入运行状态;</li><li><strong>销毁</strong>：如果线程<strong>正常执行完毕后</strong>或线程被<strong>提前强制性的终止或出现异常</strong>导致结束，那么线程就要被销毁，释放资源;</li></ul><p><strong>如下图所示</strong>：</p><p><img src="/images/7-27java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210727205111030.png" alt="线程的生命周期"></p><h2 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h2><p>我们知道一个CPU核心在任意时刻只能被一个线程使用，为了实现多线程，CPU采取的策略是给每个线程分配时间片并进行轮转的。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完CPU时间片，并切换到另一个任务之前，会先保存自己的状态，以便下次再切换回这个任务，<strong>任务从保存到再加载的过程就是一次上下文切换。</strong></p><p>上下文切换通常是计算密集型，也就是说它就会带来系统开销，耗费大量的CPU时间，带来性能问题</p><h2 id="死锁的相关知识"><a href="#死锁的相关知识" class="headerlink" title="死锁的相关知识"></a>死锁的相关知识</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>是指多个线程在运行过程中因争夺资源而造成的一种僵局，它们中的一个或者多个都在等待某个资源被释放。</p><p>我们举一个例子：比如说，线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，都在等待对方释放自己所需要的资源，那么这时候两个线程就会互相等待而进入死锁状态。</p><img src="/images/7-27java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210727212453831.png" alt="死锁的例子" style="zoom:67%;" /><h3 id="死锁产生的原因？"><a href="#死锁产生的原因？" class="headerlink" title="死锁产生的原因？"></a>死锁产生的原因？</h3><p>我们知道系统中的资源可以分为两类，一类是可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放。</p><p>第一个原因，因为多个进程之间<strong>竞争不可剥夺资源</strong>，比如说有一个进程抢占了打印机，其他进程只能等这个进程使用完成后才能使用。（举个例子假定进程PI已占用了打印机R1，进程P2已占用了磁带机R2，若P2继续要求打印机R1，P2将阻塞；P1若又要求磁带机，P1也将阻塞。于是，在P1和P2之间就形成了僵局）</p><p>第二个原因，竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p><p>第三个原因，进程间推进顺序非法</p><p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。</p><h3 id="死锁的必要条件？（4个，缺一不可）"><a href="#死锁的必要条件？（4个，缺一不可）" class="headerlink" title="死锁的必要条件？（4个，缺一不可）"></a>死锁的必要条件？（4个，缺一不可）</h3><p>1.<strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即一个资源每次只能被一个进程使用。</p><p>2.<strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>3.<strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p><p>4.<strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。（即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。）</p><h3 id="如何解决死锁问题？"><a href="#如何解决死锁问题？" class="headerlink" title="如何解决死锁问题？"></a>如何解决死锁问题？</h3><p>包括预防死锁、避免死锁、检测死锁、解除死锁四种方式</p><p><strong>预防死锁</strong></p><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p><p>1.<strong>破坏互斥条件</strong>（无法实现）：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的，如果互斥性被破坏的话，以打印机为例，多个进程共享使用打印机，则打印出来的结果就不正确了（临界资源需要互斥访问</p><p>2.<strong>破坏请求与保持条件</strong>：一次性申请所有的资源，该进程就可以顺利执行完毕（优点简单易于实现，缺点严重地降低了资源的利用率，有的资源在进程的后期才会使用，而其他进程要用这个资源的话就必须等待）</p><p>3.<strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>4.<strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。<br>破坏循环等待条件。（不足：1.需要知道资源的请求顺序、2.要请求某个序号比较大的资源时，需要先请求序号比较小的资源，占用了序号比较小的资源，使其利用率变低）</p><p><strong>避免死锁</strong></p><p>避免死锁可以采用判断<strong>系统是否会处于安全状态</strong>的方法</p><p>在进行系统资源分配之前，先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给<strong>进程； 否则，让进程</strong>等待。这是一种保证系统不进入死锁状态的动态策略</p><blockquote><p>系统的安全状态</p><p>对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p></blockquote><p><strong>银行家算法</strong>（一个避免死锁的著名算法）</p><p>我们可以把操作系统看作是银行家，系统资源看做资金，客户看做进程。</p><p>算法要求：</p><p>1、申请的贷款额度不能超过银行现有的资金总额</p><p>2、分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额</p><p>3、如果银行暂时不能满足客户申请的资金额度时，可推迟放款并在有限时间内给予贷款</p><p>4、客户要在规定的时间内还款</p><p><strong>检测死锁</strong></p><p>这种方法并不需要事先采取任何限制性措施，即允许产生死锁，若检测到死锁则采取相应的方法解除死锁</p><p><strong>解除死锁</strong></p><p>如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，此时就需要对系统采取相应的措施。常用的解除死锁的方法：<br>1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。<br>2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。<br>    a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。<br>     b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。一般根据如下几个方面来决定终止哪个进程：<br>    进程的优先级<br>    进程已运行时间以及运行完成还需要的时间<br>    进程已占用系统资源<br>    进程运行完成还需要的资源<br>    终止进程数目<br>    进程是交互还是批处理</p><h2 id="sleep方法和wait方法的共同点"><a href="#sleep方法和wait方法的共同点" class="headerlink" title="sleep方法和wait方法的共同点"></a>sleep方法和wait方法的共同点</h2><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="synchronized-关键字的了解"><a href="#synchronized-关键字的了解" class="headerlink" title="synchronized 关键字的了解"></a>synchronized 关键字的了解</h3><p>synchronized 关键字解决的是<strong>多个线程之间访问资源的同步性</strong>，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻<strong>只能有一个线程</strong>执行。</p><h3 id="synchronized关键字的使用"><a href="#synchronized关键字的使用" class="headerlink" title="synchronized关键字的使用"></a>synchronized关键字的使用</h3><p><strong>修饰实例方法：</strong>作用于当前实例加锁，进入同步方法代码前要获得<strong>当前实例</strong>的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="comment">//业务代码 &#125;</span></span><br></pre></td></tr></table></figure><p><strong>修饰静态方法：</strong>作用于当前类对象加锁，进入同步方法代码前要获得<strong>当前类对象</strong>的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="comment">//业务代码 &#125;</span></span><br></pre></td></tr></table></figure><p><strong>修饰代码块：</strong>指定加锁对象，<strong>对给定对象加锁</strong>，进入同步代码块前要获得给定对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">//业务代码 &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> synchronized(this object) 表示进入同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进入同步代码前要获得当前 class 的锁</p></blockquote><p>总结：</p><p>synchronized关键字加到static静态方法和synchronized（class）代码块上都是是<strong>给Class类上锁。</strong></p><p>synchronized关键字加到实例方法上是<strong>给对象实例上锁。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Synch s = <span class="keyword">new</span> Synch();</span><br><span class="line"><span class="comment">//        Synch s1 = new Synch();</span></span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                s.test2();</span><br><span class="line"><span class="comment">//                test2();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                s.test1();</span><br><span class="line"><span class="comment">//                test1();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Synch</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1开始&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2开始&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">test2开始</span><br><span class="line">test2结束</span><br><span class="line">test1开始</span><br><span class="line">test1结束</span><br></pre></td></tr></table></figure><p>解释：这个例子给实例加上了锁，调用多线程的时候用的都是一个对象，所以，会等一个线程执行完毕释放锁之后，另一个线程才能执行。</p><p>我们可以再创建一个s2对象，线程test1调用s1对象，线程test2调用s2对象，这样由于不是同一个对象，所以不会出现线程同步的情况。</p><p>接着，我们可以将实例方法前面加上 static 关键字，变为静态方法，这样便属于类的方法了。再按照上述运行，会得到同步的情况，因为两个对象都是同一个类创建出来的。</p><p>注意：<strong>synchronized关键字不能修饰构造方法</strong></p><h3 id="synchronized关键字的底层实现原理"><a href="#synchronized关键字的底层实现原理" class="headerlink" title="synchronized关键字的底层实现原理"></a>synchronized关键字的底层实现原理</h3><p>从jvm角度进行说明</p><h3 id="synchronized关键字和volatile关键字的区别"><a href="#synchronized关键字和volatile关键字的区别" class="headerlink" title="synchronized关键字和volatile关键字的区别"></a>synchronized关键字和volatile关键字的区别</h3><p> <a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析 </a>这篇文章写得很好（作者里面的很多文章都写得很不错）</p><p>在网上看了一些博客，在这里自己总结一下，以便以后自己可以看得懂。。</p><p>Volatile关键字的作用是不让线程在CPU缓存或者寄存器中进行写操作 因为线程在修改一个变量的时候  为了提高效率 通常会在寄存器或者CPU缓存中先进行修改，这一过程对其他线程是不可见得，然后再写入内存，在这一过程中 如果有其他线程又对这一数据进行了修改，那么就会产生数据的不同步。因此为了避免这一现象，可以使用Volatile关键字来对变量进行修饰，使其不在寄存器和CPU缓存中进行 直接操作内存，这样就可以让所有线程及时得到数据修改的消息，保证数据的一致性。但是使用volatile关键字会有性能上的消耗，因为直接操作主存比操作缓存麻烦</p><p>Synchronized关键字是对代码块加锁的操作   他操作的过程如下  </p><ol><li>  线程从监听器获取对象的锁。(这里假设监听器非锁，否则线程只有等到监听器解锁才能获取对象锁)</li><li>  线程内存更新所有的变量，也就是说他将读取主内存中的变量使自己的变量保证有效。(JVM会使用一个“脏”标志来最优化过程，使得仅仅具有“脏”标志变量被更新。详细的情况查询JAVA规范的17.9)</li><li>  代码块被执行</li><li>  任何变量的变更将被写回到主内存中。</li><li>  线程释放对象的锁给监听器。<br>综上所述，volatile 是来保证主存中的数据始终对所有线程可见，也就是线程获取到的都是主存中正确的值   而synchronized 是给某一部分代码加锁，使得他在操作某一些变量的时候其他线程都不可以操作，这样就保证了数据不会被同时修改或者读取，可以实现多个数据的同步，因此synchronized更耗资源 并且更好用一些 。</li></ol><p>最后复制一下网上最常见的二者区别。。。：</p><p>1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的<br>3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性<br>4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p><p>红字体部分的原因如下：<br>线程A修改了变量还没结束时,另外的线程B可以看到已修改的值,而且可以修改这个变量,而不用等待A释放锁,因为Volatile 变量没上锁</p><h2 id="cpu的内存缓存不一致现象"><a href="#cpu的内存缓存不一致现象" class="headerlink" title="cpu的内存缓存不一致现象"></a>cpu的内存缓存不一致现象</h2><p>CPU缓存则是为了解决<strong>CPU处理速度和内存处理速度不对等的问题。</strong></p><p>先复制一份数据到CPU Cache中，当CPU需要用到的时候就可以直接从CPU Cache中读取数据，当运算完成后，再将运算得到的数据写回Main Memory中。但是，这样存在内存缓存不一致性的问题！</p><p>比如我执行一个i++操作的话，如果两个线程同时执行的话，假设两个线程从CPU Cache中读取的i=1，两个线程做了i++运算完之后再写回Main Memory之后 i = 2，而正确结果应该是 i = 3</p><p>CPU为了解决内存缓存不一致性问题可以通过制定<strong>缓存一致协议</strong>来解决</p><p>关于缓存一致性协议看这篇文章  <a href="https://www.cnblogs.com/ynyhl/articles/12119690.html">缓存一致性协议（MESI）</a></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><a href="https://baijiahao.baidu.com/s?id=1653790035315010634&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1653790035315010634&amp;wfr=spider&amp;for=pc</a></p><h3 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h3><p><strong>概念</strong>：</p><p>ThreadLocal提供了线程的<strong>局部变量</strong>，每个线程都可以通过<code>set()</code>和<code>get()</code>来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，<strong>实现了线程之间的数据隔离</strong>。</p><p>简要言之：往ThreadLocal中填充的变量属于<strong>当前</strong>线程，该变量对其他线程而言是隔离的。</p><p>弄清这四个的关系即可</p><p><code>Thread</code>、<code>ThreadLocal</code>、<code>ThreadLocalMap</code>、<code>Entry</code></p><p>一句话总结就是：<code>Thread</code>维护了<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>里维护了<code>Entry</code>，而<code>Entry</code>里存的是以<code>ThreadLocal</code>为key，传入的值为value的键值对。</p><p><strong>Thread为每个线程维护了ThreadLocalMap这么一个Map，而ThreadLocalMap的key是ThreadLocal对象本身，value则是要存储的对象</strong></p><h3 id="ThreadLocal中的四个方法"><a href="#ThreadLocal中的四个方法" class="headerlink" title="ThreadLocal中的四个方法"></a>ThreadLocal中的四个方法</h3><h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;资本是靠自己挣来的，不是靠别人得到的&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>7.26java基础学习</title>
    <link href="http://example.com/2021/07/26/7-26java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/26/7-26java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-26T01:07:33.000Z</published>
    <updated>2021-07-27T03:24:11.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>冲冲冲</p></blockquote><a id="more"></a><p>小插曲，很多人都有幸福的烦恼吧，至少是有兜底的吧，而我却没得选。</p><p>26日的内容全写在25日里面了，保证内容的连贯性</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;冲冲冲&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>7.25java基础学习</title>
    <link href="http://example.com/2021/07/25/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/07/25/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-25T01:32:40.000Z</published>
    <updated>2021-07-27T14:52:20.974Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>落后就要站直挨打，人菜就要多读书</p></blockquote><a id="more"></a><p>多关注一下底层的实现</p><h2 id="java集合框架"><a href="#java集合框架" class="headerlink" title="java集合框架"></a>java集合框架</h2><p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210725103634078.png" alt="集合层次图"></p><p>主要分为<strong>Collection</strong> 和 <strong>Map</strong> 两种体系，他们都是接口</p><p>再细化一点，我们关注 Collection中的 list 和 Set </p><h2 id="说说-List-Set-Map-三者的区别？"><a href="#说说-List-Set-Map-三者的区别？" class="headerlink" title="说说 List,Set,Map 三者的区别？"></a>说说 List,Set,Map 三者的区别？</h2><p><strong>List</strong>：存储的元素是<strong>有序的</strong>、<strong>可重复的。</strong></p><p><strong>Set</strong>：存储的元素是<strong>无序的、不可重复的。</strong></p><p><strong>Map</strong>：使用键值对（kye-value）存储，Key是无序的、不可重复的，value是无序的、可重复的，每个key只能对应一个value</p><h2 id="为什么要使用集合？不是有数组这种东西吗？"><a href="#为什么要使用集合？不是有数组这种东西吗？" class="headerlink" title="为什么要使用集合？不是有数组这种东西吗？"></a>为什么要使用集合？不是有数组这种东西吗？</h2><p>由于<strong>数组的弊端</strong>： 数组只能存取相同类型的元素，且在使用之前必须声明长度且声明后就是固定的了，它的数据是可重复的、特点单一的。</p><p>而我们在实际的使用过程中，存储的数据类型是多种多样的，用集合来存储，可以存储<strong>不同类型、不同数量</strong>的对象，还可以保存具有映射关系的数据。</p><h2 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h2><p>根据要存放数据的特点来选择</p><p><strong>要存放具有映射关系的数据时</strong>，就用<strong>Map接口</strong>下的集合，要排序就用 TreeMap， 不需要排序用 HashMap， 需要保证线程安全就用 ConcurrentHashMap </p><p><strong>当我们只需要存放元素值时</strong>，就选择实现<strong>Collection接口</strong>的集合，需要保证<strong>元素唯一</strong>时选择实现 Set接口的集合比如TreeSet或HashSet，不需要就选择实现<strong>List接口</strong>的比如ArrayList或Linkedlist，然后再根据实现这些接口的集合的特点来选用。 </p><h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><p><strong>迭代器是什么？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下⼀个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义为：<strong>提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</strong></p><p><strong>为什么要用迭代器？</strong></p><p>迭代器目的是<strong>对集合进行遍历</strong>，而每一个集合内部的存储结构都是不同的，所以每一个集合存和取都是不一样，那么就需要在每一个类中定义<strong>hasNext()**方法和</strong>next()**方法，这样做是可以的，但是会让整个集合体系过于臃肿。</p><p>迭代器是将这样的方法向上抽取出接口，然后在每个类的内部，自己定义迭代方式。</p><p>这样做的好处有二：</p><p>第一，规定了整个集合体系的遍历方式都是hasNext()和next()方法；</p><p>第二，代码有底层内部实现，使用者不用管怎么实现的，会用即可 </p><p><strong>迭代器如何使用？</strong>（以map为例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="comment">//这里我们可以写得更加精炼，用for-each语句来代替,就不用迭代器，在后面的集合遍历方式中会提到</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">        System.out.println(entry.getKey());</span><br><span class="line">        System.out.println(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有哪些集合是线程不安全的？怎么解决呢？"><a href="#有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="有哪些集合是线程不安全的？怎么解决呢？"></a>有哪些集合是线程不安全的？怎么解决呢？</h2><p>我们常用的 Arraylist，Linkedlist，Hashmap，HashSet，TreeSet，TreeMap，PriorityQueue 不是线程安全的。解决办法很简单，可以<strong>使用线程安全的集合来代替。</strong><br>如果你要使用线程安全的集合的话，<code>java.util.concurrent</code>包（简称JUC包）中提供了很多<strong>并发容器</strong>供你使用：<br>1、ConcurrentHashMap：可以看作是线程安全的HashMap<br>2、CopyOnwriteArraylist：可以看作是线程安全的Arraylist，在读多写少的场合性能非常好，远远好于Vector<br>3、ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的inkedList，这是一个非阻塞队列。<br>4、BlockingQueue：这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。<br>5、ConcurrentSkipListMap：跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。</p><h2 id="Collection子接口之List"><a href="#Collection子接口之List" class="headerlink" title="Collection子接口之List"></a>Collection子接口之List</h2><p>List接口下面主要有三个实现类：<strong>ArrayList</strong> 、 <strong>LinkedList</strong>、 <strong>Vector</strong></p><h3 id="ArrayList源码介绍"><a href="#ArrayList源码介绍" class="headerlink" title="ArrayList源码介绍"></a>ArrayList源码介绍</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>与LinkedList不同的是，ArrayList实现了<strong>RandomAccess</strong>接口，没有实现<strong>Deque</strong>接口。</p><blockquote><p><strong>关于 RandomAccess 接口的作用？</strong></p><p>我们在源码中可以看到， RandomAccess 接口没有定义任何方法，相当于一个标识</p><p>只要集合中实现这个接口，就能支持快速随机访问，那什么是快速随机访问呢？</p><p>通过查看 Collections类中的binarySearch() 方法</p><p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210725152536103.png" alt="Collections类中的binarySearch() 方法"></p><p>这两个方法有什么区别呢？</p><p>首先判断传入的list是否为 RandomAccess 的实例</p><p>实现 RandomAccess 接口的List集合采用一般的<strong>for循环遍历</strong>，而未实现这接口则采用<strong>迭代器</strong>。</p></blockquote><p><strong>结论：</strong>经过for 循环和 迭代器 两种方法的测试，</p><p> （1）如果有实现 RandomAccess接口，在遍历该集合时采用for循环效率会更高。</p><p>（2）如果没有实现 RandomAccess接口，那么在遍历该集合时采用Iterator迭代器的效率会更高一些。</p><p><strong>ArrayList有三种构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始容量大小</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带初始容量参数的构造函数,(用户可以在创建ArrayList对象时自己指定集合的初始大小)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个包含指定集合的元素的列表</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h3><p>以<strong>无参数构造方法</strong>创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个<strong>空数组</strong>。当真正对数组进行<strong>添加元素操作</strong>时，才真正分配容量。<strong>即向数组中添加第一个元素时，数组容量扩为 10</strong>。</p><p><strong>以默认构造函数为例</strong>，此时elementData还是Object类型的空数组</p><p>1.首先我们添加一个元素，进入ensureCapacityInternal（size + 1）函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2.此时的minCapacity = 1（因为最开始是空数组，size = 0，size + 1 = 1），进入if语句中，minCapcity = Max.math(10, 1) , 所以 minCapcity在添加完第一个元素后变成了10，接着进入ensureExplicitCapacity(minCapacity); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.此时的elementData.length = 0，minCapcity = 10，进入grow函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>4.在grow函数中，<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>这句话很重要，说明了新容量是旧容量的1.5倍，经过第一个元素的添加后newCapcity = 10，<code>elementData = Arrays.copyOf(elementData, newCapacity);</code>这句话将原数组扩充到新容量这么大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">       <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">      <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">      <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>5.以上就是第一个元素添加的过程，<strong>在添加第二个元素</strong>时进入 ensureExplicitCapacity 函数中，因为判断条件不满足（此时mincapcity = size + 1 = 2 ， 而elementData.length = 10），不会进入grow函数，也就不会扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br></pre></td></tr></table></figure><p>6.添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</p><p>直到添加<strong>第 11 个元素</strong>，minCapacity (为 11) 比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><p>newCapcity为原来的1.5倍，大小为15，数组容量也从10扩充为15，不会进入hugeCapacity(minCapacity);方法中</p><blockquote><p><strong>关于扩容newCapcity扩容为1.5倍的准确说法</strong>：</p><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) **,  所以 ArrayList 每次扩容之后容量都会变为原来的 **1.5 倍左右</strong>（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。<strong>如果是奇数的话会丢掉小数.</strong></p></blockquote><blockquote><p>关于<code>hugeCapacity(minCapacity);</code>函数：</p><p>感觉这部分代码有点多余，那段的代码实际意思就是：只要minCapcity大于MAX_ARRAY_SIZE（即Integer.MAX_VALUE - 8），minCapcity = Integer.MAX_VALUE</p></blockquote><blockquote><p><code>length()</code>  、 <code>length</code>  、<code>size()</code>    三者的比较</p><p>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.(相当于数组大小)</p><p>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</p><p>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!（相当于元素多少）</p></blockquote><h3 id="ArrayList和数组的区别？"><a href="#ArrayList和数组的区别？" class="headerlink" title="ArrayList和数组的区别？"></a>ArrayList和数组的区别？</h3><p>数组内存地址是连续的，一旦声明后，长度就是不可变的了，存放的数据类型是固定的，便于查询，不方便删除和查找</p><p>ArrayList 底层是Object[]数组，容量可变，有自动扩容机制，存放的数据类型不是固定的，有许多api方便插入和删除使用</p><h3 id="ArrayList-和-Vector-的区别？"><a href="#ArrayList-和-Vector-的区别？" class="headerlink" title="ArrayList 和 Vector 的区别？"></a>ArrayList 和 Vector 的区别？</h3><p>1、ArrayList是List的<strong>主要实现类</strong>，底层使用 Object[] 存储，适用于<strong>频繁的查找工作，线程不安全</strong>；<br>2、Vector是List的<strong>古老实现类</strong>，底层使用 Object[] 存储，<strong>线程安全的</strong>。</p><h3 id="ArrayList-和-LinkedList-的区别？"><a href="#ArrayList-和-LinkedList-的区别？" class="headerlink" title="ArrayList 和 LinkedList 的区别？"></a>ArrayList 和 LinkedList 的区别？</h3><p>1、<strong>是否线程安全：</strong>都是线程不安全的</p><p>2、<strong>底层数据结构</strong>：Arraylist 底层使用的是 object数组；LinkedList底层使用的是<strong>双向链表</strong>（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p><p>3、<strong>是否支持快速随机访问</strong>：LinkedList不支持高效的随机元素访问，而ArrayList支持。快速随机访问就是通过元素的序号快速获取元素对象（对应于get（int index）方法）。</p><p>4、<strong>内存空间占用</strong>：ArrayList的空间浪费主要体现在在list列表的<strong>结尾会预留一定的容量空间</strong>，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要<strong>存放直接后继和直接前驱以及数据</strong>）.</p><p>5.<strong>在使用上的不同点</strong>：</p><p>List 是集合列表接口，ArrayList 和 LinkedList 都是 List 接口的实现类。</p><p>ArrayList 是动态数组顺序表，顺序表的存储地址是连续的，所以<strong>查找比较快，但是插入和删除时由于需要把其它的元素顺序移动，所以比较耗时。</strong></p><p>LinkedList 是双向链表的数据结构，同时实现了双端队列 Deque 接口，链表节点的存储地址是不连续的，每个存储地址通过指针关联，在<strong>查找时需要进行指针遍历节点</strong>，所以<strong>查找比较慢，而在插入和删除时比较快。</strong></p><p><strong>LinkedList源码介绍</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到 LinkedList 实现了<strong>Deque</strong>，可以作为一个双端队列，实现了<strong>Cloneable接口</strong>，能被克隆，实现了<strong>Serializable接口</strong>，因此它支持序列化，能够通过序列化传输。</p><p>LinkedList类中有一个内部私有类Node，这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//分别:前驱节点，本节点的值，后继节点</span></span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.item = element;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210725115825089.png" alt="LinkedList结构图 -- 双向链表"></p><h2 id="Collection子接口之Set"><a href="#Collection子接口之Set" class="headerlink" title="Collection子接口之Set"></a>Collection子接口之Set</h2><h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p>1、<strong>Comparable接口</strong>出自java.lang包它有一个<strong>compareTo（object obj）</strong>方法用来排序</p><p>2、<strong>Comparator接口</strong>出自java.util包它有一个<strong>compare（Object obj1，Object obj2）</strong>方法用来排序</p><p>1.Comparator定制排序，具体使用见<a href="D:\Blog\source_posts\实现Comparator接口来排序.md">实现Comparator接口来排序</a></p><p>2.实现Comparable接口来排序，需要重写接口中的compareTo方法，像String类和Integer类已经实现了Comparable接口，如果我们自定义一个类的话，需要手动实现接口，并重写方法</p><blockquote><p><code>compareTo():</code></p><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p><p>升序： o1.compareTo(o2)     降序： o2.compareTo(o1)</p></blockquote><h3 id="关于Set中无序性的解释"><a href="#关于Set中无序性的解释" class="headerlink" title="关于Set中无序性的解释"></a>关于Set中无序性的解释</h3><p>无序性<strong>不等于随机性</strong>，无序性指的是存储的数据在底层数组中并不是按照索引的顺序添加的，而是根<strong>据数据的哈希值确定的</strong></p><h3 id="HashSet如何检查重复？"><a href="#HashSet如何检查重复？" class="headerlink" title="HashSet如何检查重复？"></a>HashSet如何检查重复？</h3><p>HashSet是基于HashMap实现的，元素的值存储在key上，value的值所有元素都一样，都是这个 <code>private static final Object PRESENT = new Object();</code></p><p>HashSet在添加一个元素时（比如此时添加的是”a”这个元素），都会将该元素与set中所遍历到的每个元素作比较，比较的过程是这样的：</p><p>先用该元素的hashCode值与遍历到的每个元素的hashCode作比较，如果hashCode不相等，则直接添加；若hashCode的值一样，则继续用该元素的equals()方法比较（是被添加的equals()方法，与之比较的元素作为参数），如果equals()方法得到的值是一样的，说明两个元素是相通的则不再添加，如果equals()的值是不一样的，就会将该对象添加到其他内存地址（重新计算出不一样的hashCode）。</p><h3 id="比较HashSet，LinkedHashSet和TreeSet三者的异同"><a href="#比较HashSet，LinkedHashSet和TreeSet三者的异同" class="headerlink" title="比较HashSet，LinkedHashSet和TreeSet三者的异同"></a>比较HashSet，LinkedHashSet和TreeSet三者的异同</h3><p>如需要详细理解源码，看 <a href="https://blog.csdn.net/a724888/article/details/80295328">Java集合详解7：HashSet，TreeSet与LinkedHashSet</a> 这篇文章</p><p>HashSet与LinkedHashSet都是基于Set接口的实现类。TreeSet是Set的子接口SortedSet的实现类。Set接口及其子接口、实现类的结构如下所示：</p><p>Set接口</p><p>​        |——SortedSet接口——TreeSet实现类</p><p>​        |——HashSet实现类         </p><p>​        |——LinkedHashSet实现类</p><p><strong>1.HashSet</strong></p><p>底层基于<strong>HashMap</strong>实现的，使用HashMap保存所有元素，我们加入进去的元素相当于HashMap中的Key，所有的Value都是相同的。</p><p>1.HashSet中不能有相同的元素，可以有一个Null元素，存入的元素是<strong>无序</strong>的。</p><p>2.HashSet如何保证唯一性？</p><p>1).HashSet底层数据结构是哈希表，哈希表就是存储唯一系列的表，而哈希值是由对象的hashCode()方法生成。</p><p>2).确保唯一性的两个方法：hashCode()和equals()方法。</p><p>3.非线程安全</p><p><strong>2.LinkedHashSet</strong></p><p> LinkedHashSet底层使用 <strong>LinkedHashMap</strong> 来保存所有元素，继承了 HashSet，其所有的方法操作上又与 HashSet 相同</p><p>1.LinkedHashSet中不能有相同元素，可以有一个Null元素，是有序的，也就是说当遍历该集合时候，LinkedHashSet将会按照元素的添加顺序访问集合的元素。</p><p>2.LinkedHashSet如何保证有序和唯一性？</p><p>1).底层数据结构由哈<strong>希表和链表</strong>组成。</p><p>2).<strong>链表保证了元素的有序性</strong>，哈希表保证了元素的唯一性。</p><p>3.非线程安全</p><p><strong>3.TreeSet</strong></p><p>若想了解TreeSet中自然排序和定制排序，看这篇文章 <a href="https://www.cnblogs.com/lixiaolun/archive/2012/12/25/2832775.html">Tree自然排序和定制排序</a></p><p>1.TreeSet中不能有相同元素，<strong>不可以有Null元素</strong>（与前两个的区别），不可以放入两个类型不相同的元素，根据元素的<strong>自然顺序</strong>进行排序。</p><p>2.如果要将一个类的对象放入TreeSet中，这个类必须要实现Comparable接口，TreeSet会调用对象的comparaTo方法进行比较，没有实现这个接口，则会出现ClassCastException异常。</p><p>2.TreeSet如何保证元素的排序和唯一性？</p><p>底层的数据结构是红黑树(一种自平衡二叉查找树)</p><p>3.添加、删除操作时间复杂度都是O(log(n))</p><p>4.非线程安全</p><p>一个对象如果放到TreeSet中，必然会实现Comparable接口，实现Comparable的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比 较大小，TreeSet中有个比较大小的东西，两个不同种类的对象就不能比较大小啦。</p><blockquote><p> <strong>TreeSet的自然排序：</strong></p><p> TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间大小关系，然后将集合元素按升序排列，这种方式就是自然排序。</p></blockquote><p><strong>总结：</strong><br>通过以上特点可以分析出，三者都保证了元素的唯一性，如果无排序要求可以选用HashSet；如果想取出元素的顺序和放入元素的顺序相同，那么可以选用LinkedHashSet。如果想插入、删除立即排序或者按照一定规则排序可以选用TreeSet。</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>主要有三个实现类：HashMap、HashTable、TreeMap</p><h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p>1.<strong>线程是否安全</strong>：HashMap是<strong>非线程安全</strong>的，HashTable是<strong>线程安全</strong>的，因为HashTable内部的方法基本<strong>都经过synchronized修饰</strong>。（如果你要保证线程安全的话就使用<strong>ConcurrentHashMap</strong>吧！）；</p><p>2.<strong>效率</strong>：因为线程安全的问题，<strong>HashMap要比HashTable效率高一点</strong>。另外，<strong>HashTable基本被淘汰</strong>，不要在代码中使用它；<br>3.<strong>对Null key和Null value的支持</strong>：HashMap可以存储null的key和value，但null作为键只能有一个，null作为值可以有多个；HashTable<strong>不允许有null 键和null值</strong>，否则会抛出NullPointerException.</p><p>4.<strong>初始容量大小和每次扩充容量大小的不同</strong>：</p><p>①创建时<strong>如果不指定容量初始值</strong>，Hashtable默认的初始大小为11，之后每次扩充，容量变为原来的2n+1，HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。</p><p>②创建时<strong>如果给定了容量初始值</strong>，那么Hashtable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小（HashMap中的tablesizeFor（）方法保证，下面给出了源代码）。也就是说HashMap总是使用2的幂作为哈希表的大小、后面会介绍到为什么是2的幂次方。</p><p>5.<strong>底层实现结构不一样</strong></p><p>6.<strong>继承的类不一样</strong>，HashMap继承AbstractMap，AbstractMap实现了Map接口；Hashtable继承Dictionary类；都实现了Map，Cloneable（可复制），Serializable（可序列化）三个接口；</p><h3 id="HashMap介绍（未解决）"><a href="#HashMap介绍（未解决）" class="headerlink" title="HashMap介绍（未解决）"></a>HashMap介绍（未解决）</h3><p><strong>HashMap简介</strong></p><p>HashMap位于java.util目录下。 HashMap是一个散列表，存储的内容是&lt;key,value&gt;键值对。它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度。</p><p>HashMap继承于AbstractMap，实现了Map、Cloneable、Serializable接口 ，HashMap是线程不安全的，其中key、value都可以为null，且是无序的，但 null 作为键只能有一个，null 作为值可以有多个。</p><p><strong>JDK1.8 之前</strong> HashMap 由 <strong>数组+链表</strong> 组成的，数组是 HashMap 的主体，链表则是主要为了解决<strong>哈希冲突</strong>而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><p><strong>HashMap源码分析</strong></p><p><strong>JDK1.8之前</strong></p><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p><p>HashMap 通过 key 的 hashCode() 函数, 再经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 <strong>n 指的是数组的长度</strong>），即数组的index下标，如果当前位置存在元素的话，就判断该位置元素与要存入的元素的 <strong>hash 值以及 key 是否相同</strong>（因为hash值不同也可能得到相同的数组位置），如果相同的话，直接覆盖，不相同就通过<strong>拉链法</strong>解决冲突。</p><blockquote><p>为什么要用扰动函数得到最后的hash值，而不直接用key的hashCode() 函数得到呢？</p><p>扰动函数是为了防止一些实现比较差的 hashCode() 方法 ，换句话说使用扰动函数之后可以<strong>减少碰撞</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扰动函数的具体实现如下：</span></span><br><span class="line"><span class="comment">// ^ ：按位异或</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)；</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>什么是拉链法？</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可，如下图所示：</p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210726220013547.png" alt="拉链法示意图" style="zoom:67%;" /></blockquote><p><strong>JDK1.8之后</strong></p><p>JDK1.8 以后在<strong>解决哈希冲突</strong>时有了较大的变化。</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><ul><li><p><strong>loadFactor 加载因子</strong></p><p>loadFactor 加载因子是控制<strong>数组存放数据的疏密程度</strong>，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p><p>给定的<strong>默认容量为 16，负载因子为 0.75</strong>。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold 临界值</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当 size &gt;= threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><h3 id="HashMap和HashSet的区别"><a href="#HashMap和HashSet的区别" class="headerlink" title="HashMap和HashSet的区别"></a>HashMap和HashSet的区别</h3><p>HashSet底层就<strong>是基于HashMap实现的</strong>。（HashSet的源码非常非常少，因为除了<code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code> 是HashSet自己实现之外，其他方法都是<strong>直接调用HashMap中的方法。</strong></p><p>以HashSet的 get方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet中的add方法，直接调用HashMap中的put方法来实现的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210727105418705.png" alt="HashMap和HashSet比较" style="zoom: 80%;" /><h3 id="HashMap有哪几种常见的遍历方式？"><a href="#HashMap有哪几种常见的遍历方式？" class="headerlink" title="HashMap有哪几种常见的遍历方式？"></a>HashMap有哪几种常见的遍历方式？</h3><p>HashMap 遍历从大的方向来说，可分为<strong>以下 4 类</strong>：</p><ol><li>迭代器（Iterator）方式遍历；  2种</li><li>For Each 方式遍历；   2种</li><li>Lambda 表达式遍历（JDK 1.8+）    1种</li><li>Streams API 遍历（JDK 1.8+）  2种      </li></ol><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为<strong>以下 7 种</strong>：</p><ol><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.print(key);</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.使用 Streams API 单线程的方式进行遍历；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    *<span class="comment">// 创建并赋值 HashMap*</span></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">    *<span class="comment">// 遍历*</span></span><br><span class="line">    map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">      System.out.print(entry.getKey());</span><br><span class="line">      System.out.print(entry.getValue());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>使用 Streams API 多线程的方式进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    *<span class="comment">// 创建并赋值 HashMap*</span></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line">    *<span class="comment">// 遍历*</span></span><br><span class="line">    map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">      System.out.print(entry.getKey());</span><br><span class="line">      System.out.print(entry.getValue());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="concurrentHashMap分析（未解决）"><a href="#concurrentHashMap分析（未解决）" class="headerlink" title="concurrentHashMap分析（未解决）"></a>concurrentHashMap分析（未解决）</h3><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p><strong>Collections工具类常用方法：</strong></p><p>1、排序<br>2、查找，替换操作<br>3、同步控制（不推荐，需要线程安全的集合类型时请考虑使用JUC包下的并发集合）</p><p><strong>排序操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list，Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list，<span class="keyword">int</span> i，<span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list，<span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后</span></span></span><br></pre></td></tr></table></figure><p><strong>查找,替换操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarysearch</span><span class="params">(List list，Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll，Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll，Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list，Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c，object o)</span><span class="comment">//统计元素出现次数int indexOfSublist(List list，List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source，list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list，Object oldVal，Object newVal)</span>，用新元素替换旧元素</span></span><br></pre></td></tr></table></figure><p><strong>同步控制</strong></p><p>Collections提供了多个<code>synchronizedxxx</code>方法，该方法可以<strong>将指定集合包装成线程同步的集合</strong>，<strong>从而解决多线程并发访问集合时的线程安全问题。</strong><br>我们知道HashSet，TreeSet，Arraylist，LinkedList，HashMap，TreeMap都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合。<br><strong>最好不要用下面这些方法，效率非常低，</strong>需要线程安全的集合类型时请考虑使用 JUC包 下的并发集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt; c)<span class="comment">//返回指定collection支持的同步（线程安全的）collection.</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List.</span></span><br><span class="line">synchronizedMap(Map&lt;k，v&gt; m)<span class="comment">//返回由指定映射支持的同步（线程安全的）Map.</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s)<span class="comment">//返回指定set支持的同步（线程安全的）set.</span></span><br></pre></td></tr></table></figure><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="什么是快速失败-fail-fast-？"><a href="#什么是快速失败-fail-fast-？" class="headerlink" title="什么是快速失败(fail-fast)？"></a>什么是快速失败(fail-fast)？</h3><p>在使用迭代器对集合进行迭代的过程中，如果 A 线程正在对集合进行遍历，此时 B 线程对集合进行修改（增加、删除、修改），或者 A 线程在遍历过程中对集合进行修改，都会导致 A 线程抛出 ConcurrentModificationException 异常。</p><p><strong>原理：</strong>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <strong>modCount</strong> 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会<strong>检测 modCount 变量是否等于 expectedmodCount 值</strong>，是的话就返回遍历；否则抛出异常，终止遍历。</p><p><strong>注意：</strong>这里异常的抛出条件是检测到 <strong>modCount != expectedmodCount</strong> 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。</p><blockquote><p>注：通过 Iterator 的方法修改集合的话会修改到 expectedModCount 的值，所以不会抛出异常。</p><p>如下例所示：</p></blockquote><p><img src="/images/7-25java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20210725222431894.png" alt="例子"></p><p>上面这个例子在反例中，  如果<strong>只添加两个元素</strong>，1 是 可以成功的， “1”换成”2”就会报错</p><p><strong>场景：</strong>java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><h3 id="什么是安全失败-fail-safe-呢？"><a href="#什么是安全失败-fail-safe-呢？" class="headerlink" title="什么是安全失败(fail-safe)呢？"></a>什么是安全失败(fail-safe)呢？</h3><p>采用安全失败机制的集合容器，<strong>在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</strong></p><p><strong>原理：</strong>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。</p><p>&gt;缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p><strong>场景：</strong>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;落后就要站直挨打，人菜就要多读书&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
</feed>
