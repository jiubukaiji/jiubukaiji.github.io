<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pb</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-17T05:38:10.828Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>仿牛客论坛记录</title>
    <link href="http://example.com/2021/11/14/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/11/14/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-14T06:22:35.000Z</published>
    <updated>2021-11-17T05:38:10.828Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录仿牛客论坛记录一些不懂的地方</p></blockquote><a id="more"></a><p>运行项目之前的准备：</p><p>1.右键pom.xml,设置为maven项目</p><p>2.修改compile为jdk1.8</p><p>3.在properties中修改端口号、数据库账号密码等等。。</p><p><img src="/images/%E4%BB%BF%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E8%AE%B0%E5%BD%95/image-20211114202756059.png" alt="image-20211114202756059"></p><p>注意数据库字段和bean字段的对应关系</p><p>mybatis中有哪些标签？</p><p>select、update、insert、sql、if、include</p><p>什么是动态sql</p><p>分布式架构中存在session共享的问题：</p><p>因为要保证负载均衡，所以所以。。</p><p>解决方案：粘性session、同步session、将数据存到redis中</p><p>@bean和</p><p><strong>spring事务管理：  事务的传播机制？</strong></p><p>@Transactional，  保证事务是个整体</p><p>springboot整合redis</p><p>先在pom.xml中导入包，写一个配置类，</p><p>再使用redisTemplate来操作</p><p>kafka的消息持久化是怎样的？</p><p>参考文章：<a href="https://blog.csdn.net/weixin_48610702/article/details/115859656?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-12.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-12.no_search_link">https://blog.csdn.net/weixin_48610702/article/details/115859656?spm=1001.2101.3001.6650.12&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-12.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-12.no_search_link</a></p><p>使用之前要开启redis、zookeeper、kafka、elasticsearch服务器。</p><ul><li><p>打开<strong>redis</strong>：切换到redis目录下，输入：<code>redis-server.exe redis.windows.conf</code></p></li><li><p>打开<strong>Zookeeper</strong>：切换到kafka_2.12-2.3.0，输入：<code>bin\windows\zookeeper-server-start.bat config\zookeeper.properties</code></p></li><li><p>打开<strong>kafka</strong>：切换到kafka_2.12-2.3.0，输入：<code>bin\windows\kafka-acls.bat config\server.properties</code></p></li><li><p>打开<strong>elasticsearch</strong>：切换到elasticsearch目录下，输入：<code>bin\elasticsearch.bat</code></p></li></ul><p>在index页面上做了一点修改，隐藏了最热功能。</p><h2 id="请简要介绍一下你的项目？"><a href="#请简要介绍一下你的项目？" class="headerlink" title="请简要介绍一下你的项目？"></a>请简要介绍一下你的项目？</h2><p>这个项目的整体结构来源于牛客网，主要使用了Springboot、Mybatis、MySQL、Redis、Kafka、等工具。主要实现了用户的注册、登录、发帖、点赞、系统通知、按热度排序、搜索等功能。另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。</p><h2 id="什么是Spring框架？"><a href="#什么是Spring框架？" class="headerlink" title="什么是Spring框架？"></a>什么是Spring框架？</h2><p>有很多模块组成，利用这些模块可以方便开发工作。这些模块是：核心容器（spring core)/数据访问和集成(Spring JDBC)/Web(Spring Web/MVC)/AOP(Spring Aop)/消息模块/测试模块(Spring Test)等。</p><h2 id="对Spring-IoC的理解"><a href="#对Spring-IoC的理解" class="headerlink" title="对Spring IoC的理解"></a>对Spring IoC的理解</h2><p>IoC的意思是控制反转，是一种设计思想，把需要在程序中手动创建对象的控制权交给了Spring框架。IoC的载体是IoC容器，本质是一个工厂，数据结构上来看是一个Map，用来存放着各种对象。当我们创建一个对象时，只需要配置好配置文件/注解，而不用担心对象是怎么被创建出来的。</p><p>IoC的优点：降低耦合，对象被容器管理需要两份数据：你的对象定义 + 配置文件，对象间的关系体现在配置文件，不会直接产生耦合。</p><h2 id="什么是DAO"><a href="#什么是DAO" class="headerlink" title="什么是DAO"></a>什么是DAO</h2><p>data access object，存放数据库访问对象。</p><h2 id="Spring中关于Bean的注解"><a href="#Spring中关于Bean的注解" class="headerlink" title="Spring中关于Bean的注解"></a>Spring中关于Bean的注解</h2><p>四种常见Bean<br>@Controller @Repository @Service @Component一般来说Bean只会被容器初始化一次，@PostConstruct：初始化前调用 @PreDestroy：销毁之前<br>如何使用Bean<br>bean通过容器管理，不需要我们实例化，如果要使用某个bean，使用依赖注入 @Autowired</p><h2 id="Spring-MVC是什么，是怎样的工作流程"><a href="#Spring-MVC是什么，是怎样的工作流程" class="headerlink" title="Spring MVC是什么，是怎样的工作流程"></a>Spring MVC是什么，是怎样的工作流程</h2><p>服务器分为表现层/业务层/数据层，其中Spring MVC是工作在表现层，作用是接收/解析用户发送的请求，调用对应的业务类，根据业务类返回的结果（ModelAndView)，调用view进行视图渲染，并将渲染后的View返回给请求者。具体分为以下8步。</p><p>客户端（浏览器）发送请求给前端处理器（DispatcherServlet)(发送请求，响应结果)；<br>DispatcherServlet根据请求信息调用HandlerMapping，查找到对应的Handler；<br>查找到对应的Handler(也就是Controller)后，由HandlerAdapter适配器处理；<br>HandlerAdapter根据Handler来调用真正的Controller；<br>Controller进行业务处理，返回ModelAndView对象，Model是数据对象，View是逻辑上的View；<br>ViewResolver根据逻辑view找到实际view；<br>DispatcherServlet把Model传给view进行视图渲染，然后返回给请求者。<br>C - Controller：控制器。接受用户请求，调用 Model 处理，然后选择合适的View给客户。<br>M - Model：模型。业务处理模型，接受Controller的调遣，处理业务，处理数据。<br>V - View：视图。返回给客户看的结果。</p><h2 id="DispatcherServlet处理流程？"><a href="#DispatcherServlet处理流程？" class="headerlink" title="DispatcherServlet处理流程？"></a>DispatcherServlet处理流程？</h2><p>DispatcherServlet 处理流程：<br>在整个 Spring MVC 框架中，DispatcherServlet 处于核心位置，它负责协调和组织不同组件完成请求处理并返回响应工作。DispatcherServlet 是 SpringMVC统一的入口，所有的请求都通过它。DispatcherServlet 是前端控制器，配置在web.xml文件中，Servlet依自已定义的具体规则拦截匹配的请求，分发到目标Controller来处理。 初始化 DispatcherServlet时，该框架在web应用程序WEB-INF目录中寻找一个名为[servlet-名称]-servlet.xml的文件，并在那里定义相关的Beans，重写在全局中定义的任何Beans。在看DispatcherServlet 类之前，我们先来看一下请求处理的大致流程：</p><p>Tomcat 启动，对 DispatcherServlet 进行实例化，然后调用它的 init() 方法进行初始化，在这个初始化过程中完成了：对 web.xml 中初始化参数的加载；建立 WebApplicationContext(SpringMVC的IOC容器)；进行组件的初始化；<br>客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理；<br>DispatcherServlet 从容器中取出所有 HandlerMapping 实例（每个实例对应一个 HandlerMapping接口的实现类）并遍历，每个 HandlerMapping 会根据请求信息，通过自己实现类中的方式去找到处理该请求的 Handler(执行程序，如Controller中的方法)，并且将这个 Handler 与一堆 HandlerInterceptor (拦截器)封装成一个 HandlerExecutionChain 对象，一旦有一个 HandlerMapping 可以找到 Handler则退出循环；<br>DispatcherServlet 取出 HandlerAdapter 组件，根据已经找到的 Handler，再从所有HandlerAdapter 中找到可以处理该 Handler 的 HandlerAdapter 对象；<br>执行 HandlerExecutionChain 中所有拦截器的 preHandler() 方法，然后再利用<br>HandlerAdapter 执行 Handler ，执行完成得到 ModelAndView，再依次调用拦截器的<br>postHandler() 方法；<br>利用 ViewResolver 将 ModelAndView 或是 Exception（可解析成 ModelAndView）解析成View，然后 View 会调用 render() 方法再根据 ModelAndView 中的数据渲染出页面；<br>最后再依次调用拦截器的 afterCompletion() 方法，这一次请求就结束了。<br>拦截器的作用<br>目的：让未登录用户不能访问某些页面<br>原理：在方法前标注自定义注解，拦截所有的请求，只处理带有该注解的方法。</p><h2 id="什么是SSM框架？"><a href="#什么是SSM框架？" class="headerlink" title="什么是SSM框架？"></a>什么是SSM框架？</h2><p>包括Spring + Spring MVC(和Spring天生集成) + MyBatis（帮你和数据库打交道的框架，简单的设置，你就可以像Java一样，操作数据库了）</p><h2 id="怎么实现注册功能的？"><a href="#怎么实现注册功能的？" class="headerlink" title="怎么实现注册功能的？"></a>怎么实现注册功能的？</h2><p>根据请求来拆解功能<br>1，打开注册网页<br>2，把注册的信息发送给服务器（点注册）<br>3，把激活邮件发送给邮箱<br>4，利用激活链接打开网页</p><p>每一次请求都是先开发数据访问层，在开发业务层，最后开发视图层（三层架构），但是每一次请求不一定要用到这三层</p><h2 id="什么是Interceptor，在项目的哪里使用到了Interceptor"><a href="#什么是Interceptor，在项目的哪里使用到了Interceptor" class="headerlink" title="什么是Interceptor，在项目的哪里使用到了Interceptor?"></a>什么是Interceptor，在项目的哪里使用到了Interceptor?</h2><p>Interceptor是SpringMVC的处理器（handler)拦截器，用于对处理器进行预处理和后处理。本项目中，每次请求都会检查request中的login_ticket，把找到的user信息存放在协程中，并在完成处理后，自动释放。（方便的进行用户信息取用）</p><h2 id="使用什么技术生成验证码"><a href="#使用什么技术生成验证码" class="headerlink" title="使用什么技术生成验证码?"></a>使用什么技术生成验证码?</h2><p>使用Kaptcha包，可随机生成字符和图片。</p><h2 id="如何检查登陆状态"><a href="#如何检查登陆状态" class="headerlink" title="如何检查登陆状态"></a>如何检查登陆状态</h2><p>加拦截器注解。</p><h2 id="如何实现敏感词过滤"><a href="#如何实现敏感词过滤" class="headerlink" title="如何实现敏感词过滤"></a>如何实现敏感词过滤</h2><p>使用前缀树（字典树）存储敏感词，对text中的敏感词实现替换。</p><h2 id="什么是Ajax，应用在项目哪些地方？"><a href="#什么是Ajax，应用在项目哪些地方？" class="headerlink" title="什么是Ajax，应用在项目哪些地方？"></a>什么是Ajax，应用在项目哪些地方？</h2><p>ajax指异步的json和xml技术，不是一门新的语言，而是使用现有技术的新方法。最大的特点是：不重新加载整个页面的基础上，可以与服务器交换数据，并更新部分网页数据。<br>项目中：帖子发布成功/失败的提示，使用到ajax</p><h2 id="什么是事务，事务的四大特性。"><a href="#什么是事务，事务的四大特性。" class="headerlink" title="什么是事务，事务的四大特性。"></a>什么是事务，事务的四大特性。</h2><p>定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。<br>事物的四大特性-ACID：<br>A：原子性，事务是最小的执行单位，不允许被分割，事务的全部操作要么全部提交成功，要么全部失败回滚。<br>C：一致性，数据库在事务执行前后保持一致性状态，在一致性状态下，所有事务对同一个数据的读取结果相同。<br>I ：隔离性，一个事务所作的修改在最终提交前，对其他事务是不可见的。避免多个事物交叉执行所导致的数据不一致问题。<br>D（Duability）：持久性，一旦事务提交，所做的修改将被永远保存到数据库中。即使系统发生崩溃，事务执行的结构也不能丢失。</p><h2 id="怎么利用Spring实现事务管理"><a href="#怎么利用Spring实现事务管理" class="headerlink" title="怎么利用Spring实现事务管理"></a>怎么利用Spring实现事务管理</h2><p>Spring管理事务忽略了底层数据库的结构，非常方便。有两种方式：注解（类型，传播方式）/编程式事务（override)。</p><h2 id="是怎样实现统一捕获异常的？"><a href="#是怎样实现统一捕获异常的？" class="headerlink" title="是怎样实现统一捕获异常的？"></a>是怎样实现统一捕获异常的？</h2><p>在SpringBoot的项目某一路径下，加上对应的错误页面，发生错误时自动会跳转。服务器的三层结构中，错误会层层向上传递，所以只需要在表现层（controller)统一处理错误即可。<br>方法：在controller中加上advice包，并通过注解@ControllerAdvice和@ExceptionHandler，统一捕获异常。</p><h2 id="是怎样实现统一记录日志的？"><a href="#是怎样实现统一记录日志的？" class="headerlink" title="是怎样实现统一记录日志的？"></a>是怎样实现统一记录日志的？</h2><p>使用了AOP技术（面向切面编程），这里使用到的是SpringAOP。 AOP技术能够将哪些与业务，但是为业务模块共同调用的逻辑或责任（比如事务处理，日志记录，权限控制等），封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和维护性。 SpringAOP本质上基于动态代理，当要代理的对象实现了某接口，会使用JDK动态代理，在运行时通过创建接口的代理实例，织入代码。当要代理的对象没有实现接口，则使用Cglib技术（编译时增强），通过子类代理织入代码。</p><h2 id="什么是Redis，Redis有哪些优点？"><a href="#什么是Redis，Redis有哪些优点？" class="headerlink" title="什么是Redis，Redis有哪些优点？"></a>什么是Redis，Redis有哪些优点？</h2><p>概念：redis是一个非关系型数据库，数据存储在内存中，读写速度快。可以存储键和五种不同类型值的映射。只能以字符串为键，值支持：字符串，列表，无序集合，有序集合，hash散列表。<br>优点：由于数据存储在内存中，读写速度非常快，满足高性能，高并发的系统要求。与Java原生的map/guava相比，支持分布式缓存。与memcached相比，支持更丰富的数据类型，且支持数据持久化。</p><h2 id="Redis分布式集群架构"><a href="#Redis分布式集群架构" class="headerlink" title="Redis分布式集群架构"></a>Redis分布式集群架构</h2><p>典型的分片+复制</p><h2 id="怎么往Spring框架中配置Redis，介绍常见的Redis操作"><a href="#怎么往Spring框架中配置Redis，介绍常见的Redis操作" class="headerlink" title="怎么往Spring框架中配置Redis，介绍常见的Redis操作"></a>怎么往Spring框架中配置Redis，介绍常见的Redis操作</h2><p>如何配置：<br>1，导入jar包<br>2，配置端口，以及配置类redisTemplate（注入连接工厂/设置序列化方式（json））<br>常见操作<br>Value类型：redisTemplate.opsForValue().set(redisKey, 1)，redisTemplate.opsForValue().get(redisKey)， redisTemplate.opsForValue().increment(redisKey)，<br>Hash类型：redisTemplate.opsForHash().put(redisKey, “id”, 1)， 还有get等操作<br>List类型：redisTemplate.opsForList().leftPush(redisKey, 101)， 还有size, index, range， leftPop等操作<br>Set类型：add, size, pop, members等操作<br>Zset类型：redisTemplate.opsForZSet().add(redisKey, “Linda”, 92), 有socre，rank，reverseRank， range等操作<br>操作key：可以delete，以及设置过期时间<br>同时支持绑定操作，支持事务（编程式事务，在事务中一般不包含查询）<br>为什么不包含查询：redis事务就是一系列命令的批量操作，批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p><h2 id="项目中Redis的作用"><a href="#项目中Redis的作用" class="headerlink" title="项目中Redis的作用"></a>项目中Redis的作用</h2><p>1、事务操作：redisTemplate直接调用opfor…来操作redis数据库，每执行一条命令是要重新拿一个连接，因此很耗资源，让一个连接直接执行多条语句的方法就是使用SessionCallback，同样作用的还有RedisCallback，但不常用。<br>2、使用redis存储验证码：</p><p>因为验证码需要频繁的进行访问与刷新，因此对性能的要求较高；<br>验证码不需要永久保存，通常在很短的时间后就会失效；<br>分布式部署的时候，存在session共享的问题。<br>3、使用redis存储登录凭证：<br>因为后台在每次处理请求的时候都要查询用户的登录凭证，访问的频率非常高，因此需要使用redis存储。<br>4、使用redis缓存用户信息：<br>因为后台在每次处理请求的时候都要根据用户的凭证用户信息，访问的频率非常高。<br>5、Redis可以使用zset对需要排序的数据进行自定义的排序。</p><p>怎样存储的点赞/关注/缓存用户数据<br>点赞使用set类型存储，key为点赞对象，set中保存点赞人的ID<br>关注使用zSet类型存储，key为被关注者，set保存关注者以及关注时间为score<br>缓存用户数据使用Value类型，key为用userID得到的key，value为user对象（设置过期时间，且数据修改时需要清除缓存）</p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列是一个存放消息的容器，生产者把消息放在队列中，消费者从消息队列中取出数据。消息队列的主要功能（优点）在于：</p><p>解耦：生产者只负责把消息放在队列中，而不用关心谁去使用它。<br>异步：生产者把消息放在队列中后即可返回，而不用一个个的通知消费者去执行，消费者是异步的获取消息的。<br>限流：生产者一次性产生大量的数据时，不会给消费者造成压力，消费者可以根据自身的能力，去消息队列中取数据。<br>消息队列作为信息传递的中间件，需要注意哪些问题？<br>1、高可用：因为消息队列如果宕机，会导致整个系统不可用。（分布式/集群的现成支持）<br>2、数据持久化：防止数据丢失<br>3、如何取数据：消息队列主动通知或者消费者轮询。</p><p>Java中的blockingqueue，可以提供线程间的消息队列<br>BQ也是生产者与消费者模式，属于点对点式消息队列？（一个消息只会被消费一次）Blocking Queue构建了一个桥梁，能够解决生产速度/消费速度不匹配问题。阻塞的时候只是在那里等着，但是不会占用CPU资源，对性能不会有影响。</p><h2 id="什么是Kafka，有哪些功能和应用场景？"><a href="#什么是Kafka，有哪些功能和应用场景？" class="headerlink" title="什么是Kafka，有哪些功能和应用场景？"></a>什么是Kafka，有哪些功能和应用场景？</h2><p>Kafka为分布式流处理平台。流处理是指对不断产生的动态数据流实时处理，基于分布式内存，具有数据处理快速，高效，低延迟的特性。</p><p>Kafka简介：Kafka是一种消息队列，主要用来处理大量数据状态下的消息队列，一般用来做日志的处理，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景<br>特点：</p><p>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。<br>可扩展性：kafka集群支持热扩展<br>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失<br>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）<br>高并发：支持数千个客户端同时读写<br>Kafka主要提供的功能包括：消息系统，日志收集，用户行为跟踪，流式数据处理。</p><h2 id="Kafka的基础架构"><a href="#Kafka的基础架构" class="headerlink" title="Kafka的基础架构"></a>Kafka的基础架构</h2><p>Producer：消息生产者，向Kafka中发布消息的角色。<br>Consumer：消息消费者，即从Kafka中拉取消息消费的客户端。<br>Consumer Group：消费者组，消费者组则是一组中存在多个消费者，消费者消费Broker中当前Topic的不同分区中的消息，消费者组之间互不影响，所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。某一个分区中的消息只能够一个消费者组中的一个消费者所消费<br>Broker：经纪人，一台Kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic。<br>Topic：主题，可以理解为一个队列，生产者和消费者都是面向一个Topic<br>Partition：分区，为了实现扩展性，一个非常大的Topic可以分布到多个Broker上，一个Topic可以分为多个Partition，每个Partition是一个有序的队列(分区有序，不能保证全局有序)<br>Replica：副本Replication，为保证集群中某个节点发生故障，节点上的Partition数据不丢失，Kafka可以正常的工作，Kafka提供了副本机制，一个Topic的每个分区有若干个副本，一个Leader和多个Follower<br>Leader：每个分区多个副本的主角色，生产者发送数据的对象，以及消费者消费数据的对象都是Leader。<br>Follower：每个分区多个副本的从角色，实时的从Leader中同步数据，保持和Leader数据的同步，Leader发生故障的时候，某个Follower会成为新的Leader。</p><p>Kafka的消息模型，以及常见术语<br>消息模型：发布-订阅模型，消费者订阅了某一主题（topic）后，生产者采用类似广播的方式，将消息通过主题传递给所有的订阅者。<br>Topic：主题，类似于文件夹，用来存放不同的数据。<br>Partition：主题分区，同一主题的不同分区可以存放在不同的Broker上面，保证并发能力和负载均衡。<br>Offset：消息在Partition中的存放位置。<br>Broker：可以理解为kafka集群里面的一台或多台服务器，它本身是没有复制的，上面可能运行着topic1的leader， topic2的follower等等。</p><h2 id="在项目哪里用到了Kafka？"><a href="#在项目哪里用到了Kafka？" class="headerlink" title="在项目哪里用到了Kafka？"></a>在项目哪里用到了Kafka？</h2><p>当有点赞，评论，关注请求时，会发送系统通知点赞，评论，关注的对象。在处理系统信息时，使用到了Kafka，具体来说，先定义了生产者类和消费者类，其中生产者被点赞/评论/关注功能对应的Controller使用，产生消息。而消费者负责消息（message）到来时，把消息存到数据库内。</p><h2 id="什么是ElasticSearch，存储原理，功能，特点"><a href="#什么是ElasticSearch，存储原理，功能，特点" class="headerlink" title="什么是ElasticSearch，存储原理，功能，特点"></a>什么是ElasticSearch，存储原理，功能，特点</h2><p>概念：ES是一个基于lucene构建的，分布式的，RESTful的开源全文搜索引擎。<br>存储原理：数据按照Index – Type – Document – 字段四级存储，其中Index对应数据库，Type对应表，Document为搜索的原子单位，包含一个或多个容器，基于JSON表示。字段是指JSON中的每一项组成，类似于数据库中的行/列。Mapping是文档分析过滤后的结果，根据用户自定义，将某些文字过滤掉，类似于表结构定义DDL？？。同时ES也和分布式数据库一样，支持shard的replication。<br>功能：<br>1、分布式的搜索引擎和数据分析引擎<br>2、全文检索，结构化检索，数据分析。<br>3、对海量数据进行近实时的处理<br>特点：<br>1、可以作为分布式集群处理PB级别的数据，也可单机使用。<br>2、不是特有技术，而是将分布式+全文搜索（lucene) + 数据分析合并在一起。<br>3、操作简单，作为传统数据库的补充，提供了数据库所不具备的很多功能。</p><h2 id="项目中哪里使用到了ES-如何使用"><a href="#项目中哪里使用到了ES-如何使用" class="headerlink" title="项目中哪里使用到了ES,如何使用"></a>项目中哪里使用到了ES,如何使用</h2><p>在进行帖子搜索时，使用到了ES。可用Repository和Template两种方式，由于Repository搜索到的结果（直接返回的post类，方便）没有高亮标签（why），所以使用了template方式重写了mapResults函数，获得了带有高亮标签的post。<br>使用消息队列（kafka）的方式，实现发帖/删帖后ES数据库的自动更新。<br>搜索：定义SearchQuery，确定搜素内容，排序方式，高亮等。接着使用elasticTemplate.queryForPage方法，需要重写mapResults函数，得到高亮数据。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录仿牛客论坛记录一些不懂的地方&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>kafka相关</title>
    <link href="http://example.com/2021/11/07/kafka%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/11/07/kafka%E7%9B%B8%E5%85%B3/</id>
    <published>2021-11-07T02:26:32.000Z</published>
    <updated>2021-11-11T07:41:45.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一点kafka相关面试题</p><p>guide哥、3y哥，敖丙哥，入门必看，接着再看其他文章深入理解</p></blockquote><a id="more"></a><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列的两种模型"><a href="#消息队列的两种模型" class="headerlink" title="消息队列的两种模型"></a>消息队列的两种模型</h3><p>消息队列有两种模型：<strong>队列模型</strong>和<strong>发布/订阅模型</strong>。</p><p><strong>队列模型</strong></p><p>生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者， 但是每条消息只能被一个消费者消费。如果我们想要一条消息被多个消费者消费，就需要用到发布-订阅模型</p><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/640.webp" alt="图片"></p><p><strong>发布/订阅模型</strong></p><p><strong>为了解决一条消息能被多个消费者消费的问题</strong>，就出现了发布/订阅模型。该模型是将消息发往一个<code>Topic</code>即主题中，所有订阅了这个 <code>Topic</code> 的消费者都能消费这条消息。</p><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107224113649.png" alt="image-20211107224113649"></p><p>消息队列的应用场景：<strong>解耦、异步、削峰</strong></p><h3 id="为什么要使用消息队列？（优点）"><a href="#为什么要使用消息队列？（优点）" class="headerlink" title="为什么要使用消息队列？（优点）"></a><strong>为什么要使用消息队列？</strong>（优点）</h3><p>主要从消息队列的使用场景来分析，比如说在哪些场景下消息队列会带来好处</p><p><strong>解耦</strong></p><p>A 系统发送数据到 BCD 三个系统，如果之后不需要发送数据给C系统，或者说还需要发送数据给新的系统，那么就需要反复调整架构，修改代码，因为他们的耦合性很高。</p><p>我们现在使用MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统就不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</p><p>通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。</p><p><strong>异步</strong></p><p>以商品下单作为例子，比如说我们下单买下商品后，还需要通过优惠券系统花时间扣除优惠券，通过积分系统花时间扣除积分，还需要花时间给用户发短信等等流程。但如果按照这个链路的话用户花的时间很长。</p><p>我们可以采用MQ，当用户支付成功后，采用异步的方式，扣除优惠券的同时增减积分啊，还可以同时发个短信，这样的话花的时间就少很多了。而这些步骤用多线程的方式，我们需要调用这些操作的接口，耦合性很高，出了问题也不好排查</p><p>所以通常使用MQ的方式来解决问题。你下单了，你就把你<strong>支付成功的消息告诉别的系统</strong>，他们收到了去处理就好了，你只用走完自己的流程，把自己的消息发出去，那后面要接入什么系统简单，直接订阅你发送的支付成功消息，你支付成功了我<strong>监听就好了</strong>。</p><p><strong>那你的流程走完了，你不用管别人是否成功么？比如你下单了积分没加，优惠券没扣怎么办？</strong></p><p>问题是个好问题，但是没必要考虑，业务系统本身就是自己的开发人员维护的，你积分扣失败关我下单的什么事情？你管好自己下单系统的就好了。</p><p><strong>削峰</strong></p><p>比如说在一个系统中数据库平常只能处理1k条请求，但是遇到秒杀的情况请求会暴增，这时候数据库一下子处理不了这么多请求就会导致系统崩溃。</p><p>我们可以将请求写入MQ中，然后系统按照能够承载的负荷拉取请求，虽然这样处理的方式可能慢一些，但是系统至少不会崩溃，可以在请求高峰期过后慢慢消化掉MQ中的请求。</p><h3 id="MQ缺点"><a href="#MQ缺点" class="headerlink" title="MQ缺点"></a>MQ缺点</h3><p><strong>高可用</strong>、消息<strong>重复消费</strong>、<strong>消息丢失</strong>、<strong>消息的顺序消费</strong>、数据一致性（消费者消费完后是否成功了？）</p><p>缺点有以下几个：</p><ul><li><strong>系统可用性降低</strong><br>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整，MQ 一挂，整套系统崩溃的，你不就完了？如何保证消息队列的高可用，可以<a href="https://github.com/heqiyoujing/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md">点击这里查看</a>。</li><li><strong>系统复杂度提高</strong><br>硬生生加个 MQ 进来，你怎么<a href="https://github.com/heqiyoujing/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed.md">保证消息没有重复消费</a>？怎么<a href="https://github.com/heqiyoujing/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages.md">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</li><li><strong>一致性问题</strong><br>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</li></ul><h3 id="有哪些消息中间件呢？"><a href="#有哪些消息中间件呢？" class="headerlink" title="有哪些消息中间件呢？"></a><strong>有哪些消息中间件呢？</strong></h3><p><strong>Kafka、ActiveMQ、RabbitMQ、RocketMQ</strong></p><p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka </p><p>RocketMQ是ali研发的具有高吞吐量的MQ</p><h2 id="Kafka是什么"><a href="#Kafka是什么" class="headerlink" title="Kafka是什么"></a>Kafka是什么</h2><p>Kafka是一个分布式的流处理平台。</p><p>主要功能：（官网上对它有介绍）</p><p>1.消息队列：发布和订阅消息</p><p>2.将消息流存储下来：Kaka会把消息持久化到磁盘，有效避免了消息丢失的风限。</p><p>3.流式处理平台：在消息发布的时候进行处理，Kafka提供了一个完整的流式处理类库。</p><p>总的来说就是传输数据，处理数据的功能</p><h2 id="Kafka消息队列入门"><a href="#Kafka消息队列入门" class="headerlink" title="Kafka消息队列入门"></a>Kafka消息队列入门</h2><p>生产者、消费者、消费者群组、broker、topic、partition、leader、follwer。</p><p>把消息放到队列里边的叫<strong>生产者</strong>，从队列里边消费的叫<strong>消费者</strong>。</p><p><strong>Broker</strong>：我们把kafka集群中一个kafka服务器实例叫做Broker</p><p><strong>Topic</strong>：简单理解为存储不同类型消息的队列，一种类型消息队列就是一个topic。生产者将消息发送到特定的topic，消费者通过订阅特定的topic来消费消息</p><p><strong>Partition</strong>：为了提高系统的吞吐量，我们会对topic进行分区，分为一个个的partition。Partition属于 Topic的一部分。一个 Topic有多个 Partition，并且同一 Topic下的 Partition可以分布在不同的 Broker上。</p><p>kafka的<strong>多副本机制</strong>-》引出<strong>leader</strong>和<strong>follwer。</strong></p><p>每个partition在不同broker中有备份，我们称为follwer，而主partion称为leader。生产者和消费者只和leader进行交互，如果leader所在的broker出现了故障，就会从follwer中推选出一个作为leader。</p><p><strong>问题：Kafka的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong><br>1.Kafka通过给特定Topic指定多个 Partition，而各个 Partition可以分布在不同的 Broker上，这样便能提供比较好的并发能力（<strong>负载均衡</strong>）。<br>2.Partition可以指定对应的 Replica数，这也极大地提高了消息存储的安全性，提高了容灾能力，不过也相应的增加了所需要的存储空间。（<strong>数据备用</strong>）</p><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107225518472.png" alt="image-20211107225518472"></p><p>一台Kafka服务器叫做<strong>Broker</strong>，Kafka集群就是多台Kafka服务器：</p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107225558077.png" alt="image-20211107225558077" style="zoom: 50%;" /><p>一个topic会分为多个partition，实际上partition会<strong>分布</strong>在不同的broker中：</p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107225658286.png" alt="image-20211107225658286" style="zoom:50%;" /><p>现在我们已经知道了往topic里边丢数据，实际上这些数据会分到不同的partition上，这些partition存在不同的broker上。分布式肯定会带来问题：“万一其中一台broker(Kafka服务器)出现了故障怎么办？”</p><p>每个partition在不同broker中有备份，我们称为follwer，而主partion称为leader。生产者和消费者只和leader进行交互，如果leader所在的broker出现了故障，就会从follwer中推选出一个作为leader。</p><p>现在我们有三个partition，分别存在三台broker上。每个partition都会备份，这些备份散落在<strong>不同</strong>的broker上。</p><p>在一个消费者组中，<strong>每个消费者去消费一个分区</strong>（也是为了提高吞吐量）</p><ul><li>如果消费者组中的某个消费者挂了，那么其中一个消费者可能就要消费两个partition了</li><li>如果只有三个partition，而消费者组有4个消费者，那么一个消费者会空闲</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/image-20211107230812009.png" alt="image-20211107230812009"></p><p>如果一个消费者组中的某个消费者挂了，那挂掉的消费者所消费的分区可能就由消费组中存活的消费者消费。那<strong>存活的消费者是如何知道挂掉的消费者消费到哪了？</strong></p><p>这里要引出<code>offset</code>了，Kafka就是用<code>offset</code>来表示消费者的消费进度到哪了，每个消费者会都有自己的<code>offset</code>。说白了<code>offset</code>就是表示消费者的<strong>消费进度</strong>。</p><p>在以前版本的Kafka，这个<code>offset</code>是由Zookeeper来管理的，后来Kafka开发者认为Zookeeper不合适大量的删改操作，于是把<code>offset</code>在broker以内部topic(<code>__consumer_offsets</code>)的方式来保存起来。</p><p>每次消费者消费的时候，都会提交这个<code>offset</code>，Kafka可以让你选择是自动提交还是手动提交。</p><p>既然提到了Zookeeper，那就多说一句。Zookeeper虽然在新版的Kafka中没有用作于保存客户端的<code>offset</code>，但是Zookeeper是Kafka一个重要的依赖。</p><ul><li>探测broker和consumer的添加或移除。</li><li>负责维护所有partition的领导者/从属者关系（主分区和备份分区），如果主分区挂了，需要选举出备份分区作为主分区。</li><li>维护topic、partition等元配置信息</li></ul><p><a href="https://www.cnblogs.com/heqiyoujing/p/10926087.html">https://www.cnblogs.com/heqiyoujing/p/10926087.html</a>  写得有点详细关于如何处理消息队列的问题</p><h2 id="Zookeeper在Kafka中的作用"><a href="#Zookeeper在Kafka中的作用" class="headerlink" title="Zookeeper在Kafka中的作用"></a>Zookeeper在Kafka中的作用</h2><p>Zookeeper为分布式消息队列框架提供开源的分布式<strong>配置服务、同步服务和命名注册。</strong></p><p>ZooKeeper主要为 Kafka提供 <strong>Broker和 Topic的注册</strong>以及<strong>多个 Partition的负载均衡</strong>等功能</p><p>1.<strong>Broker注册</strong>：在 Zookeeper上会有一个专门用来进行 Broker服务器列表记录的节点。每个 Broker在启动时，都会到 Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点。每个 Broker就会将自己的P地址和端口等信息记录到该节点中去</p><p>2.<strong>Topic注册</strong>：在Kaka中，同一个 Topic的消息会被分成多个分区并将其分布在多个Broker上，这些分区信息及与 Broker的对应关系也都是由 Zookeeper在维护。比如我创建了一个名字为 my-topic的主题并且它有两个分区，对应到z0 keeper中会创建这些文件XE：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></p><p>3.<strong>负载均衡</strong>：上面也说过了 Kafka通过给特定 Topic指定多个 Partition，而各个 Partition可以分布在不同的 Broker上，这样便能提供比较好的并发能力。对于同一个 Topic的不同Partition，Kafka会尽力将这些 Partition分布到不同的 Broker服务器上。当生产者产生消息后也会尽量投递到不同 Broker的 Partition里面。当 <strong>Consumer消费的时候，Zookeeper可以根据当前的 Partition数量以及 Consumer数量来实现动态负载均衡。</strong></p><h2 id="如何保证消息的有序性？"><a href="#如何保证消息的有序性？" class="headerlink" title="如何保证消息的有序性？"></a>如何保证消息的有序性？</h2><p>我们的消息都是发送给topic，而topic由多个partition组成并分散到不同的broker中。</p><p>kafka每次添加消息到 Partition的时候都会采用尾加法，即每次添加到partition的尾部。这样能保证Partition中的消息有序，而不能保证Topic中不同的 Partition的有序。</p><blockquote><p>消息在被追加到 Partition（分区）的时候都会分配一个特定的偏移量（offset）。Kafka通过偏移量（offset）来保证消息在分区内的顺序性。 </p></blockquote><ul><li><p>因此我们可以用一种简单的方式：1个Topic只对应一个 Partition，就不用担心topic中不同partition的顺序问题。</p></li><li><p>还可以这样：将要求有序的消息发送到指定的partition，这样消费者每次从指定的partition中取也可以保证消息的有序性。</p></li></ul><h2 id="如何保证消息不丢失？"><a href="#如何保证消息不丢失？" class="headerlink" title="如何保证消息不丢失？"></a>如何保证消息不丢失？</h2><p><strong>生产者丢失消息</strong></p><p><strong>kafka丢失消息</strong></p><p><strong>消费者丢失消息</strong></p><h2 id="如何保证消息队列高可用"><a href="#如何保证消息队列高可用" class="headerlink" title="如何保证消息队列高可用"></a>如何保证消息队列高可用</h2><p>​    将partition备份到多个broker中</p><h2 id="如何保证消息不被重复消费？"><a href="#如何保证消息不被重复消费？" class="headerlink" title="如何保证消息不被重复消费？"></a><strong>如何保证消息不被重复消费？</strong></h2><h2 id="Zookeeper是什么？"><a href="#Zookeeper是什么？" class="headerlink" title="Zookeeper是什么？"></a>Zookeeper是什么？</h2><p>有使用过的，使用ZooKeeper作为<strong>dubbo的注册中心</strong>，使用ZooKeeper实现<strong>分布式锁</strong>。</p><p>ZooKeeper，它是一个开放源码的<strong>分布式协调服务</strong>，它是一个集群的管理者，它将简单易用的接口提供给用户。</p><p><strong>可以基于Zookeeper 实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能</strong></p><p>Zookeeper的<strong>用途</strong>：命名服务、配置管理、集群管理、分布式锁、队列管理</p><p><strong>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。</strong> 服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。</p><p>ZooKeeper的视图数据结构，很像Unix文件系统，也是树状的，这样可以确定每个路径都是唯一的。zookeeper的节点统一叫做<strong>znode</strong>，它是可以通过<strong>路径来标识</strong>，结构图如下： <img src="/images/kafka%E7%9B%B8%E5%85%B3/8d7058978e614f7f8ee4832cb3b9c7cbtplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h3 id="znode的4种类型"><a href="#znode的4种类型" class="headerlink" title="znode的4种类型"></a>znode的4种类型</h3><p>根据节点的生命周期，znode可以分为4种类型，分别是持久节点（PERSISTENT）、持久顺序节点（PERSISTENT_SEQUENTIAL）、临时节点（EPHEMERAL）、临时顺序节点（EPHEMERAL_SEQUENTIAL）</p><ul><li><strong>持久节点</strong>（PERSISTENT）</li></ul><blockquote><p>这类节点被创建后，就会一直存在于Zk服务器上。直到手动删除。</p></blockquote><ul><li><strong>持久顺序节点</strong>（PERSISTENT_SEQUENTIAL）</li></ul><blockquote><p>它的基本特性同持久节点，不同在于增加了顺序性。父节点会维护一个自增整性数字，用于子节点的创建的先后顺序。</p></blockquote><ul><li><strong>临时节点</strong>（EPHEMERAL）</li></ul><blockquote><p>临时节点的生命周期与客户端的会话绑定，一旦客户端会话失效（非TCP连接断开），那么这个节点就会被自动清理掉。zk规定临时节点只能作为叶子节点。</p></blockquote><ul><li><strong>临时顺序节点</strong>（EPHEMERAL_SEQUENTIAL）</li></ul><blockquote><p>基本特性同临时节点，添加了顺序的特性。</p></blockquote><h3 id="znode节点上的监听机制"><a href="#znode节点上的监听机制" class="headerlink" title="znode节点上的监听机制"></a>znode节点上的监听机制</h3><p>Zookeeper 允许客户端向服务端的某个Znode注册一个Watcher监听，可以理解为Watcher就是客户端注册在某个Znode上的触发器，当这个Znode节点发生变化时（增删改查），就会触发Znode对应的注册事件，注册的客户端就会收到通知，然后做出业务的改变。</p><p><strong>监听触发流程：</strong></p><ul><li><p>ZooKeeper的Watcher机制主要包括客户端线程、客户端 WatcherManager、Zookeeper服务器三部分。</p></li><li><p>客户端向ZooKeeper服务器注册Watcher的同时，会将Watcher对象存储在客户端的WatchManager中。</p></li><li><p>当zookeeper服务器触发watcher事件后，会向客户端发送通知， 客户端线程从 WatcherManager 中取出对应的 Watcher 对象来执行回调逻辑</p></li></ul><h2 id="CAP定理是什么？"><a href="#CAP定理是什么？" class="headerlink" title="CAP定理是什么？"></a>CAP定理是什么？</h2><p>指的是在一个分布式系统中，Consistency（一致性）、</p><p>Availability（可用性）、Partitiontolerance（分区容错性），三者不可兼得，最多只可以同时实现两个。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p><strong>实现分布式锁的三种方法</strong>：mysql、redis、Zookeeper</p><p>应用在单机部署的情况下，要保证资源在同一时刻只能被一个线程战友，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成<strong>分布式集群系统</strong>后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就<strong>需要一种跨机器的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题！</p><p><strong>分布式锁一般有如下的特点</strong>：</p><ul><li><strong>互斥性</strong>： 同一时刻只能有一个线程持有锁</li><li><strong>可重入性</strong>： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁</li><li><strong>锁超时</strong>：和J.U.C中的锁一样支持锁超时，防止死锁</li><li><strong>高性能和高可用</strong>： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效</li><li><strong>具备阻塞和非阻塞性</strong>：能够及时从阻塞状态中被唤醒</li></ul><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p><strong>获取锁</strong>：（假设共享资源是某个方法）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> methodLock(method_name,<span class="keyword">desc</span>) <span class="keyword">values</span> (‘method_name’,‘<span class="keyword">desc</span>’)</span><br></pre></td></tr></table></figure><p>因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。</p><p><strong>释放锁</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> methodLock <span class="keyword">where</span> method_name =<span class="string">&#x27;method_name&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>存在问题</strong>：</p><p>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。<br>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。<br>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。<br>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p><p><strong>解决方案</strong>：<br>     1、数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。<br>     2、没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>     3、非阻塞的？搞一个while循环，直到insert成功再返回成功。<br>     4、非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p>谈起redis锁，下面三个，算是出现最多的高频词汇：</p><ul><li><strong>setnx</strong></li><li><strong>redLock</strong></li><li><strong>redisson</strong></li></ul><p><strong>setnx</strong></p><p>推荐使用set命令，后面跟上ex 和 nx 参数，即要设定过期时间，防止客户端还没释放锁就挂掉了，其他的客户端就抢不到锁了。</p><p>可以直接通过 <code>set key value px milliseconds nx</code> 命令实现加锁， 通过Lua脚本实现解锁</p><p>解释：ex：多少秒过期 ；px：多少毫秒过期 ； nx：如果键不存在则创建成功，否则失败</p><p><strong>redLock</strong></p><p>源码中<strong>加锁/释放锁</strong>操作都是用<strong>lua</strong>脚本完成的，封装的非常完善，开箱即用。</p><p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p><ol><li>获取当前时间戳，单位是毫秒；</li><li>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</li><li>尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；</li><li>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</li><li>要是锁建立失败了，那么就依次之前建立过的锁删除；</li><li>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</li></ol><p><strong>redisson</strong></p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a><strong>Zookeeper</strong></h3><p>Zookeeper使用<strong>临时顺序节点</strong>特性实现分布式锁的。</p><ul><li>获取锁过程 （创建临时节点，检查序号最小，其他的节点监听前一个节点）</li><li>释放锁 （删除临时节点，监听通知）</li></ul><h4 id="获取锁过程"><a href="#获取锁过程" class="headerlink" title="获取锁过程"></a>获取锁过程</h4><ul><li>当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点/locks。如果它（Client1）想获得锁，需要在locks节点下创建一个顺序节点lock1.如图</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/39e5ee84f901453fb894600c331693d6tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>接着，客户端Client1会查找locks下面的所有临时顺序子节点，判断自己的节点lock1是不是排序最小的那一个，如果是，则成功获得锁。</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/e958178a196742b480a20dff85dfef4ftplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点lock2</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/34a3a0f7221b4de79e1ed5595d7c177ctplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/a17880856e1546bba4f2571dbf8b3b38tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/abda17df527b4dbe8faa7e3a3a9e859etplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><ul><li>同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。</li></ul><p><img src="/images/kafka%E7%9B%B8%E5%85%B3/5a8725119723434daddca761b0d7be83tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>我们再来看看释放锁的流程，zookeeper的<strong>客户端业务完成或者故障</strong>，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令 <img src="/images/kafka%E7%9B%B8%E5%85%B3/ecf2bec179f64ef79b180f66a327e634tplv-k3u1fbpfcp-watermark.awebp" alt="img"> 如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的 <img src="/images/kafka%E7%9B%B8%E5%85%B3/e87703be60a3407e9e570c86bd4c180dtplv-k3u1fbpfcp-watermark.awebp" alt="img"> lock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。 <img src="/images/kafka%E7%9B%B8%E5%85%B3/be3c7146f2934dd69a598cdf974ab390tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~</p><p><strong>从性能角度（从高到低）:</strong> 缓存 &gt; Zookeeper &gt;= 数据库</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录一点kafka相关面试题&lt;/p&gt;
&lt;p&gt;guide哥、3y哥，敖丙哥，入门必看，接着再看其他文章深入理解&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>11.01</title>
    <link href="http://example.com/2021/11/01/11-01/"/>
    <id>http://example.com/2021/11/01/11-01/</id>
    <published>2021-11-01T13:26:39.000Z</published>
    <updated>2021-11-14T03:59:16.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>呱呱呱</p></blockquote><p>down了down了。</p><p>其实也很正常，你个非科班的花俩月时间（而且还是断断续续的），就能找到好实习，如果有这么简单，要么你就是神仙，要么你当那些科班的学了好几年的是傻子呀~</p><p>不过话说回来，这段时间对于一些基础的知识认识更加清晰了，也积累了一些面试的经验（被面试毒打），总归是很不错的。</p><p>不免有一丝丝动摇了我未来的职业规划。</p><p>以后再说吧，总之还没有结束呢，还有一堆简历在池子里，看能不能被捞吧。。。</p><hr><p>虽然但是，为什么字节一面还给我过了。迷。。</p><p>准备接受第二顿毒打</p><hr><p>！！为啥字节二面也过了。。许愿三面过</p><hr><p>三面g</p><hr><p>读书能让人的心静下来，不要带着压力带着太强的目的性去读书，就会很快乐。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;呱呱呱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;down了down了。&lt;/p&gt;
&lt;p&gt;其实也很正常，你个非科班的花俩月时间（而且还是断断续续的），就能找到好实习，如果有这么简单，要么你就是神仙，要么你当那些科班的学了好几年的是傻子呀~&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis相关</title>
    <link href="http://example.com/2021/10/30/Redis%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/30/Redis%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-30T01:52:52.000Z</published>
    <updated>2021-11-10T12:25:58.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录一点Redis相关面试题</p></blockquote><a id="more"></a><p><a href="https://www.nowcoder.com/discuss/780303?type=post&amp;order=time&amp;pos=&amp;page=0&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack">https://www.nowcoder.com/discuss/780303?type=post&amp;order=time&amp;pos=&amp;page=0&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack</a> </p><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><p>Redis（<code>Remote Dictionary Server</code>）是一个使用 <strong>C 语言编写</strong>的，高性能的、<strong>非关系型</strong>数据库，与mysql这种传统数据库不同的是，Redis存取的是<strong>键值对</strong>，并且Redis 的数据是存在<strong>内存中</strong>的，所以读写速度非常快，被广泛应用于缓存方向。同时，Redis的持久化机制可以将数据写入磁盘中，保证了数据的安全。</p><p>缓存通常适用于高并发的情况，那些经常被访问或者读写成本（比如说从磁盘的IO）很高的情况就需要用到缓存。</p><p>Redis中存储的是键值对，可以存储键和五种不同类型的值，键的类型只能为字符串，值支持五种数据类型：String、List、Hash、Set、SortedSet。</p><p>Redis还可以用来作<strong>缓存</strong>、<strong>分布式锁</strong>、<strong>消息队列</strong>，支持不同的业务场景。</p><p><strong>分布式缓存</strong>：</p><p><strong>分布式锁：</strong></p><p>set key value EX seconds nx </p><p>redlock  </p><p>redission</p><p><strong>消息队列：</strong></p><ul><li>通过List类型中的lpush、rpop命令实现 </li></ul><p>但使用 List 同样存在一定的问题，比如消息不支持重复消费、没有按照主题订阅的功能、不支持消费消息确认等。</p><ul><li><p>通过发布-订阅模式，可以让一个消费者订阅多个生产者</p><p>发布消息，publish channel “message”</p><p>订阅消息，subscribe channel</p></li></ul><h2 id="Redis优缺点？（Redis的功能和不足）"><a href="#Redis优缺点？（Redis的功能和不足）" class="headerlink" title="Redis优缺点？（Redis的功能和不足）"></a>Redis优缺点？（Redis的功能和不足）</h2><p><strong>优点</strong>：</p><ol><li><strong>基于内存操作</strong>，内存读写速度很快。 </li><li>Redis是<strong>单线程</strong>的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，即一个线程处理所有网络请求，Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。 </li><li>有一套<strong>过期数据的删除策略和内存淘汰机制</strong>保证不会发生内存不足。</li><li><strong>支持多种数据类型</strong>，包括String、List、Hash、Set、SortedSet等。 </li><li><strong>支持持久化</strong>。Redis支持<strong>RDB</strong>和<strong>AOF</strong>两种持久化机制，可以有效地避免数据丢失问题。 </li><li><strong>支持事务</strong>。Redis的所有操作命令都是原子性的， <strong>Redis的事务不支持原子性。</strong></li><li><strong>支持主从复制</strong>。主节点会自动将数据同步到从节点，可以进行读写分离。 </li></ol><p><strong>缺点</strong>：</p><ol><li>对结构化查询的支持比较差。 </li><li>数据库容量受到物理内存的限制，不适合用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。 </li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ol><h2 id="为什么Redis这么快？"><a href="#为什么Redis这么快？" class="headerlink" title="为什么Redis这么快？"></a>为什么Redis这么快？</h2><ul><li><p><strong>基于内存</strong>：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。</p></li><li><p><strong>单线程实现</strong>（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。</p></li><li><p><strong>IO多路复用模型</strong>：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。</p></li><li><p><strong>高效的数据结构</strong>：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。</p></li></ul><h2 id="Redis单线程模型介绍（完成未理解）"><a href="#Redis单线程模型介绍（完成未理解）" class="headerlink" title="Redis单线程模型介绍（完成未理解）"></a>Redis单线程模型介绍（完成未理解）</h2><p><strong>为什么说Redis是单线程模型呢？</strong></p><p>我们说Redis是单线程的，指的是执行 <strong>Redis 命令的核心模块</strong>是单线程的，而不是整个 Redis 实例就一个线程，Redis 其他模块还有各自模块的线程的。</p><p>Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为<strong>文件事件处理器</strong>。它的组成结构为4部分：<strong>多个套接字、IO多路复用程序、文件事件分派器、事件处理器</strong>。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型”</p><p><code>IO</code>多路复用程序会同时监听<strong>多个<code>socket</code>**，当被监听的<code>socket</code>准备好执行<code>accept</code>、<code>read</code>、<code>write</code>、<code>close</code>等操作时，与这些操作相对应的文件事件就会产生。</strong><code>IO</code>多路复用程序<strong>会把所有产生事件的<code>socket</code>压入一个队列中，然后有序地每次仅一个<code>socket</code>的方式传送给文件事件分派器，</strong>文件事件分派器<strong>接收到<code>socket</code>之后会根据<code>socket</code>产生的事件类型调用对应的</strong>事件处理器**进行处理。</p><p> Redis通过socket与客户端进行连接，并将服务器对socket的操作抽象为文件事件。redis通过单线程，并通过I/O多路复用来处理来自客户端的多个连接请求，当产生连接后，i/o多路复用程序，会将产生事件的套接字放置一个队列，通过队列以有序、同步的、每次一个套接字的方式向文件事件分派发器传送套接字。当上一个套接字的事件被处理完毕后，I/O多路复用才会向文件分派器传送下一个套接字。服务端通过监听这些事件，并完成相应的处理。被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作，与操作相关的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p>可以看出，文件事件处理器（file event handler）主要是包含4个部分：</p><ul><li>多个 socket（客户端连接）  <strong>socket是什么东东？</strong></li><li>IO多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket关联到相应的事件处理器）</li><li>·事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><img src="/images/Redis%E7%9B%B8%E5%85%B3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jldml2ZWRzdW4=,size_16,color_FFFFFF,t_70.png" alt="https://img-blog.csdnimg.cn/20190822004147554.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Jldml2ZWRzdW4=,size_16,color_FFFFFF,t_70" style="zoom: 50%;" /><p><strong>为什么Redis选择单线程模型呢？</strong></p><p>Redis 选择使用单线程模型处理客户端的请求，主要还是因为 CPU 不是 Redis 服务器的瓶颈，使用单线程已经足够快了，多线程会有性能提升，但不是很明显，而且多线程就会存在死锁、线程上下文切换等问题，所以综合来看使用单线程处理请求就已经够了。</p><p>事实上也是有多线程的，而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p><p><strong>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</strong></p><p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <strong>I/O 多路复用</strong>就是为了解决这个问题而出现的。</p><p><strong>IO多路复用技术的理解</strong></p><p>IO 多路复用机制是指一个线程处理多个 IO 流，简单来说就是<code>IO</code>多路复用程序会同时监听多个<code>socket</code>，当哪个socket执行操作后会将其交给相应的事件处理器。</p><h2 id="为什么又说Redis中有多线程呢？"><a href="#为什么又说Redis中有多线程呢？" class="headerlink" title="为什么又说Redis中有多线程呢？"></a>为什么又说Redis中有多线程呢？</h2><p>在Redis 4.0 版本开始就有多线程的概念了，比如 Redis 通过<strong>多线程方式在后台删除一些比较大的键值对</strong></p><p>在Redis 6.0 版本 里的多线程主要是为了提高网络IO读写性能， 执行命令的核心模块还是单线程的，因为Redis性能主要受限于内存和网络IO。</p><p>IO 多线程处理模式默认是不开启的，需要去配置文件中开启并配置线程数</p><p><strong>为什么网络处理要引入多线程？</strong></p><p>前面有提到过，<strong>Redis 的瓶颈并不在 CPU，而在内存和网络。</strong></p><p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p><h2 id="Redis的数据结构和应用场景"><a href="#Redis的数据结构和应用场景" class="headerlink" title="Redis的数据结构和应用场景"></a>Redis的数据结构和应用场景</h2><p>Redis有5种数据类型：String 、List（双向链表）、Hash（键值对）、Set（不重复）、SortedSet（排序不重复）</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/1289934-20190621163930814-1395015700.png" alt="img"></p><p><strong>String</strong></p><p>String是最简单的Key-value类型，存储的是字符串。一个字符串类型的值能存储最大容量是<strong>512M</strong>。</p><p>底层是一个简单的动态字符串，和C语言的字符串有区别，空间不足会自动扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line">exists key</span><br><span class="line">strlen key</span><br><span class="line">del key</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong>：一般用在需要计数的场景，比如用户的访问次数、文章的点赞数等等</p><p><strong>List</strong></p><p>List是一个双向链表</p><p><strong>应用场景</strong>：发布与订阅</p><p><strong>rpush 和 lpop 实现队列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpush key value1 value2 Value3 从右边添加</span><br><span class="line">lpop key     从左边取出</span><br><span class="line">&quot;value&quot; </span><br><span class="line">lrange key 0 1  从左到右查看  ,0 是开始， 1是结束</span><br><span class="line">&quot;value2&quot; &quot;value3&quot; </span><br><span class="line">lrange key 0 -1 查看列表中所有元素  -1是倒数第一个</span><br></pre></td></tr></table></figure><p><strong>rpush 和 rpop实现栈</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpush myList2 value1 value2 value3</span><br><span class="line">rpop myList2  # 将 list的头部(最右边)元素取出</span><br><span class="line">&quot;value3&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105165407904.png" alt="image-20211105165407904"></p><p><strong>Hash</strong></p><p>Hash 它的 value 是一个键值对。适用于存储对象，方便修改对象的某个属性值。</p><p><strong>应用场景</strong>：存储对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset userInfoKey name &quot;guide&quot; description &quot;dev&quot; age &quot;24&quot; </span><br><span class="line">OK </span><br><span class="line">127.0.0.1:6379&gt; hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存 在。 (integer) 1 </span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey name # 获取存储在哈希表中指定字段的值。 </span><br><span class="line">&quot;guide&quot; </span><br><span class="line">127.0.0.1:6379&gt; hget userInfoKey age </span><br><span class="line">&quot;24&quot; </span><br><span class="line">127.0.0.1:6379&gt; hgetall userInfoKey # 获取在哈希表中指定 key 的所有字段和值</span><br></pre></td></tr></table></figure><p>**Set **</p><p>set主要存取不重复的元素。还提供了<strong>取交集、并集、差集</strong>的操作。</p><p><strong>使用场景</strong>：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd mySet value1 value2 # 添加元素进去</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sadd mySet value1 # 不允许有重复元素</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers mySet # 查看 set 中所有的元素</span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard mySet # 查看 set 的⻓度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并</span><br><span class="line">存放在 mySet3 中</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>Sorted Set</strong></p><p>和 set 相比，sorted set 增加了⼀个权重参数 score，使得集合中的元素能够按 score 进行排序，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 的TreeSet 。</p><p><strong>适用场景</strong>：适用于排行榜这个场景，比如玩家游戏分数排行，微博热搜排行，最新评论按时间排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 # ⼀次添加多个元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zcard myZset # 查看 sorted set 中的元素数量</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zscore myZset value1 # 查看某个 value 的权重</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange myZset 0 -1 # 顺序输出某个范围区间的元素，0 -1 表示输出所有元</span><br><span class="line">素</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br><span class="line">3) &quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange myZset 0 1 # 顺序输出某个范围区间的元素，0 为 start 1 为</span><br><span class="line">stop</span><br><span class="line">1) &quot;value3&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure><p><strong>sorted set 的底层实现</strong></p><p>SortedSet底层使用到了<strong>skipList跳跃表</strong>这种数据结构</p><p>跳表是为了让链表的查找更快而诞生的一种数据结构，最底层链表包括全部的元素，在底层链表的基础上向上抽取出一些节点形成一个多层的链表，也叫做一级索引、二级索引，可以提高我们的查找效率。</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/151152187209308.jpg" alt="img"></p><p>当我们查找时，从最上层开始查找，如果发现当前值比目标值大就往下一层并往后搜索，平均的时间复杂度是O（logn）。</p><p>与红黑树相比，逻辑更加简单，实现和维护起来也更加方便。跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><h2 id="Redis为什么要给数据设置过期时间？"><a href="#Redis为什么要给数据设置过期时间？" class="headerlink" title="Redis为什么要给数据设置过期时间？"></a>Redis为什么要给数据设置过期时间？</h2><p><strong>如何设置过期时间</strong>？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set aa bb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire aa 60  # 设置过期时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl aa   # 查看过期时间</span><br><span class="line">(integer) 58</span><br><span class="line">127.0.0.1:6379&gt; persist aa  # 移除过期时间，设为永不过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex aa 100 bb  # set 和 expire 的合并操作</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><ul><li>内存有限，如果缓存中的所有数据都是一直保存的话，内存会不足</li><li>用于一些要求数据有时效性的场景，比如验证码功能，我们希望它只是在一段时间内有效</li></ul><p><strong>Redis如何判断数据是否过期呢？</strong></p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105182448638.png" alt="image-20211105182448638"></p><p>在内部有一个<strong>过期字典</strong>来判断这个键是否过期。过期字典存储的是每个键的过期时间，字典中 key 是 键， value 是过期时间的时间戳）</p><ol><li><strong>检查这个键是否在过期字典中，如果存在，那么取出这个键的过期时间</strong></li><li><strong>和当前 UNIX 时间戳比较，如果大于，则键过期。</strong></li></ol><h2 id="过期数据的删除策略是怎样的？（3种）"><a href="#过期数据的删除策略是怎样的？（3种）" class="headerlink" title="过期数据的删除策略是怎样的？（3种）"></a>过期数据的删除策略是怎样的？（3种）</h2><p>目前来说有三种删除策略：</p><ul><li><strong>定时删除：在设置键的过期时间时，创建一个定时器，当到达键过期时间时就会通过定时器去删除键</strong>。</li><li><strong>惰性删除：是每次获取键时，会判断是否过期，如果过期则删除</strong>。</li><li><strong>定期删除：每隔一段时间，就对数据库中的键进行检查，如果过期则删除。至于要删除多少什么时候删除，则是通过具体程序决定</strong>。</li></ul><p><strong>定时删除策略</strong></p><p> 优点是：对内存友好。因为通过定时器，当一个键到达过期时间时就会立马被删除，直接就释放了内存。<br> 缺点是：对 CPU 不友好。因为如果过期键比较多，那么删除这些过期键会占用相当一部分CPU时间，如果CPU时间非常紧张的话，还将CPU时间用在删除和当前任务无关的过期键上，会对服务器的响应时间以及吞吐量造成影响。</p><p><strong>惰性删除策略</strong></p><p>优点：对 CPU 时间友好。程序只会在取出键时才会判断是否删除，并且只作用到当前键上，其他过期键不会花费 CPU 时间去处理。<br>缺点：对内存不友好。因为只有键被使用时才会去检查是否删除，如果有大量的键一直不被使用，那么这些键就算过期了也不会被删除，会一直占用着内存。这种可以理解为是一种内存泄漏——大量无用的数据一直占用着内存，并且不会被删除。</p><p><strong>Redis实际使用的是惰性删除+定期删除的策略。</strong></p><p>通过这两种方式可以很好的<strong>利用CPU时间以及避免内存浪费</strong>的情况。</p><p>但是这样的删除策略还是有问题的，因为无论是惰性删除还是定期删除，都会发生漏掉过期 key 的情况。这样就导致大量过期 key 堆积在内存里，导致内存不足，这时候我们就需要用<strong>Redis内存淘汰机制</strong>。</p><h2 id="Redis内存淘汰机制（8种）"><a href="#Redis内存淘汰机制（8种）" class="headerlink" title="Redis内存淘汰机制（8种）"></a>Redis内存淘汰机制（8种）</h2><p><strong>当MySQL里有2000W数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</strong></p><p>答：redis内存数据集大小上升到一定大小的时候，就会施行<strong>数据淘汰策略。</strong></p><p>当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略。（4种volatile开头的，3种allkeys开头的，还有一种拒绝写入）</p><p>没有配置时，默认为no-eviction</p><ul><li><p>volatile-lru    从<strong>已设置过期时间</strong>的数据集中挑选<strong>最近最少使用</strong>的数据淘汰</p></li><li><p>volatile-lfu    从<strong>已设置过期时间</strong>的数据集中挑选<strong>最不经常使用</strong>的数据淘汰</p></li><li><p>volatile-ttl    从<strong>已设置过期时间</strong>的数据集中挑选<strong>将要过期</strong>的数据淘汰</p></li><li><p>volatile-random    从<strong>已设置过期时间</strong>的数据集中挑选<strong>任意</strong>数据淘汰</p></li><li><p>allkeys-lru    从所有key中淘汰<strong>最近最少</strong>使用的Key（最常用的）</p></li><li><p>allkeys-lfu    从所有key中淘汰<strong>最不经常使用</strong>的Key</p></li><li><p>allkeys-random    从所有key中<strong>随机</strong>选择key淘汰</p></li><li><p>no-eviction    当内存不足以写入新数据时，新写入操作会报错</p></li></ul><p>volatile为前缀的策略都是从 <strong>已设置过期的数据集</strong> 中进行淘汰。<br>allkeys为前缀的策略都是 <strong>面向所有key</strong> 进行淘汰。<br>LRU（least recently used）最近最少用到的。<br>LFU（Least Frequently Used）最不常用的。<br>它们的触发条件都是Redis使用的内存达到阈值时。</p><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><p>持久化就是把<strong>内存的数据写到磁盘中</strong>，防止Redis服务器发生故障导致内存数据丢失。</p><p>Redis 的持久化机制有两种，第一种是<strong>RDB快照</strong>，第二种是 <strong>AOF 日志</strong>。</p><ul><li><p>RDB快照就是将<strong>内存中的数据</strong>以快照的方式写入到二进制文件中，并保存到磁盘。</p></li><li><p>AOF日志就是将<strong>每个操作指令</strong>以日志的方式记录到文件中，并保存到磁盘。</p></li></ul><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><p><code>RDB</code>是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个<code>dump.rdb</code>文件。Redis 重启会加载<code>dump.rdb</code>文件恢复数据。</p><img src="/images/Redis%E7%9B%B8%E5%85%B3/rdb%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="img" style="zoom:80%;" /><p><strong>RDB执行流程</strong></p><ul><li><p>执行<code>BGSAVE</code>命令 ，Redis 父进程判断当前<strong>是否子进程正在执行持久化任务</strong>，如果存在，<code>BGSAVE</code>命令直接返回。 </p></li><li><p>父进程执行<code>fork</code>操作<strong>创建子进程</strong>，fork操作过程中父进程会阻塞。 （仅仅只创建子进程的这个过程，不影响后续操作）</p></li><li><p>父进程<code>fork</code>完成后，<strong>父进程继续接收并处理客户端的请求</strong>，而<strong>子进程开始将内存中的数据写进硬盘的临时文件</strong>； </p></li><li><p>当子进程写完所有数据后会<strong>用该临时文件替换旧的 RDB 文件</strong>。</p></li></ul><p><strong>触发机制</strong></p><p>RDB持久化触发机制分为：<strong>手动触发</strong>和<strong>自动触发</strong> </p><p><strong>手动触发</strong></p><p>用户执行<code>SAVE</code>或<code>BGSAVE</code>命令。</p><p><code>SAVE</code>命令的执行过程会阻塞所有客户端的请求，我们一般不采用这种方式。</p><p><code>BGSAVE</code>命令可以在后台异步操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用<code>BGSAVE</code>命令。</p><p><strong>自动触发</strong></p><p>有以下情况会自动触发RDB快照：</p><ul><li>我们可以在redis.conf这个配置文件中配置，比如SAVE 100 10，100秒内至少有10个键被修改则进行快照。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作</span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br><span class="line"># 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、</span><br><span class="line"># 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave</span><br></pre></td></tr></table></figure><ul><li><p>执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，那么会自动执行一次bgsave</p></li><li><p>主从同步的时候，如果从节点执行复制操作，主节点会自动执行BGSAVE生成 RDB 文件并发送给从节点。</p></li></ul><p><strong>RDB的优缺点</strong></p><p><strong>优点</strong></p><ul><li>Redis加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的是内存数据，而AOF文件中存储的是一条条命令，需要重演命令。</li><li>使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，<strong>保证了 Redis 的高性能</strong>。</li></ul><p><strong>缺点</strong></p><ul><li>RDB<strong>无法做到实时持久化</strong>，若在两次bgsave持久化操作间宕机，则会丢失增量数据，不适用于实时性要求较高的场景</li><li>bgsave命令每次都要执行fork操作创建子进程，fork子进程属于重量级操作，并且会阻塞redis主进程</li><li>RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，<strong>存在老版本 Redis 无法兼容新版 RDB 格式的问题</strong>。</li></ul><h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>AOF日志就是以日志的方式将<strong>每个操作指令</strong>记录到文件中，并保存到磁盘。Redis 重启后会根据日志文件的内容重新执行这些指令。与RDB快照的方式相比，AOF<strong>解决了数据持久化的实时性</strong>，AOF 是Redis持久化的主流方式。</p><p><strong>默认情况下Redis没有开启AOF方式的持久化</strong>，可以通过<code>appendonly</code>参数启用：<code>appendonly yes</code></p><p><strong>AOF执行流程：</strong></p><ul><li><p>AOF并不会每次都把命令直接写入文件中，因为这样会导致磁盘IO负担加重，它会首先将写入命令会追加到 AOP 缓冲区中。 </p></li><li><p>AOF 缓冲区到达一定容量后会根据<strong>对应的策略</strong>向硬盘同步。 （这里有三种策略将缓存区中的命令同步到硬盘中）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always  &#x2F;&#x2F;每次发生数据变更会被立即记录到磁盘，数据完整性好但性能差，不建议配置</span><br><span class="line">appendfsync everysec  &#x2F;&#x2F;每秒同步一次，这样最多丢失1s的记录，建议配置</span><br><span class="line">appendfsync no   &#x2F;&#x2F;Redis不直接调用文件同步，而是让操作系统来决定何时同步磁盘</span><br></pre></td></tr></table></figure><ul><li>当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。</li></ul><p><strong>AOF日志重写机制：</strong></p><p>随着 AOF 文件保存的数据越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。</p><p>Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的AOF文件。</p><p><strong>AOF的优缺点</strong></p><p><strong>优点：</strong></p><ul><li>AOF可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次<code>fsync</code>操作，如果Redis进程挂掉，最多丢失1秒的数据。</li></ul><p><strong>缺点：</strong></p><ul><li>AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。</li><li>数据恢复与RDB相比要慢。</li></ul><h2 id="RDB和AOF如何选择？"><a href="#RDB和AOF如何选择？" class="headerlink" title="RDB和AOF如何选择？"></a>RDB和AOF如何选择？</h2><p>通常来说，应该<strong>同时使用两种持久化方案，以保证数据安全。</strong></p><ul><li>如果数据不敏感，且可以从其他地方重新生成，可以关闭持久化。 </li><li>如果数据比较重要，且能够承受几分钟的数据丢失，比如缓存等，只需要使用RDB即可。 </li><li>如果是用做内存数据，要使用Redis的持久化，建议是RDB和AOF都开启。 </li><li>如果只用AOF，优先使用everysec的配置选择，因为它在可靠性和性能之间取了一个平衡。 </li></ul><p><strong>当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。</strong></p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="Redis-事务介绍"><a href="#Redis-事务介绍" class="headerlink" title="Redis 事务介绍"></a>Redis 事务介绍</h3><p>1）Redis 的事务是通过 <strong>MULTI，EXEC，DISCARD 和 WATCH</strong> 这四个命令来完成的。</p><p>2）Redis 的单个命令都是<strong>原子性</strong>的，所以这里确保事务性的对象是<strong>命令集合</strong>。</p><p>3）<strong>Redis不支持回滚操作，因此Redis事务不满足原子性</strong></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p>使用MULT命令后开启事务可以输入多个命令。Redis不会立即执行这些命令，而是将这些命令放入队列中，当调用了EXEC命令将执行所有命令，使用discard命令会清楚掉队列中的命令。</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-6c4bb09d4f8596d3e6c8ab86d35a721d_1440w.jpg" alt="img"></p><p>1）MULTI：用于标记事务块的开始。Redis 会将后续的命令逐个放入队列中，然后使用 EXEC 命令原子化地执行这个命令序列。</p><blockquote><p>127.0.0.1:6379&gt; multi # 开启事务<br>OK<br>127.0.0.1:6379&gt; set k1 alan # 设置 k1<br>QUEUED # k1 加入队列<br>127.0.0.1:6379&gt; set k2 tom # 设置 k2<br>QUEUED # k2 加入队列</p></blockquote><p>2）EXEC：在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。</p><blockquote><p>127.0.0.1:6379&gt; exec<br>\1) OK<br>\2) OK</p></blockquote><p>使用 EXEC 命令原子化地执行这个命令序列，刚刚我们设置了 k1 和 k2 两条命令，执行EXEC 命令后，给我们反馈了两个 OK，说明上述两条命令全部执行成功。</p><p>3）DISCARD：清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。</p><blockquote><p>127.0.0.1:6379&gt; multi<br>OK<br>127.0.0.1:6379&gt; set k3 lucy<br>QUEUED<br>127.0.0.1:6379&gt; set k4 jack<br>QUEUED<br>127.0.0.1:6379&gt; discard<br>OK</p></blockquote><p>4）WATCH：可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行EXEC命令之后，就会自动取消监控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name 2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set gender 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get gender</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>比如上面的代码中：</p><ol><li><code>watch name</code>开启了对<code>name</code>这个<code>key</code>的监控 </li><li>修改<code>name</code>的值 </li><li>开启事务a </li><li>在事务a中设置了<code>name</code>和<code>gender</code>的值 </li><li>使用<code>EXEC</code>命令进提交事务 </li><li>使用命令<code>get gender</code>发现不存在，即事务a没有执行 </li></ol><p>5）UNWATCH：可以取消WATCH命令对key的监控，所有监控锁将会被取消。</p><h3 id="事务失败处理（两种错误处理）"><a href="#事务失败处理（两种错误处理）" class="headerlink" title="事务失败处理（两种错误处理）"></a>事务失败处理（两种错误处理）</h3><p><strong>1）Redis 格式错误（语法错误）</strong> ：那么事务中的命令都会被回滚</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-3dc3673aa2e049602c211ab8d6df666b_1440w.jpg" alt="img"></p><p>在一个事务中，当命令出现错误时，后续命令正确依旧是可以添加到命令队列中去得，但是使用 EXEC 命令执行命令队列的时候，就会报错，并且队列中正确的命令也不会被执行。</p><p><strong>2）Redis 格式正确，类型错误</strong>  ：除了错误的那一句，其他的命令都会正常执行，不满足回滚操作</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/v2-341eb047ef02f8013c4a5b33aacbb9aa_1440w.jpg" alt="img"></p><p>这种错误不是命令错误，而是因为对命令理解不透彻出现的使用错误，在执行过程中会报错，因为 username1 不是 list 类型，它只是一个 string 类型。有一点需要注意，从结果可以看出，第一条命令是执行成功了的，所有我们使用”get username1”命令，返回了”alan”结果，<strong>这也证明了 Redis 是不支持事务回滚的</strong>。</p><p><strong>3）为什么 Redis 不支持事务回滚？</strong></p><p>（1）Redis为了性能更好就是忽略了事务回滚</p><p>（2）大多数事务失败是因为<strong>语法错误或者类型错误</strong>，这两种错误，应该在开发阶段就应该被发现而不是在生产过          程中。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>缓存穿透：</strong>用户发起大量请求，发现缓存中没有，并且数据库中也没有，也就是说没有经过缓存这一层，导致数据库压力过大。</p><p><strong>获取缓存的流程：</strong></p><p>前台请求数据，后台先从缓存中取数据，如果缓存中有直接返回结果，如果没有就从数据库中取，数据库取到后会更新缓存，并返回结果，如果数据库也没取到，那直接返回空结果。</p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211105205040220.png" alt="image-20211105205040220" style="zoom:67%;" /><p><strong>解决方案：</strong></p><p><strong>首先对请求做参数校验，</strong>如果参数不合法直接拒绝该请求：比如用户id不能小于0，邮箱格式不对等等。</p><p>1.<strong>缓存无效的key</strong>（适用于解决大量请求的key变化不频繁的情况）</p><p>如果缓存和数据库都查不到某个key的数据，就主动把这个key写入到 Redis中去并设置过期时间，这种方式可以解决请求的key变化不频繁的情况。如果每次是不同请求的key，会导致 Redis中缓存大量无效的key，就不可行了。</p><p>2.<strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，底层是一个二进制的位数组，通过它我们可以非常方便地<strong>判断一个给定数据是否存在于海量数据中</strong>。我们需要的就是判断请求的key是否合法。</p><p>具体是这样做的：把所有<strong>可能存在的请求的值都存放在布隆过滤器</strong>中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接过滤掉就不会去查找缓存中的数据；存在的话才会走下面的流程。这样就减轻了数据库的压力。</p><p>使用布隆过滤器可能会漏掉少部分不合法的请求，有一定的误判概率</p><p><strong>布隆过滤器原理：</strong></p><p>当一个元素加入布隆过滤器时：</p><p>1.使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</p><p>2.根据得到的哈希值，在<strong>位数组</strong>中把对应下标的值标为1。</p><p>我们再来看一下，当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作</p><p>1.对给定元素进行相同的哈希计算；<br>2.得到值之后判断位数组中的每个元素是否都为1，如果值都为1，那么说明这个值在布隆过滤器中，如果存在一个值不为1，说明该元素不在布隆过滤器中。</p><p>但是存在这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong>那么有的不合法的请求也会被判断为合法的，</p><p><strong>解决方法</strong>：可以适当增加<strong>位数组的大小</strong>或者<strong>调整我们的哈希函数</strong>来降低概率</p><p>缺点：不能删除里面的元素，因为不同的元素有些位置是相同的，我们删除其中某一位时，可能把其他元素也删除了。</p><p>在布隆过滤器中引用了一个<strong>误判率</strong>的概念，即它可能会把不属于这个集合的元素认为可能属于这个集合，但是不会把属于这个集合的认为不属于这个集合，布隆过滤器的特点如下：</p><ol><li>一个非常大<strong>的二进制的位数组</strong> （数组里只有0和1）</li><li>若干个<strong>哈希函数</strong></li><li><strong>空间效率</strong>和<strong>查询效率高</strong></li><li>不存在<strong>漏报</strong>（False Negative）：某个元素在某个集合中，肯定能报出来。</li><li>可能存在<strong>误报</strong>（False Positive）：某个元素不在某个集合中，可能也被爆出来。</li><li>不提供删除方法，代码维护困难。</li><li>位数组初始化都为0，它不存元素的具体值，当元素经过哈希函数哈希后的值（也就是数组下标）对应的数组位置值改为1。</li></ol><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211108111923205.png" alt="image-20211108111923205"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>缓存雪崩</strong>：我们对缓存设置了相同的过期时间，导致缓存在同一时刻大面积失效，请求在短时间内全部落到了数据库上，可能导致数据库崩溃</p><p><strong>举个例子</strong>：秒杀开始12个小时之前，我们统一存放了一批商品到 Redis中，设置的缓存过期时间也是12个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><p><strong>解决方案：</strong></p><p>1.我们可以设置不同的缓存失效时间，比如我们可以在原有的缓存时间基础上增加一个随机值，这样每一个缓存的过期时间就会错开。</p><p>2.缓存预热，在数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中</p><p>3.对Redis服务的话，我们可以采用Redis集群的方式让Redis高可用，处理更多请求</p><p>4.或者消息队列限流避免同时处理大量的请求。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>缓存击穿</strong>是指一个<code>key</code>非常热点，大量请求集中对这一个key进行访问，当<strong>这个key在失效的瞬间</strong>，大量持续的请求就击穿缓存，直接请求数据库，数据库的访问压力瞬间增大。有点像袋子里面装着水，袋子破了一个洞，大量的水从洞中漏出。</p><p>缓存击穿和缓存雪崩还是有点类似的，不过击穿是一个key失效，雪崩是大量key同时失效</p><p>造成缓存击穿的原因有以下两个：</p><ol><li>该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）</li><li>添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）</li></ol><p>解决方案：</p><p>1.加锁，在并发的多个请求中，只有第一个请求线程能拿到锁并执行数据库查询操作，其他的线程拿不到锁就阻塞等着，等到第一个线程将数据写入缓存后，直接走缓存。</p><p>2.设置这个热点数据永不失效，当然这种情况需要考虑更新缓存。</p><h2 id="Redis高可用（未完成）"><a href="#Redis高可用（未完成）" class="headerlink" title="Redis高可用（未完成）"></a>Redis高可用（未完成）</h2><p>高可用通常是指，<strong>通过设计减少系统不能提供服务的时间。</strong>（让系统尽可能处于可用的状态）</p><p>如果在实际生产中，如果redis只部署一个节点，当机器故障时，整个系统都不能提供服务了。这就是我们常说的单点故障。</p><p>如果redis部署了多台，当一台或几台故障时，整个系统依然可以对外提供服务，这样就提高了服务的可用性。</p><p>redis高可用的三种模式：<strong>主从模式，哨兵模式，集群模式。</strong></p><h3 id="Redis主从模式"><a href="#Redis主从模式" class="headerlink" title="Redis主从模式"></a>Redis主从模式</h3><p><strong>主从复制介绍：</strong></p><p>Redis为了保证系统的高可用，避免单点故障，一般需要部署多台机器。</p><p>因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。redis提供了Redis提供了主从复制的(replication)功能，当一台redis主数据库中的数据发生了变化，这个变化会被自动的同步到其他的redis从数据库中。</p><p>redis多机器部署时，这些机器节点会被分成两类，一类是主数据库（master），一类是从数据库（slave）。</p><p>主数据库可以进行读写操作，<strong>当主数据库的数据发生变化时会自动将数据同步到从数据库</strong>。从数据库一般是只读的，它会接收主数据库同步过来的数据。一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。也就是所谓的<strong>一主多从</strong>结构。<br><img src="/images/Redis%E7%9B%B8%E5%85%B3/format,png.png" alt="一主多从"></p><p><strong>主从复制过程：</strong>（没看懂）</p><p>1.当启动一个从节点时，它会发送一个 <code>PSYNC</code> 命令给主节点； </p><p>2.如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件； </p><p>3.同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后， 主节点会将<code>RDB</code>文件发送给从节点，从节点会先将<code>RDB</code>文件<strong>写入本地磁盘，然后再从本地磁盘加载到内存中</strong>； </p><p>4.接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据； </p><p>5.如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。</p><h3 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h3><p><strong>哨兵模式介绍：</strong></p><p>主从模式下要是发生了故障主节点宕机了，哨兵机制会自动选举主节点并将其他的从节点指向新的主节点。</p><p>客户端连接Redis的时候，先连接哨兵，哨兵会告诉客户端Redis主节点的地址，然后客户端连接上Redis并进行后续的操作。当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。</p><p><strong>哨兵模式过程：</strong></p><h3 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h3><p>哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是存在主节点的写能力、容量受限于单机配置的问题。而集群模式实现了Redis的分布式存储，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。</p><p>Redis cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p><strong>三种模式的特点：</strong></p><ul><li><strong>主从模式</strong> 可以实现读写分离，数据备份。但是并不是「高可用」的</li><li><strong>哨兵模式</strong> 可以看做是主从模式的「高可用」版本，其引入了Sentinel对整个Redis服务集群进行监控。但是由于只有一个主节点，因此仍然有写入瓶颈。</li><li><strong>Cluster模式</strong> 不仅提供了高可用的手段，同时数据是分片保存在各个节点中的，可以支持高并发的写入与读取。当然实现也是其中最复杂的。</li></ul><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><p>主要是解决了分布式缓存不均衡的问题</p><p>在单点架构中，如果一个服务器宕机了，整个系统就不可用了，所以我们一般使用的是多点的分布式架构。</p><p>当我们使用分布式架构的时候，希望<strong>每台服务器缓存的数据能够均衡一点</strong>，而一致性Hash算法就是解决这个问题。</p><p><strong>第一种方式</strong>：<strong>hash（图片名称）% N</strong></p><p>我们对图片名称hash，并对服务器数量取余，就可以随机分散在不同服务器上了</p><p><strong>缺点</strong>：如果我们服务器数量发生改变，那么所有缓存的位置都需要重新计算搬移。</p><p>因此，我们提出了一致性</p><p><strong>第二种方式</strong>：<strong>hash（服务器A的IP地址） %  2^32</strong></p><p>考虑一个圆环，上面有2^32个点，先将服务器经过hash计算后映射到圆环上。接着将图片用同样的方式映射到圆环上，存储到顺时针移动碰到的第一个服务器。</p><p>这时候，如果某一台服务器不可用了，将这台服务器存车处的数据再顺时针移动到下一台服务器即可。</p><p><strong>缺点</strong>：存在Hash环的偏斜，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211109113800911.png" alt="image-20211109113800911"></p><p><strong>第三种方式</strong>：设置虚拟节点，将原有的物理节点通过虚拟的方法复制出来，让服务器分布相对均匀些</p><p><img src="/images/Redis%E7%9B%B8%E5%85%B3/image-20211109113834444.png" alt="image-20211109113834444"></p><h2 id="Redis如何保证缓存和数据库的一致性"><a href="#Redis如何保证缓存和数据库的一致性" class="headerlink" title="Redis如何保证缓存和数据库的一致性"></a>Redis如何保证缓存和数据库的一致性</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录一点Redis相关面试题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>智力题</title>
    <link href="http://example.com/2021/10/30/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <id>http://example.com/2021/10/30/%E6%99%BA%E5%8A%9B%E9%A2%98/</id>
    <published>2021-10-30T01:52:52.000Z</published>
    <updated>2021-11-10T09:13:07.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录几个智力题</p></blockquote><a id="more"></a><h3 id="分石子问题"><a href="#分石子问题" class="headerlink" title="分石子问题"></a><strong>分石子问题</strong></h3><p>总共有30个石子，每次取1或者2块，先到30的就能赢，怎样才能赢？</p><p>30%（1+2）= 0   那么后拿的人一定赢，只要每次与先拿的人加起来的个数为3.</p><p>假如31个石子呢？</p><p>31%（1+2）= 1 那么先拿的人一定赢，先拿的第一次拿一个，就和上面的类似了。</p><h3 id="按灯泡问题"><a href="#按灯泡问题" class="headerlink" title="按灯泡问题"></a>按灯泡问题</h3><p>如果100个灯泡连成环，按下一个灯泡，它旁边两个灯泡的状态也会发生变化，问如何让100个灯泡全亮？</p><p><strong>步骤一：将灯泡变为全亮或只剩一个为暗</strong></p><p>从 1 循环到 98 ，遇到暗的则按它下一个，使之变亮。循环完毕，1 ~ 98 必然全亮。99 和 100可能为亮亮、暗亮、亮暗、暗暗四种状态。</p><ul><li>若为亮亮，皆大欢喜，满足题目要求</li><li>暗亮、亮暗，达到只剩一个为暗的状态；</li><li>若为暗暗。则按下编号 100 的灯泡，使编号 99 、100 变为亮，编号 1 的灯泡变为暗，从而达到只剩一个为暗的状态。</li></ul><p><strong>步骤二：将灯泡变为全暗</strong></p><p>由于灯泡环形摆放，我们指定暗的灯泡编号为 1 ，将剩下 99 个亮着的灯泡每 3 个为一组。按下每组中间的灯泡后，使得所有灯泡变为暗。</p><p><strong>步骤三：将灯泡变为全亮</strong></p><p>将所有灯泡按一下，灯泡变为全亮。（每个灯泡除了自己主动，还有旁边灯泡触发，即每个灯泡被按了3次，就会由全灭变成全亮）</p><h3 id="有100只狼和1只羊"><a href="#有100只狼和1只羊" class="headerlink" title="有100只狼和1只羊"></a>有100只狼和1只羊</h3><p><strong>规则：</strong></p><p>1、草原上有狼和羊，狼可以选择吃羊，也可以选择吃草，但会优先选择吃羊</p><p>2、一只狼只能吃一只羊，一只羊只会被一只狼吃掉</p><p>3、吃完羊的狼，自己会变成一只羊，可以被其他狼吃掉</p><p>4、狼比起吃羊，更害怕变成羊后被吃掉</p><p> <strong>问题：100只狼和1只羊在一起，这只羊会不会被吃掉？</strong></p><p> 思路：</p><p>如果1羊，1狼。那么狼必然会吃掉羊。 如果1羊，2狼。那么狼吃完羊后，就会被另外一只狼吃掉，因此两只狼都不敢吃羊。因此羊不会被吃。 如果1羊，3狼。那么狼吃完羊后，另外两只狼会面临上一种情况，不敢吃这个新生成的羊，因此原来的羊会被吃掉。 依次类推，<strong>如果是偶数只狼，那么羊不会被吃。如果是奇数只狼，那么羊会被吃掉</strong></p><h3 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a>倒水问题</h3><p>一个3L，一个5L，如何倒出4L水？</p><ul><li>倒满5L，倒进3L，5L中剩2L</li><li>3L倒掉，将5L中的2L倒进3L，此时3L中有2L，5L中没有</li><li>倒满5L，当3L满的时候，5L还剩4L</li></ul><h3 id="毒药问题"><a href="#毒药问题" class="headerlink" title="毒药问题"></a>毒药问题</h3><p>1000瓶药水里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在24小时后试出那瓶有毒？</p><p>答案：log2 1000 向上取整 ≈ 10只。</p><p>解析：<strong>二进制思想。</strong></p><p>老鼠表示二进制中每一位，二进制转化为10进制代表瓶子编号。</p><p>即老鼠表示二进制去对应10进制的瓶子编号</p><p><code>0 000 000 001</code>表示 1 号老鼠，喝了药水 1 。</p><p><code>0 000 000 010</code>表示 2 号老鼠，喝了药水 2 。</p><p><code>0 000 000 011</code>表示 1 号、 2 号老鼠，喝了药水 3 。</p><p>… …</p><p><code>1 111 101 000</code>表示 4、6、7、8、9、10号老鼠，喝了药水 1000。</p><p>按照上述的方法依次喝</p><p>第一回合，1 号老鼠喝药水 1</p><p>第二回合，2 号老鼠喝药水 2</p><p>…</p><p>第一千回合，4、6、7、8、9、10号老鼠喝药水 1000</p><p>喝完一天时，看 10 只老鼠的状态，根据老鼠状态就知道哪瓶药水有毒了。</p><p><strong>比如最后只是 2 号老鼠死了，那就说明第2瓶药水有毒；如果1、2号老师死了，说明第3瓶药水有毒。如果4、6、7、8、9、10死了，那就说明第1000瓶药水有毒！</strong></p><h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><h3 id="12个小球找一个重量不同的球"><a href="#12个小球找一个重量不同的球" class="headerlink" title="12个小球找一个重量不同的球"></a>12个小球找一个重量不同的球</h3><p>这个问题的思想是采用分治的思想</p><p>1.将12个小球分为三组（因为分成两组不能找到重量不一样的球在哪组），为A组、B组、C组<br>2.将三组球分别两两称重，找到重量和另外两组不同的那一组（只要有两组可以使天平平衡，重量不致的球必然在第三组）。假设坏的球在C组<br>3.将C组的球分成两组C1和C2，每组两个球，这时从A组和B组里找到两个正常的球，分别和C1和C2去称，天平不能平衡说明重量不一致的球就在哪组。假设在C14.将C1组的球分别和正常的球去称，天平不平衡时就能找到重量与其他不一致的球</p><h3 id="设计一个排行榜"><a href="#设计一个排行榜" class="headerlink" title="设计一个排行榜"></a>设计一个排行榜</h3><p>mysql</p><p>如果想要<strong>计算排第几名就找出他分数高的有几个，再加上自身个数就好了</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="number">1</span>)+<span class="number">1</span> <span class="keyword">as</span> <span class="string">&#x27;排名&#x27;</span></span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">test</span></span><br><span class="line">  <span class="keyword">WHERE</span> score&gt;(<span class="keyword">SELECT</span> score <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;李四&#x27;</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，该sql语句会进行全表的扫描，只适用于数据量不是很大的表</p><p>redis</p><p>用SortedSet，底层是一个跳表</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记录几个智力题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B8%85%E6%A5%9A%E7%9A%84%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE/"/>
    <id>http://example.com/2021/10/27/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E6%B8%85%E6%A5%9A%E7%9A%84%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE/</id>
    <published>2021-10-27T07:33:11.850Z</published>
    <updated>2021-11-10T02:00:09.317Z</updated>
    
    <content type="html"><![CDATA[<p> IO的方式一般分为几种，<strong>同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO</strong></p><p><strong>用户态和内核态</strong></p><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是<strong>特权级不同</strong>。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：<strong>系统调用，异常和中断。</strong></p><p><strong>用户态和内核态的切换</strong></p><p>当在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。</p><p>用户态切换到内核态的 3 种方式</p><p>（1）<strong>系统调用</strong></p><p>这是用户态进程<strong>主动要求</strong>切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。例如 fork（）就是执行了一个创建新进程的系统调用。系统调用的机制核心是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</p><p>（2）<strong>异常</strong></p><p>当 cpu 在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。</p><p>（3）<strong>外围设备的中断</strong></p><p>当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。</p><p>这三种方式是系统在运行时由用户态切换到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。从触发方式上看，切换方式都不一样，但从最终实际完成由用户态到内核态的切换操作来看，步骤又是一样的，都相当于执行了一个中断响应的过程。系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本一致。</p><p><strong>JVM：</strong></p><p><strong>java基础：</strong></p><p>concurrenthashmap  </p><p><strong>底层结构方面</strong></p><p>JDK1.7底层是Segment数组 + HashEntry数组+链表</p><p>JDK1.8底层是Node数组+链表+红黑树</p><p><strong>并发安全方面</strong></p><p>JDK1.7采用的是分段锁，锁的是一个个segment，segment 继承了 ReentrantLock。</p><p>JDK1.8采用的是CAS+synchronized，锁的是Node节点，只要没有发生哈希冲突，就不会产生锁的竞争。</p><p>所以JDK1.8相比于JDK1.7提供了一种粒度更小的锁，减少了锁的竞争，提高了concurrentHashMap的并发能力。</p><p><strong>mysql：</strong></p><p><strong>java并发：</strong></p><p>两个线程交替打印奇数和偶数：</p><p>采用synchronized + wait + notify</p><p>在一个循环中，先打印，再唤醒另一个线程，再wait当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Process</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">               <span class="keyword">while</span>(num &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印&quot;</span> + num++);</span><br><span class="line">                   lock.notify();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       lock.wait();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintThread thread = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>threadlocal有了解吗？</p><p><strong>框架相关</strong>：</p><p><strong>算法：</strong></p><p>查找数组中第k大的数（快排思想，每次求得一个）</p><p>另一棵树的子树</p><p>递归实现冒泡排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; IO的方式一般分为几种，&lt;strong&gt;同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户态和内核态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户态和内核态是操作系统的两种运行级别，两者最大的区别就是&lt;strong&gt;特权</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/26/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E4%B8%80%E9%9D%A2/"/>
    <id>http://example.com/2021/10/26/%E4%BA%AC%E4%B8%9C%E9%9B%B6%E5%94%AE%E4%B8%80%E9%9D%A2/</id>
    <published>2021-10-26T09:07:41.735Z</published>
    <updated>2021-11-01T04:00:41.461Z</updated>
    
    <content type="html"><![CDATA[<p>京东零售java后台开发一面     1h   10月26日16:00~17:00</p><ol><li>自我介绍</li><li>java基本数据类型（8种）</li><li>String是基本数据类型吗？</li><li>介绍一下final（变量、方法、类）</li><li><strong>输入3X0.1，返回的是什么类型（不会。。）</strong></li><li>instanceof有什么作用？</li><li>枚举类中的两个对象作比较，用equals还是== ？（不是很懂，）</li><li><strong>java中创建对象有几种方式？（new、反射（两种）、clone方法、反序列化）</strong></li><li><strong>介绍一下java的异常体系</strong></li><li><strong>自定义异常如何实现？继承Exception和继承RuntimeException有什么区别？</strong></li><li>对java集合类的理解</li><li>HashMap数组下标如何计算？（三步）</li><li>为什么不直接用Object的HashCode方法，还要右移和取模？</li><li>解决哈希冲突有哪些方法？HashMap中如何解决哈希冲突？（答了拉链法和开放定址法）</li><li>为什么HashMap选择拉链法而不选择开放定址法？</li><li>对HashMap的key有什么要求吗？（我答的通常使用不变的对象作为key）</li><li>java中实现多线程的方法（4种，面试官说线程池不算一种方法）</li><li>线程池怎么创建？（不是很熟悉，）</li><li>有三个线程ABC按顺序执行。比如说A-》B-》C（面试官提到用join方法）</li><li>线程通信和调度方法有哪些？</li><li>wait和sleep方法的区别？</li><li>线程有哪些状态？（我答的6个）</li><li>调用wait和sleep是进入哪个状态？</li><li>MySQL的索引作用？</li><li>主键索引是唯一索引吗？</li><li><strong>我们怎么创建索引？（创建表时加索引，创建完表后再加索引语句create index index_name on student(字段名)）</strong></li><li><strong>怎么知道索引是否创建成功（当时忘了，使用explain）</strong></li><li>数据库事务的四大特性</li><li>谈谈你对隔离性的理解</li><li>谈谈脏读、不可重复读、幻读的区别</li><li>说一下Spring的IOC和AOP</li><li>Spring里面注入的几种方式（）通过成员变量和构造器注入</li><li>@Autowired（有了解过在构造器上用@Autowired吗？）</li><li>Mybatis里面有哪些常用标签？</li><li>MySQL的联合查询如何实现？</li><li>知道Union和UnionAll有什么区别？（将两个表查询的结果集合并在一起）</li><li>去重的标准是什么？</li><li>MyBatis的的$和#有什么区别？</li><li>估计你的实习周期有多长？</li><li>反问</li></ol><p>把一些语气词去掉，不要显得自己不是很确认的样子。。</p><p>比如说 吧，应该是这样的，大概，就按照自己的理解去说就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;京东零售java后台开发一面     1h   10月26日16:00~17:00&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;java基本数据类型（8种）&lt;/li&gt;
&lt;li&gt;String是基本数据类型吗？&lt;/li&gt;
&lt;li&gt;介绍一下final（变量、方法、类）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/25/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/"/>
    <id>http://example.com/2021/10/25/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2/</id>
    <published>2021-10-25T08:54:32.276Z</published>
    <updated>2021-10-31T14:40:39.803Z</updated>
    
    <content type="html"><![CDATA[<p>小米java后台开发一面  1h   10月25日15:30~16:30</p><p>结果：一面挂（其实我感觉答的还可以。。除了最后的算法题没完全写对，我也不晓得为啥会挂）</p><ol><li>自我介绍</li><li>介绍一下面向对象的特点（封装、继承、多态）</li><li>Object类的常用方法（只知道hashcode equals hashCode）</li></ol><p>getClass、clone、hashCode equals finalize wait notify notifyall toString </p><ol><li><p>String对象为什么不可变（不清楚，只回答了源码用final修饰）</p></li><li><p>equals方法和hashCode方法</p></li><li><p>有重写过equals方法吗？重写了equals方法一定要重写hashCode方法吗？</p></li><li><p>讲一下java接口</p></li><li><p>讲一下java集合中的Collection和Map两个接口（要按照什么样的思路来讲的话比较好呢？讲List、Set、Queue这三个子接口。我是先介绍特点再介绍下面的子接口或者子类</p></li><li><p>讲ArrayList和LinkedList（先从宏观上讲一遍，也就是那三个区别，再从底层讲一下）</p><p>ArrayList 的底层存储、构造函数、扩容过程。LinkedList底层</p></li><li><p>java中创建多线程的方法（4种，可以详细 讲一讲每种是怎么创建的。用线程池创建线程的方法、自定义的忘了怎么说了）</p></li><li><p>有哪些方法可以解决多线程并发安全问题？（我答的synchronized、volatile、锁机制、JUC包下的原子操作类和一些线程安全的并发集合类）</p></li><li><p>介绍一下ReentrantLock和synchronized的区别（中断方式没讲明白、）</p></li><li><p><strong>介绍一下ReentrantLock的底层实现</strong></p></li><li><p><strong>AQS讲一下</strong></p></li><li><p>线程池的参数</p></li><li><p>MySQL引擎介绍一下</p></li><li><p>MySQl引擎的数据结构（B+树）</p></li><li><p>还有哪些数据结构，为什么不用这些数据结构（<strong>为什么不用哈希表</strong>，而用B+树）</p></li><li><p>MySQL的事务隔离</p></li><li><p>MySQL的默认级别是可重复读，但为什么可以解决幻读问题？（MVCC+临键锁）</p></li><li><p><strong>讲一下临键锁</strong></p></li><li><p>意向锁（流程讲一下）</p></li><li><p>JVM的内存结构（讲一下流程和5个区域的作用）</p></li><li><p><strong>讲一下OOM，什么情况下会发生OOM</strong></p></li><li><p>讲一下Spring（这个框架有什么用，核心思想IOC和AOP，先答解耦，再详细答每个思想）</p></li><li><p><strong>Spring事务</strong>（不会）</p></li><li><p>算法题–反转链表Ⅱ</p></li><li><p>反问（1.面试哪些地方不足   2.面试官介绍部门是做什么的，说是小米商城的交易中台服务）</p></li></ol><p>总结：口头禅太多，知识点大概都答上来了，但是总结的有点凌乱。</p><p><strong>有这些口头禅</strong>：就是 、额 、可能、如果。。。的话、然后还有一个、好像</p><p><strong>解决方法</strong>：</p><p>额-》回答问题使先思考一会儿再答，不用着急</p><p>xxx就是-》xxx，他的意思是  或者   xxx的意思是</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小米java后台开发一面  1h   10月25日15:30~16:30&lt;/p&gt;
&lt;p&gt;结果：一面挂（其实我感觉答的还可以。。除了最后的算法题没完全写对，我也不晓得为啥会挂）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;介绍一下面向对象的特点（封装、继承、多态）&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/25/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/25/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-25T04:11:13.609Z</published>
    <updated>2021-11-03T10:21:48.935Z</updated>
    
    <content type="html"><![CDATA[<p>面试官，您好！我叫彭博。来自北京邮电大学，我的专业是信息工程 ，目前大四，专业排名10%，保研到本校计算机学院，想要应聘贵公司java开发实习生的岗位。</p><p>在校期间，我学习了   Java、    MySQL   、数据结构算法等必备知识，在技能方面还是符合这个岗位的。我也参加过一些比赛并取得一定的成绩，像美国大学生数学建模竞赛等，让我明白了团结和分工的重要性，在获奖的同时也锻炼了自己的实践能力。像平时我也会写一些博客整理记录下自己所学的知识。</p><p>通过自身的努力，我也获得了很多次的奖学金，担任过大班体育委员、团支书等职务，这也让我认识到付出就有收获，对我将来的工作也有很大的激励作用。在生活上我是一个比较积极乐观的人，一般会通过运动唱歌的的方式来放松自己。如果有幸能够进入到贵公司，   <strong>在工作中我也会积极主动地迎难而上，认真地完成每一项任务。</strong>以上就是我的自我介绍，面试官好，我介绍完了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试官，您好！我叫彭博。来自北京邮电大学，我的专业是信息工程 ，目前大四，专业排名10%，保研到本校计算机学院，想要应聘贵公司java开发实习生的岗位。&lt;/p&gt;
&lt;p&gt;在校期间，我学习了   Java、    MySQL   、数据结构算法等必备知识，在技能方面还是符合这个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git、Maven、postman的理解</title>
    <link href="http://example.com/2021/10/24/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/24/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-24T12:49:40.000Z</published>
    <updated>2021-10-24T13:14:51.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>几个开发中常用工具的使用</p></blockquote><a id="more"></a><h2 id="git简要介绍"><a href="#git简要介绍" class="headerlink" title="git简要介绍"></a>git简要介绍</h2><p>Git官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>Git图标：<img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/Git%E5%9B%BE%E6%A0%87.jpeg" alt="Git图标" style="zoom:80%;" /></p><p>Git 是一个<strong>开源的分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git版本控制</p><ul><li>个人操作</li><li>团队协作：记录每次修改的情况。</li></ul><p><strong>什么是版本控制呢？</strong></p><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3-1610510235263.jpg" alt="版本迭代" style="zoom:50%;" /><h2 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h2><p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/%E6%B5%81%E7%A8%8B.png" alt="git工作流程"></p><p>名词解释：</p><ul><li>workspace：工作区</li><li>staging area：暂存区/缓存区</li><li>local repository：或本地仓库</li><li>remote repository：远程仓库</li></ul><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><h3 id="提交版本"><a href="#提交版本" class="headerlink" title="提交版本"></a>提交版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;Adding files&quot;</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone</span><br></pre></td></tr></table></figure><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">注：一个^表示后退一步，n 个表示后退 n 步</span><br></pre></td></tr></table></figure><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>一般我们在pom.xml文件中导入jar包的，只要我们确定maven坐标，就可以从远程残酷</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/Git%E3%80%81Maven%E3%80%81postman%E7%9A%84%E7%90%86%E8%A7%A3/915951-20161205142602226-1306419231.png" alt="maven仓库"></p><p><strong>本地仓库</strong>是指存在于我们本机的仓库，在我们加入依赖时候，首先会跑到我们的本地仓库去找，如果找不到则会跑到远程仓库中去找。</p><p><strong>远程仓库</strong>是指其他服务器上的仓库，包括全球中央仓库，公司内部的私服，又或者其他公司提供的公共库。</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>而Postman就是一个能够产生各种类型http请求的工具，并能设置请求的参数。</p><p>比如我们能发送我们常用的Post请求和Get请求。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;几个开发中常用工具的使用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql基础知识</title>
    <link href="http://example.com/2021/10/23/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/10/23/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-10-23T09:53:17.000Z</published>
    <updated>2021-11-11T03:47:35.661Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记一下常见的MySQL语句</p></blockquote><a id="more"></a><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160254539-1309074983.png" alt="img"></p><p>语法格式：</p><p>select 字段 from 表名 where 条件 group by 分组字段 having 分组条件 order by 排序字段 排序规则 limit 分页参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表  from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><h3 id="创建数据库（Create）"><a href="#创建数据库（Create）" class="headerlink" title="创建数据库（Create）"></a>创建数据库（Create）</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database db_name;  -- 创建数据库</span><br><span class="line">mysql&gt; show databases;           -- 显示所有的数据库</span><br><span class="line">mysql&gt; drop database db_name;    -- 删除数据库</span><br><span class="line">mysql&gt; use db_name;              -- 选择数据库</span><br><span class="line">mysql&gt; create table tb_name (字段名 varchar(20), 字段名 char(1));   -- 创建数据表模板</span><br><span class="line">mysql&gt; show tables;              -- 显示数据表</span><br><span class="line">mysql&gt; desc tb_name；            -- 显示表结构</span><br><span class="line">mysql&gt; drop table tb_name；      -- 删除表</span><br></pre></td></tr></table></figure><p>​    例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建学生表*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(</span><br><span class="line">     Sno <span class="built_in">char</span>(<span class="number">10</span>) primary <span class="keyword">key</span>,</span><br><span class="line">     Sname <span class="built_in">char</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">     Ssex <span class="built_in">char</span>(<span class="number">2</span>),</span><br><span class="line">     Sage <span class="built_in">smallint</span>,</span><br><span class="line">     Sdept <span class="built_in">char</span>(<span class="number">20</span>)</span><br><span class="line">)；</span><br></pre></td></tr></table></figure><h3 id="插入数据（Insert）"><a href="#插入数据（Insert）" class="headerlink" title="插入数据（Insert）"></a>插入数据（Insert）</h3><p> insert into 表名 values （值1，值2）语句用于向表格中插入新的行：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：*/</span></span><br><span class="line">mysql&gt; insert into tb_name values (value1,value2,value3,...);</span><br><span class="line"><span class="comment">/*第二种形式需要指定列名及被插入的值：*/</span></span><br><span class="line">mysql&gt; insert into tb_name (column1,column2,column3,...) values (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>​     例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*插入数据*&#x2F;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student values ( 20180001,张三,男,20,CS）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student values ( 20180002,李四,男,19,CS）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180003,王五,男,18,MA）;</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into Student (Sno,Sname,Ssex,Sage,Sdept) values ( 20180004,赵六,男,20,IS）;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>update 表名 set 字段1=值1，字段值2=值2，where 条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 将id为2的age改为22，sex改为男</span><br><span class="line">update stu set age&#x3D;22,sex&#x3D;&#39;男&#39; where id&#x3D;2;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>delete from 表名 [where 条件]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 删除stu表中id值为11的数据</span><br><span class="line">delete from stu where id&#x3D;11;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值为12到17的数据</span><br><span class="line">delete from stu where id between 12 and 17;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值大于10的数据</span><br><span class="line">delete from stu where id&gt;10;</span><br></pre></td></tr></table></figure><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表  from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><h3 id="where-查询"><a href="#where-查询" class="headerlink" title="where 查询"></a><strong>where 查询</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 查询stu表中 age &gt; 22的数据</span><br><span class="line">select * from stu where age&gt;22;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 name&#x3D;某个条件值 的数据</span><br><span class="line">select * from stu where name&#x3D;&#39;yyx&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的数据</span><br><span class="line">select * from stu where age between 22 and 25;</span><br><span class="line">select * from stu where age &gt;&#x3D; 22 and age&lt;&#x3D; 25;</span><br><span class="line">-- 查询 stu 表中 年龄不在22到25之间的数据</span><br><span class="line">select * from stu where age not between 22 and 25;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的女生信息</span><br><span class="line">select * from stu where age between 22 and 25 and sex&#x3D;&#39;女&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 users 表中 年龄为22或者25 的女生信息，必须要加小括号，因为and的优先级高于or</span><br><span class="line">select * from users where (age&#x3D;22 or age &#x3D; 25) and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><h3 id="like查询"><a href="#like查询" class="headerlink" title="like查询"></a>like查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- like 语句  like某个确定的值 和。where name &#x3D; &#39;王五&#39; 是一样</span><br><span class="line">select * from stu where name like &#39;yyx&#39;;</span><br><span class="line"></span><br><span class="line">-- % 代表任意个字符  _ 代表单个字符</span><br><span class="line"></span><br><span class="line">-- 使用 % 模糊搜索。%代表任意个任意字符</span><br><span class="line">    -- 查询name字段中包含x的</span><br><span class="line">    select * from stu where name like &#39;%x%&#39;;</span><br><span class="line">    -- 查询name字段中最后一个字符 为 u的</span><br><span class="line">    select * from stu where name like &#39;%u&#39;;</span><br><span class="line">    -- 查询name字段中第一个字符 为 q 的</span><br><span class="line">    select * from stu where name like &#39;q%&#39;;</span><br><span class="line">-- 使用 _ 单个的下划线。表示一个任意字符，使用和%类似</span><br><span class="line">    -- 查询表中 name 字段为两个字符的数据</span><br><span class="line">    select * from users where name like &#39;__&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 name 字段最后为j，的两个字符的数据</span><br><span class="line">select * from users where name like &#39;_j&#39;;</span><br></pre></td></tr></table></figure><h3 id="Mysql中的统计函数（聚合函数）"><a href="#Mysql中的统计函数（聚合函数）" class="headerlink" title="Mysql中的统计函数（聚合函数）"></a>Mysql中的统计函数（聚合函数）</h3><p>可以使用like语句进行某个字段的模糊搜索，</p><p>例如： 查询 name字段中包含五的数据</p><p><strong>count(),max(),min(),sum(),avg()</strong></p><h3 id="count统计数量"><a href="#count统计数量" class="headerlink" title="count统计数量"></a>count统计数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 计算 users 表中 最大年龄，最小年龄，年龄和及平均年龄</span><br><span class="line">select max(age),min(age),sum(age),avg(age) from stu;</span><br><span class="line">-- 上面数据中的列都是在查询时使用的函数名，不方便阅读和后期的调用，可以通过别名方式 美化</span><br><span class="line">select max(age) as max_age,min(age) as min_age,</span><br><span class="line">sum(age) as sum_age,avg(age) as avg_age from stu;</span><br><span class="line">-- 统计 stu 表中的数据量</span><br><span class="line">select count(*) from stu;</span><br><span class="line">select count(id) from stu;</span><br><span class="line">-- 上面的两个统计，分别使用了 count(*) 和 count(id),结果目前都一样，有什么区别？</span><br><span class="line">-- count(*) 是按照 users表中所有的列进行数据的统计，只要其中一列上有数据，就可以计算</span><br><span class="line">-- count(id) 是按照指定的 id 字段进行统计，也可以使用别的字段进行统计，</span><br><span class="line">-- 但是注意，如果指定的列上出现了NULL值，那么为NULL的这个数据不会被统计</span><br><span class="line">-- 假设有下面这样的一张表需要统计</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line">| id | name     | age | sex  | classid |</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line">|  1 | zhangsan |  20 | 男   |       1 |</span><br><span class="line">|  2 | yyx      |  22 | 男   |       1 |</span><br><span class="line">|  3 | lj       |  20 | 男   |       1 |</span><br><span class="line">|  4 | zhaoliu  |  25 | 女   |       1 |</span><br><span class="line">|  5 | uu01     |  26 | 男   |       1 |</span><br><span class="line">|  6 | uu02     |  28 | 男   |       2 |</span><br><span class="line">|  7 | qq02     |  24 | 男   |       2 |</span><br><span class="line">|  8 | uu03     |  32 | 女   |       2 |</span><br><span class="line">|  9 | qq03     |  23 | 女   |       2 |</span><br><span class="line">| 10 | aa       |  19 | 男   |       2 |</span><br><span class="line">| 25 | bb       |  20 | NULL |       2 |</span><br><span class="line">+----+----------+-----+------+---------+</span><br><span class="line"></span><br><span class="line">-- 如果按照sex这一列进行统计，结果就是10个而不是11个，因为sex这一列中有NULL值存在</span><br><span class="line">select count(sex) from stu;</span><br><span class="line">+------------+</span><br><span class="line">| count(sex) |</span><br><span class="line">+------------+</span><br><span class="line">|         10 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>*<em>count(1)  count(</em>)  count(列名) 三者的区别**</p><p>都是返回结果集的行数</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，<strong>不会忽略为NULL的值。</strong>  把null所在行也计算</li><li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，<strong>不会忽略为NULL的值</strong>。</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，<strong>即某个字段值为NULL时，不统计</strong>。</li></ul><p>结论：使用count(1)和count(*)在性能上是差不多的，而count(字段)会判断一下字段是否为空，性能差，结果不一样</p><p>MySQL对count(*)做了优化，</p><p><strong>count(可空字段) &lt; count(非空字段) = count(主键 id) &lt; count(1) ≈ count(*)</strong></p><h3 id="group-by分组"><a href="#group-by分组" class="headerlink" title="group by分组"></a>group by分组</h3><p> group by 语句根据一个或多个列对结果集进行分组</p><p>一般情况下，是用与数据的统计或计算，配合聚合函数使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 统计 stu 表中 男女生人数,</span><br><span class="line">-- 很明显按照上面的需要，可以写出两个语句进行分别统计</span><br><span class="line">select count(*) from stu where sex&#x3D;&#39;女&#39;;</span><br><span class="line">select count(*) from stu where sex&#x3D;&#39;男&#39;;</span><br><span class="line">-- 可以使用分组进行统计，更方便</span><br><span class="line">select sex,count(*) from stu group by sex;</span><br><span class="line">+------+----------+</span><br><span class="line">| sex  | count(*) |</span><br><span class="line">+------+----------+</span><br><span class="line">| NULL |        1 |</span><br><span class="line">| 男   |        7 |</span><br><span class="line">| 女   |        3 |</span><br><span class="line">+------+----------+</span><br><span class="line">-- 统计1班和2班的人数</span><br><span class="line">select classid as &#39;班级&#39;,count(*) from stu group by classid;</span><br><span class="line">+--------+----------+</span><br><span class="line">| 班级   | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      1 |        5 |</span><br><span class="line">|      2 |        6 |</span><br><span class="line">+--------+----------+</span><br><span class="line">-- 分别统计每个班级的男女生人数</span><br><span class="line">select classid,sex,count(*) from stu group by classid,sex;</span><br><span class="line">+---------+------+----------+</span><br><span class="line">| classid | sex  | count(*) |</span><br><span class="line">+---------+------+----------+</span><br><span class="line">|       1 | 男   |        4 |</span><br><span class="line">|       1 | 女   |        1 |</span><br><span class="line">|       2 | NULL |        1 |</span><br><span class="line">|       2 | 男   |        3 |</span><br><span class="line">|       2 | 女   |        2 |</span><br><span class="line">+---------+------+----------+</span><br><span class="line"># 注意，在使用。group by分组时，一般除了聚合函数，其它在select后面出现的字段都需要出现在grouop by后面</span><br></pre></td></tr></table></figure><h3 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h3><p> having时在分组聚合计算后，对结果再一次进行过滤，类似于where。 </p><p>where过滤的是行数据，having过滤的是分组数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 要统计班级人数</span><br><span class="line">select classid,count(*) from stu group by classid;</span><br><span class="line"></span><br><span class="line">-- 统计班级人数，并且要人数达到5人及以上</span><br><span class="line">select classid,count(*) as num from stu group by classid having num &gt;&#x3D;5;</span><br></pre></td></tr></table></figure><h3 id="orded-by"><a href="#orded-by" class="headerlink" title="orded by"></a>orded by</h3><p>ORDER BY 语句用于<strong>根据指定的列对结果集进行排序</strong>。ORDER BY 语句默认按照升序对记录进行排序。</p><p>如您希望按照降序对记录进行排序，可以使用 ASC（升序）、DESC(降序) 关键字。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>查询数据表前几条或者后几条记录，LIMIT可以很好的满足需求。</p><p>limit子句用于限制查询结果返回的数量，常用于分页查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询10条数据，索引从0到9，第1条记录到第10条记录   </span><br><span class="line"># 第一个数类似于数组的下标，从0开始计数，第二个数为记录总条数</span><br><span class="line">select * from t_user limit 10;</span><br><span class="line">select * from t_user limit 0,10;    # 从第1条开始，一共有10条</span><br><span class="line"></span><br><span class="line"># 查询8条数据，索引从5到12，第6条记录到第13条记录</span><br><span class="line">select * from t_user limit 5,8;     # 从第6条开始，一共有8条</span><br></pre></td></tr></table></figure><p><strong>分页需求：</strong></p><p>通过传递<strong>页码（curPage）</strong>和<strong>每页记录条数（pageSize）</strong>两个参数去<strong>分页查询</strong>数据库表中的数据。</p><p>比如：</p><p>查询第1条到第10条的数据的sql是：<code>select * from table limit 0,10</code>;  -&gt;对应我们的需求就是查询第一页的数据：<code>select * from table limit (1-1)*10,10;</code></p><p>查询第11条到第20条的数据的sql是：<code>select * from table limit 10,10</code>; -&gt;对应我们的需求就是查询第二页的数据：<code>select * from table limit (2-1)*10,10</code>;</p><p>查询第21条到第30条的数据的sql是：<code>select * from table limit 20,10</code>; -&gt;对应我们的需求就是查询第三页的数据：<code>select * from table limit (3-1)*10,10</code>;</p><p>这样可以按页去查询数据，比如说查询哪一页的数据，指定页码和每页容纳多少条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curPage是当前第几页；pageSize是一页多少条记录</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">limit</span>(curPage<span class="number">-1</span>)*pageSize,pageSize;</span><br></pre></td></tr></table></figure><h3 id="课后练习题（-分割线-）"><a href="#课后练习题（-分割线-）" class="headerlink" title="课后练习题（***分割线*****）"></a>课后练习题（*<strong>**</strong>分割线*<strong>****</strong>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 1. 统计班级 classid为2的男女生人数？</span><br><span class="line">select sex,count(*) where classid&#x3D;2 group by sex;</span><br><span class="line"></span><br><span class="line">-- 2. 获取每个班级的 平均年龄，并按照平均年龄从大到小排序</span><br><span class="line">select classid,avg(age) as avg_age from stu group by classid order by avg_age desc;</span><br><span class="line"></span><br><span class="line">-- 3. 统计每个班级的人数，按照从大到小排序</span><br><span class="line">select classid,count(*) as &#39;人数&#39; from stu group by classid order by count(*) desc;</span><br></pre></td></tr></table></figure><h3 id="varchar和char的区别？"><a href="#varchar和char的区别？" class="headerlink" title="varchar和char的区别？"></a>varchar和char的区别？</h3><ul><li>varchar表示变长，char表示长度固定。如char（5），无论插入的字符长度是多少，长度都是5，插入字符长度小于5，则<strong>用空格补充。</strong>对于varchar（5），如果插入的字符长度小于5，则存储的字符长度就是插入字符的长度，<strong>不会填充</strong>。</li><li>存储容量不同，对于char来说，最多能存放的字符个数为255，对于varchar，最多能存放的字符个数是65532</li><li>存储速度不同，char长度固定，存储速度会比varchar快一些，但在空间上会占用额外的空间，属于一种空间换时间的策略。而varchar空间利用率会高些，但存储速度慢，属于一种时间换空间的策略。</li></ul><h3 id="查询表的字段属性"><a href="#查询表的字段属性" class="headerlink" title="查询表的字段属性"></a>查询表的字段属性</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">desc table_name     <span class="comment">-- 这里的desc是describe的意思，就是描述表的字段信息</span></span><br><span class="line">creat index nameIndex on student(name);</span><br><span class="line">creat unique index ageIndex on student(age);</span><br><span class="line">desc student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出字段类型、是否为空、Key的类型</span></span><br><span class="line">Field   Type            Null  Key</span><br><span class="line">id    int(11)        NO  PRI</span><br><span class="line">namevarchar(255)Yes  MUL(可以重复)</span><br><span class="line">age    int(11)        YES  UNI(不可重复)</span><br><span class="line">gendervarchar(255)YES</span><br></pre></td></tr></table></figure><h3 id="什么是子查询？"><a href="#什么是子查询？" class="headerlink" title="什么是子查询？"></a>什么是子查询？</h3><p>把一个查询的结果在另一个查询中使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询年纪最大的人</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> age=(<span class="keyword">SELECT</span> <span class="keyword">max</span>(age)<span class="keyword">from</span> <span class="keyword">user</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (age, sex) = (<span class="keyword">SELECT</span> age, sex <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&quot;zhangsan&quot;</span>）                               </span><br></pre></td></tr></table></figure><h3 id="MySQL的几种连接查询"><a href="#MySQL的几种连接查询" class="headerlink" title="MySQL的几种连接查询"></a>MySQL的几种连接查询</h3><p>MySQL的连接查询主要可以分为<strong>外连接</strong>，<strong>内连接</strong>，<strong>交叉连接</strong></p><p><strong>表测试数据：</strong></p><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027113245206.png" alt="image-20211027113245206"></p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>从左表中取出每一条记录，去右表中与所有的记录进行匹配，保留匹配成功的记录，并将两份记录拼接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 内连接</span></span><br><span class="line"><span class="comment">-- select * from student inner join class; --结果与交叉连接相同</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">class</span> <span class="keyword">on</span> student.cid = class.cid;</span><br></pre></td></tr></table></figure><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160249740-1441543214.png" alt="image"></p><p>说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。</p><p><img src="/images/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/3.png" alt="img"></p><h4 id="外连接（左外连接和右外连接）"><a href="#外连接（左外连接和右外连接）" class="headerlink" title="外连接（左外连接和右外连接）"></a>外连接（左外连接和右外连接）</h4><p>与内连接不同的是主表记录不管匹配符不符合都保留，方式有<strong>左外连接、右外连接,左外连接是保留左表，右外连接是保留右表</strong></p><ul><li><p>语法：</p></li><li><ul><li>左外连接：<code>select 字段列表 from 左表 left join 右表 on 左表.字段 = 右表.字段;</code></li><li>右外连接：<code>select 字段列表 from 左表 right join 右表 on 左表.字段 = 右表.字段;</code></li></ul></li><li><p><strong>左外连接</strong></p></li><li><pre><code class="sql">select * from student left join class on student.cid = class.cid;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ![image](&#x2F;images&#x2F;mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&#x2F;1053079-20180411160252239-1394678105.png)</span><br><span class="line"></span><br><span class="line">- **右外连接**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;sql</span><br><span class="line">  select * from student right join class on student.cid &#x3D; class.cid;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1053079-20180411160254539-1309074969.png" alt="image"></p></li></ul><h3 id="Union和Union-All的区别（联合查询语句）"><a href="#Union和Union-All的区别（联合查询语句）" class="headerlink" title="Union和Union All的区别（联合查询语句）"></a>Union和Union All的区别（联合查询语句）</h3><p><strong>作用：</strong></p><p>union和union all的作用都是<strong>将两个结果集合并到一起。</strong>但要注意用于选择的两个语句选择的字段数要相等（否则无法连接），字段类型可以不相等。</p><p><strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">column</span>,......from table1   <span class="keyword">UNION</span> [<span class="keyword">all</span>]   <span class="keyword">select</span>  <span class="keyword">column</span>,...... <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027112104524.png" alt="image-20211027112104524"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,gender <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">class</span>;</span><br><span class="line"><span class="comment">-- 因为class就两个字段，所以第一个只选出两个字段</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><img src="/images/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211027112145964.png" alt="image-20211027112145964" style="zoom: 67%;" /><p><strong>区别：</strong></p><ul><li>union会对结果<strong>去重并排序</strong>，union all直接直接返回合并后的结果，不去重也不进行排序。</li><li>union all的性能比union性能好。</li></ul><h3 id="如何优化Limit分页？"><a href="#如何优化Limit分页？" class="headerlink" title="如何优化Limit分页？"></a>如何优化Limit分页？</h3><p><strong>数据量大的时候limit分页速度为什么会变慢？</strong></p><p><strong>如何优化？</strong></p><h3 id="SQL语句执行的很慢的原因"><a href="#SQL语句执行的很慢的原因" class="headerlink" title="SQL语句执行的很慢的原因"></a>SQL语句执行的很慢的原因</h3><ul><li>可能是执行的时候遇到了锁</li><li>可能是字段上没有索引或者字段有索引但是没用上索引（比如不满足最左匹配准则）</li></ul><h3 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h3><p>查询中用到的关键词主要包含六个，并且他们的顺序依次为</p><p>select–from–where–group by–having–order by </p><p><strong>这六个关键词的执行顺序 与sql语句的书写顺序并不是一样</strong>的，其中select和from是必须的，其他关键词是可选的，按照下面的顺序来执行：</p><p>from–where–group by–having–select–order by,</p><p>from:需要从哪个数据表检索数据</p><p>where:过滤表中数据的条件</p><p>group by:如何将上面过滤出的数据分组</p><p>having:对上面已经分组的数据进行过滤的条件 （对分组后的数据进行统计）</p><p>select:查看结果集中的哪个列，或列的计算结果</p><p>order by :按照什么样的顺序来查看返回的数据</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>攻击者通过SQL语句欺骗服务器而得到非授权的查询，进而获取数据库信息</p><p>大部分的sql注入是因为程序要接受客户端传来的参数，而这些参数是组成sql语句的一部分，改变了正常的sql语句结构所导致</p><p>解决方法：</p><ol><li>在执行SQL语句之前，先检查客户端传来的参数类型和格式是否符合预期的格式，同时要过滤掉一些非法的字符等等。</li><li>使用预编译语句，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构</li></ol><h3 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h3><p>MySQL触发器指通过事件触发而执行，而不是主动调用；它会事先为某张表绑定一段代码，当表中的某些内容发生改变（增、删、改）的时候，系统会自动触发代码并执行。</p><p>我们需要指定绑定的表、改变之前触发还是改变之后触发、触发之后该怎么做</p><p>下面这个例子：当我们在student表中插入一个学生时，就需要在成绩表中插入对应的学生信息。</p><ol><li><strong>create</strong> <strong>trigger</strong> ins_stu </li><li><strong>after</strong> <strong>insert</strong> <strong>on</strong> student <strong>for</strong> each row  </li><li><strong>begin</strong> </li><li>   <strong>insert</strong> <strong>into</strong> cj ( stu_id, stu_name) </li><li>​    <strong>values</strong>( new.stuid, new.username); </li><li><strong>end</strong>; </li></ol><h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p>即第一范式要求确保表中每列的原子性，也就是不可拆分；第二范式要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖；第三范式确保主键列之间没有传递函数依赖关系，也就是消除传递依赖</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记一下常见的MySQL语句&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>linux常用指令</title>
    <link href="http://example.com/2021/10/23/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>http://example.com/2021/10/23/linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2021-10-23T08:50:29.000Z</published>
    <updated>2021-10-23T09:53:39.843Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一些linux常用指令</p></blockquote><a id="more"></a><p><strong>查看运行的进程</strong>： ps    </p><ul><li><p>ps -ef  查看所有进程信息</p><p>-e 显示所有进程。<br>-f 全格式。</p></li><li><p>ps -ef | grep java    查看java进程信息</p></li></ul><p><strong>结束进程</strong>：kill   pid     </p><ul><li><p>kill -9 pid 强制结束进程   </p></li><li><p>kill -15 pid 默认方式，正常结束进程</p></li></ul><p>kill原理：kill 命令会向操作系统发送一个信号（多是终止信号）和目标进程的 PID，然后系统根据收到的信号类型，对指定进程进行相应的操作。我们的 -9 -15 都是信号类型</p><p><strong>查看与某台机器的连接情况</strong> ：ping</p><p>命令：ping ip</p><p><strong>查看每个进程的运行情况</strong>：top</p><p>类似于windows的资源管理器</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>目录切换：cd       cd / 切换到根目录    、  cd ../ 切换到上一级目录 或者  cd ..</p><p>目录查看：ls        ls -a查看当前目录下的所有目录和文件（包括隐藏的文件）</p><p>创建目录：mkdir     mkdir   aaa 在当前目录下创建一个名为aaa的目录</p><p>删除目录：rm     rm 文件名   删除当前目录下的文件  、   rm -r aaa   递归删除当前目录下的aaa目录   </p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>新建文件：touch       touch  aa.txt   在当前目录创建一个名为aa.txt的文件    </p><p>删除文件：rm</p><p>修改文件：vi  进入文件    按 i 进入编辑模式   按wq保存并退出</p><p>查看文件：more</p><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><p>命令：tar -zcvf  打包压缩后的文件名  要打包的文件</p><p>例子：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar</p><p>tar -zcvf ab.tar  *</p><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><p>grep：匹配文件中的文本</p><p> grep  ‘test’  file    匹配file文件中 含有 text 的文本</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一些linux常用指令&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/10/21/%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/10/21/%E5%AE%9E%E4%B9%A0%E6%8A%95%E9%80%92%E8%AE%B0%E5%BD%95/</id>
    <published>2021-10-21T01:30:23.489Z</published>
    <updated>2021-10-26T14:31:44.291Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">网址</th><th>公司名称</th><th>投递时间</th><th>面试时间</th><th>面试状态</th><th>一面</th></tr></thead><tbody><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_d6gl0x8oliko?pcm=pc_SearchList%EF%BC%88%E5%AE%9E%E4%B9%A0%E5%83%A7%EF%BC%89">https://www.shixiseng.com/intern/inn_d6gl0x8oliko?pcm=pc_SearchList（实习僧）</a></td><td>猿辅导</td><td>10月21日 9:32</td><td></td><td>被拒</td><td>无</td></tr><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_lpevnzwllesy?pcm=pc_SearchList">https://www.shixiseng.com/intern/inn_lpevnzwllesy?pcm=pc_SearchList</a> （实习僧）</td><td>小米</td><td>10月21日9:42</td><td></td><td>等待约面</td><td>一面挂</td></tr><tr><td align="left"><a href="https://www.shixiseng.com/intern/inn_pzv2tkpt7pxv?pcm=pc_SearchList">https://www.shixiseng.com/intern/inn_pzv2tkpt7pxv?pcm=pc_SearchList</a> （实习僧）</td><td>京东</td><td>10月21日9:45</td><td></td><td>等待约面</td><td>等消息</td></tr><tr><td align="left"><a href="https://nowpick.nowcoder.com/w/intern/detail?jobId=61053&amp;deliverSource=2&amp;pageSource=5004%EF%BC%88%E7%89%9B%E5%AE%A2%EF%BC%89%E6%B2%A1%E6%9C%89%E5%9B%9E%E5%93%8D">https://nowpick.nowcoder.com/w/intern/detail?jobId=61053&amp;deliverSource=2&amp;pageSource=5004（牛客）没有回响</a></td><td>滴滴</td><td>10月21日 9:54</td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">学长内推</td><td>字节</td><td>10月22日10:00</td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">实习僧</td><td>百度</td><td></td><td></td><td>等待约面</td><td></td></tr><tr><td align="left">实习僧</td><td>快手</td><td></td><td></td><td>等待约面</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;网址&lt;/th&gt;
&lt;th&gt;公司名称&lt;/th&gt;
&lt;th&gt;投递时间&lt;/th&gt;
&lt;th&gt;面试时间&lt;/th&gt;
&lt;th&gt;面试状态&lt;/th&gt;
&lt;th&gt;一面&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10.18</title>
    <link href="http://example.com/2021/10/18/10-18/"/>
    <id>http://example.com/2021/10/18/10-18/</id>
    <published>2021-10-18T12:58:44.000Z</published>
    <updated>2021-10-24T02:06:19.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕叽咕叽</p><p>看了几篇字节的面经，有那么点感觉好像面试题都答得上来了，至少题目都还见过，只是记得熟不熟的问题。</p><p>我飘了，快来骂醒我！！</p><p>许愿许愿，搞定了就来还愿</p></blockquote><a id="more"></a><p>10.24更</p><p>笑死，根本学不完，飘不起来。</p><hr><p>看到一个帖子，其实感触还蛮深。。。</p><p>想要说点什么</p><p><img src="/images/10-18/image-20211024100435602.png" alt="image-20211024100435602"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕叽咕叽&lt;/p&gt;
&lt;p&gt;看了几篇字节的面经，有那么点感觉好像面试题都答得上来了，至少题目都还见过，只是记得熟不熟的问题。&lt;/p&gt;
&lt;p&gt;我飘了，快来骂醒我！！&lt;/p&gt;
&lt;p&gt;许愿许愿，搞定了就来还愿&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ReentrantLock介绍</title>
    <link href="http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T08:50:25.000Z</published>
    <updated>2021-10-28T03:36:10.778Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下</p></blockquote><a id="more"></a><p>Lock是一个接口，Reentrantlock是Lock的一个主要实现类。</p><p><strong>ReentrantLock</strong> 类内部总共存在<strong>Sync</strong>、<strong>NonfairSync</strong>、<strong>FairSync</strong>三个类，<strong>NonfairSync</strong>与 <strong>FairSync</strong>类继承自 <strong>Sync</strong>类，<strong>Sync</strong>类继承自 <strong>AbstractQueuedSynchronizer</strong>抽象类</p><h1 id="synchronized与ReentrantLock的区别（5点）"><a href="#synchronized与ReentrantLock的区别（5点）" class="headerlink" title="synchronized与ReentrantLock的区别（5点）"></a>synchronized与ReentrantLock的区别（5点）</h1><p>共同点：都是可重入锁、都是排它锁。</p><p>可重入锁：当前线程获取该锁后还可以再次获取，不会发生阻塞。</p><p>独占锁：一个锁只能被一个线程所占有。</p><p>在性能上ReentrantLock和synchronized差不多，但ReentrantLock相比synchronized而言<strong>功能更加丰富，使用起来更为灵活。</strong></p><p>① <strong>底层实现上来说</strong></p><p>​    synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来实现</p><p>​    ReentrantLock 是JUC.lock包下的一个类，是<strong>API层面</strong>的锁。</p><p>② <strong>是否可手动释放：</strong></p><p>​    synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用；</p><p>​    ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。</p><p>③ <strong>是否公平锁</strong></p><p>​    公平锁介绍：多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁</p><p>​    synchronized为非公平锁 </p><p>​    ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空<strong>默认false非公平锁</strong>，true为公平锁。</p><p>④ <strong>是否可中断</strong></p><p>​    可中断介绍：</p><p>​    线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，</p><p>   如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断</p><p>   如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p><p>​    synchronized是不可中断类型的锁。</p><p>​    ReentrantLock可以中断，可通过<strong>tryLock</strong>(long timeout,TimeUnit unit)设置超时方法（超时没有获得锁就中断）或者将<strong>lockInterruptibly</strong>()放到代码块中，调用<strong>interrupt</strong>方法进行中断。</p><p>⑤ <strong>锁是否可绑定条件Condition</strong></p><p>​    synchronized不能绑定；     </p><p>​    ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的<strong>精确唤醒</strong>，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。</p><h2 id="Reentrantlock的底层实现"><a href="#Reentrantlock的底层实现" class="headerlink" title="Reentrantlock的底层实现"></a>Reentrantlock的底层实现</h2><p><strong>ReentrantLock</strong> 类内部总共存在<strong>Sync</strong>、<strong>NonfairSync</strong>、<strong>FairSync</strong>三个类，<strong>NonfairSync</strong>与 <strong>FairSync</strong>类继承自 <strong>Sync</strong>类，<strong>Sync</strong>类继承自 <strong>AbstractQueuedSynchronizer</strong>抽象类</p><p><strong>底层主要是AQS+CAS操作，AQS=双向链表+volatile类型的state状态量</strong></p><p>先讲一下AQS，AQS（AbstractQueuedSynchronizer）抽象队列同步器，是一个双向链表+volatile类型的state状态量所构成。</p><p>双向链表是由一个个Node组成的，没有抢到锁的线程被封装成Node节点放入队列中，每个Node节点有两个指针，叫做分别指向前驱结点和后继结点，同时还存有一个Thread的变量，代表封装的线程，需要注意的是，这些变量也都是Volatile类型的，主要是为了保证对其他线程课件。</p><p>state主要是表示是否有线程获取到锁了，当有线程获取到锁时，state=1，如果获取到锁的线程再次加锁，state加一；同理当释放锁时，state减一。当state=0时，会唤醒队列中的下一个节点。</p><p><strong>底层排队过程如下：</strong></p><p>主要分为抢到锁的线程，和没有抢到锁在队列里面排队的线程</p><p>首先A抢到锁了，state=1，当前线程改为A线程。</p><p>如果B线程再来抢锁，通过CAS操作先去判断state的值，发现state!=0; 去队列里面排队，排队之前并不会直接用头指针指向B线程所在的节点，而是先创建一个空节点，我们称这个空间点叫做哨兵节点，在哨兵节点创建完毕后，再把自己连接在哨兵结点之后。即先设置哨兵节点，再设置B节点</p><p>如果C再来抢锁，通过CAS，发现state!=0;去队列里面排队，发现头结点已经指向了一个哨兵节点，就不用再设置哨兵节点了，去B节点后面排队。</p><p>（排队的过程还涉及再次抢锁，如果没有进入park状态，等待A线程释放锁唤醒）</p><p>接着A线程释放锁，将state设为0，将B线程唤醒，同时受理窗口改为B线程，队列中的B节点Thread设置为null，并用头结点指向，那么开始的哨兵节点由于没有对象指向就变成了垃圾被GC掉。</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026103743409.png" alt="image-20211026103743409"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104027910.png" alt="image-20211026104027910"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104154035.png" alt="image-20211026104154035"></p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026104257380.png" alt="image-20211026104257380"></p><p>第一次排队的节点是一个空节点</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026110225172.png" alt="image-20211026110225172"></p><p>如果队列中再来一个节点</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026110508921.png" alt="image-20211026110508921">    </p><p>B节点出队后，设置成了null，相当于是新的哨兵节点。而原来得哨兵节点没有任何引用指向它，就被GC掉</p><p><img src="/images/ReentrantLock%E4%BB%8B%E7%BB%8D/image-20211026112122771.png" alt="image-20211026112122771"></p><p>按照自己理解的Reentrantlock的加锁和解锁过程：</p><p><strong>底层主要是AQS+CAS操作，AQS=双向链表+state状态量</strong></p><p>主要分为抢到锁的线程，和没有抢到锁在队列里面排队的线程</p><p>首先A抢到锁了，state=1，受理窗口改为A线程。</p><p>如果B线程再来抢锁，通过CAS，发现state!=0;去队列里面排队，排队之前先设置哨兵节点，在设置B节点</p><p>如果C再来抢锁，通过CAS，发现state!=0;去队列里面排队，发现头结点已经指向了一个哨兵节点，就不用再设置哨兵节点了，去B节点后面排队。</p><p>（排队的过程还涉及再次抢锁，如果没有进入park状态，等待A线程释放锁唤醒）</p><p>接着A线程释放锁，将state设为0，将B线程唤醒，同时受理窗口改为B线程，队列中的B节点Thread设置为null，并用头结点指向，那么开始的哨兵节点由于没有对象指向就变成了垃圾被GC掉。</p><p>。。。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java中几种锁的介绍</title>
    <link href="http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T07:25:38.000Z</published>
    <updated>2021-10-24T09:12:48.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中一些锁的介绍</p></blockquote><a id="more"></a><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当第二个线程想拿这个数据的时候，第二个线程会一直堵塞，直到第一个释放锁，他拿到锁后才可以访问。传统的数据库里面就用到了这种锁机制，例如：行锁，表锁，读锁，写锁，都是在操作前先上锁。<strong>java中的synchronized的实现也是一种悲观锁。</strong></p><p><strong>乐观锁</strong>：乐观锁概念为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有修改过数据，乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。在Java中java.util.concurrent.<strong>atomic包下面的Atomic操作类就是使用了乐观锁</strong>，<strong>而Atomic操作类的底层正是用到了“CAS机制”。</strong></p><p>采用悲观锁的一些问题（采用synchronized的一些问题）：</p><ul><li>在多线程竞争下，多次加锁释放锁会造成性能损耗</li><li>如果一个线程持有锁，其他的线程就都会阻塞，等待持有锁的线程释放锁。</li></ul><p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。</p><p>乐观锁就是：每次不加锁而是假设没有并发冲突去操作同一变量，如果有并发冲突导致失败，则重试直至成功。</p><p>主要就是两个步骤：<strong>冲突检测和数据更新</strong>。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，先来后到。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><p>简单来说就是：</p><p><strong>公平锁</strong> ：是指多个线程按照申请锁的顺序来获取锁，类回排队打饭先来后到。<br><strong>非公平锁</strong> ：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</p><p><strong>什么是饥饿？</strong></p><p>优先级高的线程能够插队并优先执行，这样如果<strong>优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。</strong>当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源。</p><p>ReentrantLock中就有相关公平锁，非公平锁的实现。默认是非公平锁，如果为设置为true就是公平锁。更深入的需要探寻其中的源码实现原理</p><h2 id="可重入锁和非重入锁"><a href="#可重入锁和非重入锁" class="headerlink" title="可重入锁和非重入锁"></a>可重入锁和非重入锁</h2><p>可重入锁：当前线程获取该锁后还可以再次获取，不会发生阻塞。</p><p>用一个简单的例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说A和B都是两个synchronized修饰的方法，在方法A中调用了方法B；有一个线程获取到了锁执行方法A，然后在执行方法B的时候就自动获取锁，去执行方法B；</p><p><strong>可重入锁可以避免线程死锁</strong>：</p><p>假如Synchronized不是可重入锁；那么该线程获取到执行A方法所需要的锁之后开始执行A方法；但是在执行过程中遇到了方法B；由于是不可重入锁；B方法也是被Synchronized关键字修饰；所以执行B方法也需要获取锁；但是此时A方法代码还未执行完成，继续占有锁；B方法就获取不到锁，被阻塞；A方法迟迟执行不完成，所以也就一直不释放锁；因此；就产生了死锁</p><p>synchronized和ReentrantLock都是可重入锁；当然ReentrantLock还可以设置成为公平锁，也就是不可重入锁；</p><p>不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;java中一些锁的介绍&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CAS和Atomic相关</title>
    <link href="http://example.com/2021/10/16/CAS%E5%92%8CAtomic%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/16/CAS%E5%92%8CAtomic%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-16T01:05:18.000Z</published>
    <updated>2021-11-05T02:42:44.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java.util.concurrent.atomic 和 java.util.concurrent.locks 是两个很重要的包</p></blockquote><a id="more"></a><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><p>这篇文章通俗易懂的解释了CAS操作  <a href="https://www.sohu.com/a/314272265_120104204">什么是CAS机制，通俗易懂大白话版</a></p><h3 id="什么是乐观锁与悲观锁？"><a href="#什么是乐观锁与悲观锁？" class="headerlink" title="什么是乐观锁与悲观锁？"></a><strong>什么是乐观锁与悲观锁？</strong></h3><p><strong>乐观锁</strong>：乐观锁概念为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有修改过数据。乐观锁的实现方式一般有两种：<strong>版本号机制</strong>和<strong>CAS操作</strong>。在Java中java.util.concurrent.<strong>atomic包下面的Atomic操作类就是使用了乐观锁</strong>，<strong>而Atomic操作类的底层正是用到了“CAS机制”。</strong></p><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当第二个线程想拿这个数据的时候，第二个线程会一直堵塞，直到第一个释放锁，他拿到锁后才可以访问。传统的数据库里面就用到了这种锁机制，例如：行锁，表锁，读锁，写锁，都是在操作前先上锁。<strong>java中的synchronized的实现也是一种悲观锁。</strong></p><p><strong>乐观锁与悲观锁的适用场景：</strong></p><p>总结：两种所各有优缺点，读取操作比较频繁使用乐观锁，写入操作比较频繁使用悲观锁。</p><p>因为写入操作比较频繁用乐观锁的话，发生冲突的可能性就会增大，就会不断自旋尝试</p><p>读取操作比较频繁的话，每次读取都需要加锁，开销太大，推荐使用乐观锁。</p><h3 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h3><p>一般在数据表中加一个数据版本号version字段，每次对数据修改时,version加一；当有线程要更新数据时，在读取数据的同时还会读取version值，再提交更新的时候会再次读取version值，然后判断当前version值和之前的version值是否相同，如果相同则提交成功，如果失败则重复上述操作直到成功为止。</p><p><strong>流程示意：</strong></p><p>当线程要更新数据了-》读取数据同时读取版本号-》更新提交时再次读取版本号-》对照两次版本号是否相同</p><p>-》若版本号相同说明没有其他线程更改数据，更新成功 ；若不相同则更改失败再次重复上述操作。</p><h3 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h3><p><strong>乐观锁是一种思想，CAS是这种思想的一种实现方式。</strong></p><p>相比于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以在性能上有了很大的提升。</p><p><strong>CAS是乐观锁技术，当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋</strong>。Java中的自旋锁就是利用CAS来实现的。</p><p>CAS即Compare And Swap，翻译成中文即比较并替换。Java中可以通过CAS操作来保证原子性，原子性就是一系列操作，要么全部完成，要么失败，不能被中断。</p><p>CAS操作包括三个操作数：需要读写的内存值(V)、预期原值(A)、新值(B)。</p><p><strong>算法流程</strong>：比较A和V的值，如果相等，将B值赋值给A，如果不相等说明有其他线程对该变量做了更新，自旋或者不做操作</p><h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><ul><li><p><strong>ABA问题</strong></p><p>如果一个变量V初次读取时是A的值，在再次被读取的期间，先被其他线程修改成B又被修改成A，则CAS操作会认为它从来没有被修改过，显示这是错误的。</p><p><strong>ABA问题解决方案：加上版本号</strong></p><p>JUC的atomic包里提供了一个类<strong>AtomicStampedReference</strong>来解决ABA问题。</p><p>给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使内存V中的值从A-&gt;B-&gt;A，但是版本号也发生了变化。基于CAS的乐观锁也是这个实现原理。</p></li><li><p><strong>循环时间过长导致开销太大</strong></p><p>CAS自旋不成功，就一直循环执行，如果长时间不成功，会给CPU带来非常大的执行开销</p></li><li><p><strong>只能保证一个共享变量的原子操作</strong></p><p>但如果对多个共享变量进行操作时，CAS则无法保证操作的原子性，这时候就需要用锁了。</p></li></ul><h3 id="CAS和synchronized对比"><a href="#CAS和synchronized对比" class="headerlink" title="CAS和synchronized对比"></a>CAS和synchronized对比</h3><p>1.对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p><p>2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><h3 id="分析atomic包下的原子操作类AtomicInteger（待解决）"><a href="#分析atomic包下的原子操作类AtomicInteger（待解决）" class="headerlink" title="分析atomic包下的原子操作类AtomicInteger（待解决）"></a>分析atomic包下的原子操作类AtomicInteger（待解决）</h3><p>我们看一下AtomicInteger类中常用的自增方法incrementAndGet，相当于i++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">int</span> current = get();  </span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line">                <span class="keyword">return</span> current;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/JUC%E5%8C%85%E4%B8%8Batomic%E5%92%8Clocks%E7%9B%B8%E5%85%B3/webp.webp" alt="img"></p><p>实现CAS操作的应该是getAndAddInt（）方法，</p><p>核心实现是先获取当前值和目标值（也就是value+1），如果<code>compareAndSet(current, next)</code> 返回成功则该方法返回目标值。那么compareAndSet是做什么的呢？理解这个方法我们需要引入CAS操作。</p><p>AtomicInteger 中的CAS操作就是<code>compareAndSet()</code>，其作用是每次从<strong>内存中根据内存偏移量（<code>valueOffset</code>）取出数据</strong>，将取出的值跟expect 比较，如果数据一致就把内存中的值改为update。</p><p>这样使用CAS就保证了原子操作。其余几个方法的原理跟这个相同，在此不再过多的解释。</p><p>没看AtomicInteger 源码之前，我认为其内部是用<code>synchronized</code> 来实现的原子操作。查阅资料后发现<code>synchronized</code> 会影响性能，因为Java中的<code>synchronized</code> 锁是独占锁，虽然可以实现原子操作，但是这种实现方式的并发性能很差。</p><p><strong>1. java语言CAS底层如何实现？</strong></p><p><strong>利用unsafe提供的原子性操作方法。</strong></p><p>总结一下，AtomicInteger 中主要实现了整型的原子操作，防止并发情况下出现异常结果，其内部主要依靠JDK 中的unsafe 类操作内存中的数据来实现的。volatile 修饰符保证了value在内存中其他线程可以看到其值得改变。CAS操作保证了AtomicInteger 可以安全的修改value 的值。</p><h2 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h2><p>Atomic原子类位于java.util.concurrent.atomic包下，<strong>原子类就是具有原子操作特征的类</strong>。原子操作特征是指：多个操作要么都成功要么都失败，不会被其他线程干扰。</p><p>四种原子类：基本类型（3个）、数组类型（3个）、引用类型、原子更新字段类</p><p><img src="/images/JUC%E5%8C%85%E4%B8%8Batomic%E5%92%8Clocks%E7%9B%B8%E5%85%B3/image-20211016113025301.png" alt="image-20211016113025301"></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>也简单介绍一下</p><p>AQS的全称是AbstractQueuedsynchronizer，抽象队列同步器，它是Java并发用来构建锁和其他同步组件的基础框架。</p><p>变量+一个队列</p><p>ReentrantLock<br>CountDownLatch<br>ReentrantReadWriteLock<br>Semaphore                                   这四个是什么意思？</p><p>锁和同步器区别？</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>简单介绍一下</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent.atomic 和 java.util.concurrent.locks 是两个很重要的包&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>volatile深入理解</title>
    <link href="http://example.com/2021/10/15/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/15/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-15T11:47:13.000Z</published>
    <updated>2021-10-26T07:01:42.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>volatile</p></blockquote><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>介绍并发编程的三大特性：原子性、可见性、有序性</p><p>volatile不具有原子性，具有可见性和有序性</p><p>其底层实现原理也是围绕这两点来展开的</p><p>volatile主要的作用包括两点：</p><p>1.<strong>保证线程间共享变量的可见性。</strong>（可见性）</p><p>2.<strong>禁止CPU进行指令重排序。</strong>（有序性）使用内存屏障禁止指令重排</p><h2 id="volatile实现可见性原理"><a href="#volatile实现可见性原理" class="headerlink" title="volatile实现可见性原理"></a>volatile实现可见性原理</h2><p>首先介绍一下JMM模型</p><p>可见性问题是由Java内存模型中的工作内存和主内存之间的值不一致所导致</p><p>例如上面所说线程1访问自己工作内存A中的值时，但此时主内存的该值已经被线程2所修改，所以线程1所访问到的值是一个脏数据。</p><p>那如何解决这种问题呢？用volatile修饰共享变量</p><p>可以发现通过volatile修饰的变量，生成汇编指令时会比普通的变量多出一个Lock指令，这个Lock指令就是volatile关键字可以保证内存可见性的关键，它主要有两个作用：</p><ul><li>将当前处理器缓存的数据刷新到主内存。</li><li>刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效。</li></ul><p>因此其他线程会直接从主内存中读取数据，</p><h2 id="volatile实现有序性原理（内存屏障没看懂）"><a href="#volatile实现有序性原理（内存屏障没看懂）" class="headerlink" title="volatile实现有序性原理（内存屏障没看懂）"></a>volatile实现有序性原理（内存屏障没看懂）</h2><blockquote><p>前面提到的指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但在多线程程序中可能导致程序的运行结果不正确，那volatile是如何解决这一问题的呢？</p></blockquote><p>为了实现volatile的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。</p><p>内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p><p>java虚拟机把内存屏障分为4类：</p><img src="/images/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211015223529379.png" alt="内存屏障" style="zoom:80%;" /><p>Java内存模型对编译器指定的volatile重排序规则为：</p><ul><li><p>当第一个操作是volatile读时，无论第二个操作是什么都不能进行重排序。</p></li><li><p>当第二个操作是volatile写时，无论第一个操作是什么都不能进行重排序。</p></li><li><p>当第一个操作是volatile写，第二个操作为volatile读时，不能进行重排序。</p></li></ul><p>根据volatile重排序规则，Java内存模型采取的是保守的屏障插入策略，volatile写是在前面和后面分别插入内存屏障，volatile读是在后面插入两个内存屏障，具体如下：</p><h2 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h2><ul><li><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。</p></li><li><p>volatile 关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。</p></li><li><p>volatile关键字只能用于变量，synchronized关键字用来修饰方法以及代码块。</p></li><li><p>volatile 关键字不能保证原子性，synchronized关键字能保证原子性</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;volatile&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java线程池相关</title>
    <link href="http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-15T03:38:17.000Z</published>
    <updated>2021-11-03T01:24:16.686Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程池相关</p></blockquote><a id="more"></a><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a><strong>什么是线程池？</strong></h2><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>有了线程池后，如果我们要处理多线程的任务，直接从线程池中去取线程即可，而不用每个请求任务都创建和销毁线程，提高服务器的性能。</p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a><strong>为什么要使用线程池？</strong></h2><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程太耗费性能，于是我们可以使用线程池技术把创建和销毁的线程的过程去掉，直接从线程池中取出线程</p><h2 id="线程池有什么作用？"><a href="#线程池有什么作用？" class="headerlink" title="线程池有什么作用？"></a><strong>线程池有什么作用？</strong></h2><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><h2 id="创建线程池的方法"><a href="#创建线程池的方法" class="headerlink" title="创建线程池的方法"></a>创建线程池的方法</h2><p>创建出来的线程池都实现了ExecutorService接口。常用方法有以下几个：</p><p>1、<strong>使用自定义的ThreadPoolExecutor类</strong></p><p>2、<strong>使用Executors类（四种线程池）</strong></p><p>Executors类为我们提供了四种常见的线程池，但本质上都是调用ThreadPoolExecutor的构造函数，只是构造函数的参数不同。使用Executors类创建线程池可能会造成OOM，比如说我们使用Exexutors类中的newFixedThreadPool，意思是创建一个固定大小的线程池，超过了这个大小就要在等待队列中排队，而等待队列的最大值是Integer.Max_Value，相当于无穷大，当我们不断创建线程执行的时候就会超出堆空间的内存，导致OOM的发生，所以我们建议使用自定义的ThreadPoolExecutors类，并设置等待队列的大小。</p><p>所以我们推荐使用ThreadPoolExecutors的方法，根据我们的需要自定线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.调用ThreadPoolExecutos的构造函数创建一个对象</span></span><br><span class="line"><span class="comment">//2.调用这个对象的execute方法，execute方法中一般是一个实现了runnable接口的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">            ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">60</span>, TimeUnit.MICROSECONDS, <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">                Runnable task = <span class="keyword">new</span> CustomTask(i);</span><br><span class="line">                <span class="comment">//将runnable对象作为参数传入pool.execute中。</span></span><br><span class="line">                pool.execute(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说几种常见的线程池及使用场景"><a href="#说说几种常见的线程池及使用场景" class="headerlink" title="说说几种常见的线程池及使用场景"></a><strong>说说几种常见的线程池及使用场景</strong></h2><p><strong>java.util.concurrent.Executors类为我们提供了创建线程池的简便方法。</strong></p><p>使用Executors可以创建我们常用的四种线程池：</p><p>（1）newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。不设上限，提交的任务将立即执行。</p><p>（2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>（3）newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>（4）newSingleThreadExecutor 创建一个单线程化的线程池执行任务。</p><blockquote><p>这几种线程池的源码都调用了ThreadPoolExecutor的构造函数</p></blockquote><p><strong>Executors的坏处</strong></p><p>正常来说，我们<strong>不应该使用这种方式创建线程池</strong>，应该使用<strong>ThreadPoolExecutor</strong>来创建线程池。Executors创建的线程池也是调用的ThreadPoolExcutor的构造函数。通过源码可以看出：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015164333196.png" alt="newFixedThreadPool"></p><p>我们也看到了这里面的LinkedBlockingQueue并没有指定队列的大小，是一个无界队列，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致OOM。所以我们一般要使用ThreadPoolExecutor这种方式来创建线程池。</p><p><strong>创建线程池的正确姿势：</strong></p><p>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>或者是使用开源类库：开源类库，如apache和guava等。</p><p><strong>五种线程池的使用场景</strong></p><p>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</p><p>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</p><p>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</p><p>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h2 id="线程池中的几种重要的参数（7个）"><a href="#线程池中的几种重要的参数（7个）" class="headerlink" title="线程池中的几种重要的参数（7个）"></a><strong>线程池中的几种重要的参数</strong>（7个）</h2><p><strong>ThreadPoolExecutors构造函数中7个重要的参数：</strong></p><ul><li><p>corePoolSize就是线程池中的核心线程数量，即使这些线程处理空闲状态，他们也不会被销毁</p></li><li><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p></li><li><p>keepAliveTime，非核心线程在空闲状态下的最大存活时间，超过这个时间，非核心线程就会被销毁</p></li><li><p>util，表示最长存活时间的单位。</p></li><li><p>workQueue，就是等待队列，当核心线程数满了后其他请求就储存在任务队列中，等待被执行，按照FIFIO原则（先进先出）。</p></li><li><p>threadFactory，就是创建线程的线程工厂。</p></li><li><p>handler,是一种拒绝策略，当线程池中线程数量满了后，拒绝执行某些任务。（4种内置的拒绝策略）</p></li></ul><p><strong>线程池提交任务时的执行流程：</strong></p><p>当我们创建好线程池后，要向线程池提交任务时：</p><p>会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</p><p>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</p><p>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</p><p>如果已经达到了最大线程数，则执行指定的拒绝策略。</p><p><strong>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</strong></p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015180107031.png" alt="线程池提交任务时的执行流程"></p><p>举个例子：corePoolSize为2，maximumPoolSize为6，workQueue大小为5；</p><p><strong>第一步</strong>，任务0、1提交时，创建核心线程并执行<br><strong>第二步</strong>，任务2、3、4、5、6提交时，将其放在工作队列（工作队列能容纳5个线程）<br><strong>第三步</strong>，任务7、8、9、10提交时，创建线程并执行，直到池子满了（工作队列也满了，多一个线程就创建一个新线程，但总线程数不能大于maximumPoolSize）<br><strong>第四步</strong>，任务11、12、13、14、15被拒绝策略拒绝（什么时候被拒绝策略拒绝呢？当请求线程数&gt;工作队列容量+ maximumPoolSize时）<br><strong>第五步</strong>，执行缓存队列中的任务2、3、4、5、6</p><h2 id="线程池常用的阻塞队列（没有很理解）"><a href="#线程池常用的阻塞队列（没有很理解）" class="headerlink" title="线程池常用的阻塞队列（没有很理解）"></a>线程池常用的阻塞队列（没有很理解）</h2><ol><li><p><strong>LinkedBlockingQueue</strong></p><p>LinkedBlockingQueue，它的容量是 Integer.MAX_VALUE，为 2^31 -1 ，是一个非常大的值，可以认为是无界队列。</p><p>这里需要注意，FixedThreadPool 和 SingleThreadExecutor 线程池的线程数是固定的，其中maximumPoolSize这个参数是没有用的，因为阻塞队列根本就放不满，所以线程池只会创建核心线程数量的线程</p></li><li><p><strong>SynchronousQueue</strong><br> 第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。<br> 我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p></li><li><p><strong>DelayedWorkQueue</strong><br> 第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p></li></ol><p>下面是四种线程池对应的阻塞队列：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015181738391.png" alt="image-20211015181738391"></p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a><strong>线程池的拒绝策略</strong></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当线程池中最大线程数满了后，我们需要采取拒绝策略。</span><br><span class="line">在ThreadPoolExecutor中已经包含四种处理策略，默认为AbortPolicy策略，即丢弃任务并抛出异常。</span><br></pre></td></tr></table></figure><ul><li><p>AbortPolicy策略：丢弃任务并抛出RejectedExecutionException异常。</p></li><li><p>DiscardPolicy策略：丢弃任务，但是不抛出异常。</p></li><li><p>DiscardOlddestPolicy策略： 该策略将丢弃最老的一个请求，也就是工作队列中最前面的一个请求，并再次提交当前任务。</p></li><li><p>CallerRunsPolicy 策略：如果线程池未关闭，由调用线程（即提交任务的线程）执行此该请求</p></li></ul><p><strong>自定义拒绝策略</strong>：除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，只需实现RejectedExecutionHandler接口即可。</p><h2 id="线程池的执行任务和关闭"><a href="#线程池的执行任务和关闭" class="headerlink" title="线程池的执行任务和关闭"></a>线程池的执行任务和关闭</h2><p><strong>execute和submit用来执行线程池中的任务</strong></p><ul><li>execute（）方法用于不需要提交返回值的任务</li><li>submit（）方法用于需要提交返回值的任务。</li></ul><p><strong>线程池的关闭</strong></p><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><ul><li><p>shutdownNow（）方法的解释是：线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。</p></li><li><p>shutdown（）方法的解释是：线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。</p></li></ul><p><strong>初始化线程池时线程数的选择</strong></p><p>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</p><p>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</p><p>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线程池相关&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized深入理解</title>
    <link href="http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-13T01:55:05.000Z</published>
    <updated>2021-11-03T08:55:17.889Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>synchronized </p></blockquote><a id="more"></a><h2 id="线程安全问题和线程同步"><a href="#线程安全问题和线程同步" class="headerlink" title="线程安全问题和线程同步"></a>线程安全问题和线程同步</h2><p><strong>线程安全问题</strong>：多个线程共同操作共享数据。使用线程同步来解决线程安全问题。</p><p><strong>线程同步</strong>：当存在多个线程操作共享数据时，需要保证同一时刻只有一个线程在操作共享数据，其他线程必须等到该线程处理完共享数据后，才能进行操作</p><p>面试题：<strong>线程有哪些同步的方法？</strong></p><ul><li>synchronized修饰代码块或者方法</li><li>volatile修饰共享变量</li><li>juc包下的锁（比如Reentrantlock重入锁）</li><li>Atomic原子类（比如AutomicInteger）</li><li>线程安全的并发集合（ConcurrentHashMap）</li></ul><h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><ul><li> synchronized可以保证<strong>在同一个时刻</strong>，<strong>只有一个线程</strong>可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)</li><li>synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能） </li></ul><p><strong>具体用法：</strong></p><ul><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ul><p>具体如下：</p><ul><li>对于实例方法，锁是当前<strong>类的实例对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于静态方法，锁是当前<strong>类的Class对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 对于同步方法块，锁是<strong>synchonized括号里配置的对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对当前实例对象this加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对class对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>synchronized修饰方法和修饰代码块的区别？</strong></p><p>从宏观层面上看有两点：</p><ul><li>锁的范围不同。一个是整个方法中的方法体，一个是一部分代码块，相对来说用代码块的方式更加灵活</li><li>锁的对象不同。修饰方法时，对于静态方法，是把类的class对象作为锁；对于非静态方法，是把类的实例对象作为锁；修饰代码块时，是把括号中传入的对象作为锁。</li></ul><p>从底层原理上来看：</p><ul><li><h2 id="java对象在JVM中的构成"><a href="#java对象在JVM中的构成" class="headerlink" title="java对象在JVM中的构成"></a>java对象在JVM中的构成</h2></li></ul><p>在JVM中，java对象由三部分构成：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。如下图所示：</p><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/SouthEast.png" alt="这里写图片描述"></p><p><strong>对象头：</strong></p><p>HotSpot虚拟机的对象头包括两部分信息：</p><ol><li><strong>Mark Word</strong><br>会记录<strong>对象和锁的有关信息</strong>，比如：<strong>对象的hashCode、分代年龄和锁标记位</strong>，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。</li><li><strong>klass 指针</strong><br>它是一个指向类的数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.</li><li><strong>数组长度（只有数组对象有）</strong><br>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.</li></ol><p><strong>实例数据：</strong>对象真正存储的有效信息，比如我们在java代码中定义对象一些属性值</p><p><strong>对齐填充：</strong>对齐填充并不是必然存在的，相当于是占位符的作用，JVM要求对象的大小必须是8字节的整数倍。而对象头这部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="MarkWord中记录了对象中锁相关信息"><a href="#MarkWord中记录了对象中锁相关信息" class="headerlink" title="MarkWord中记录了对象中锁相关信息"></a>MarkWord中记录了对象中锁相关信息</h3><p>在jdk1.6之前，synchronized被称为<strong>重量锁</strong>，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了<strong>偏向锁和轻量级锁</strong>。</p><p>前面介绍了java对象的构成，我们重点关注对象头中的MarkWord，它记录了锁相关的信息。</p><p>在程序运行期间，MarkWord中存储的数据会随着锁标志位的变化而变化，在64位虚拟机中，不同状态下的组成如下：</p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211014220803850.png" alt="image-20211014220803850" style="zoom:80%;" /><p>其中线程ID表示持有偏向锁线程的ID，Epoch表示偏向锁的时间戳，偏向锁和轻量级锁是在jdk1.6中引入的。</p><h3 id="重量级锁的底部实现原理：Monitor"><a href="#重量级锁的底部实现原理：Monitor" class="headerlink" title="重量级锁的底部实现原理：Monitor"></a>重量级锁的底部实现原理：Monitor</h3><p><strong>synchronized底层原理 = java对象头markword + 操作系统对象monitor：</strong></p><p>在jdk1.6之前，synchronized只能实现重量级锁，synchronized是基于<strong>Monitor对象</strong>来实现重量级锁的，Monitor是操作系统底层的一个对象，使用c++语言编写的，<strong>每个锁都关联一个Monitor对象</strong>，synchronized的加锁释放锁也就是获取和释放Monitor对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分重要的属性</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">//锁计数器</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//锁的重入次数</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">//指向拥有该Monitor的线程地址，即哪个线程拥有Monitor</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzY0NDY4,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><strong>获取Monitor和释放Monitor的流程如下：</strong></p><p>关键字：WaitSet、Owner、EntryList阻塞队列</p><p>我们把synchronized代码中的代码称为临界区代码。</p><ul><li>当多个线程访问同步代码块时，线程t1要执行临界区的代码时，首先会通过synchronized括号中的obj对象的markword指向一个monitor锁对象</li><li>当Thread-1线程持有monitor对象后，就会把monitor中的owner变量设置为当前线程Thread-1，同时count+1，recursions+1</li><li>当另一个线程Thread-2想要执行临界区的代码时，要判断monitor对象的属性Owner是否为null，如果为null，Thread-2线程就获得了锁，可以执行临界区的代码；如果不为null，Thread-2线程就会放入monitor的EntryList阻塞队列中，并处于阻塞状态Blocked。</li><li>当获取锁的线程调用wait（）方法时，则会将owner设置为null，同时count减1，recursions减1，当前线程加入到WaitSet中，等待被唤醒。</li><li>当前线程执行完同步代码块时，会释放monitor(锁)并将owner置为null，同时count-1，recursions-1，当recursions = 0 时，说明当前线程已经释放完了锁，这时会通知EntryList阻塞队列中的线程，唤醒里面阻塞的线程。</li></ul><h3 id="JVM指令分析同步代码块和同步方法"><a href="#JVM指令分析同步代码块和同步方法" class="headerlink" title="JVM指令分析同步代码块和同步方法"></a><strong>JVM指令分析同步代码块和同步方法</strong></h3><p><strong>JVM是如何实现同步代码块和同步方法的呢？</strong></p><p>JVM是通过<strong>获取和释放Monitor对象</strong>来实现代码块同步和方法同步的</p><ul><li><p>同步代码块是通过<strong>monitorenter **指令（获取锁）和</strong>monitorexit**（释放锁）指令来实现的；</p></li><li><p>而同步方法是通过<strong>ACC_SYNCHRONIZED标识符</strong>来隐式的调用monitorenter（获取锁）和monitorexit（释放锁）来实现的。</p></li></ul><p>synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块时，计数器的数量会1，直到计数器的数量为0，就释放这个锁。</p><p>synchronized不可中断性：</p><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会—直阻塞或等待，不可被中断。</p><h2 id="JDK6后对synchronized的优化（还有一篇文章找时间看看）-java中锁升级的过程"><a href="#JDK6后对synchronized的优化（还有一篇文章找时间看看）-java中锁升级的过程" class="headerlink" title="JDK6后对synchronized的优化（还有一篇文章找时间看看）/ java中锁升级的过程"></a>JDK6后对synchronized的优化（还有一篇文章找时间看看）/ java中锁升级的过程</h2><p>看看这篇文章对synchronized几种锁的介绍</p><p><a href="https://blog.csdn.net/qq_42764468/article/details/106603249">https://blog.csdn.net/qq_42764468/article/details/106603249</a></p><h3 id="为什么要优化？"><a href="#为什么要优化？" class="headerlink" title="为什么要优化？"></a><strong>为什么要优化？</strong></h3><p>因为Java虚拟机是通过获得和释放Monitor对象来实现代码块同步和方法同步的，而这个过程需要操作系统从用户态切换到内核态，这个切换成本比较高。</p><p>因此，在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，对synchronized锁的实现进行了大量的优化，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术。锁的状态变成了四种，<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，锁的状态会随着竞争激烈逐渐升级，并且升级方向是不可逆的（<strong>弄明白什么时候会升级？</strong>）</p><p><strong>用户态和内核态是什么？</strong></p><p>用户态和内核态是操作系统的两种cpu状态</p><p>用户态：不能直接调用底层的硬件资源，访问资源受到限制，需要系统调用。</p><p>内核态：操作系统直接操作硬件资源。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><strong>为什么要引入自旋锁？</strong></p><p>线程的阻塞和唤醒需要CPU从用户态转为内核态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。而且很多情况下，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p><strong>自旋锁原理？</strong></p><p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换，从而进入阻塞状态，它们只需要等一等，这个等待的过程我们就叫做自旋，等持有锁的线程释放锁后即可立即获取锁，这样就<strong>避免用户态和内核态切换的消耗</strong>。</p><p>但是我们的线程自旋是需要消耗cpu的，说白了就是让cpu在做无用功，如果一直获取不到锁，那线程也不能一直占用cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。</p><p>如果在自旋等待的最大时间内持有锁的线程仍没有释放锁，那么线程就会停止自旋进入阻塞状态</p><p>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；<br>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><p>适应自旋锁是对自旋锁的改进。它自旋的次数不再是固定的，由上一个线程在这个锁上的自旋时间以及是否获取到了锁来决定的。上一个线程如果自旋成功了，那么下次自旋的次数会更多。因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待的次数更多。反之，如果对于某个锁，很少有线程能够自旋成功的，那么允许自旋等待的次数就会更少甚至会不让自旋。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>JVM编译器在运行时分析发现有些数据不存在竞争，所以就不用加锁浪费性能，于是就通过JVM编译器优化将锁消除。所以锁消除可以介绍毫无意义的请求锁的时间。</p><p>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候<strong>会存在隐形的加锁操作</strong>。比如<strong>StringBuffer的append()方法，Vector的add()方法：</strong></p><p>比如StringBuffer的append方法用了synchronized关键词，它是线程安全的。但我们可能仅在线程内部把StringBuffer当作局部变量使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sBuf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sBuf.append(str1);<span class="comment">// append方法是同步操作</span></span><br><span class="line">        sBuf.append(str2);</span><br><span class="line">        <span class="keyword">return</span> sBuf.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码中createStringBuffer方法中的局部对象sBuf，就只在该方法内的作用域有效，不同线程同时调用createStringBuffer()方法时，都会创建不同的sBuf对象，因此此时的append操作若是使用同步操作，就是白白浪费的系统资源，这时我们可以通过编译器将其优化，将锁消除</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>大部分情况下我们是要让锁的粒度最小化，这样可以减少锁的竞争，增加并发度。</p><p><strong>锁的粗化则是要增大锁的粒度，</strong>因为一系列连续地加锁释放锁操作，可能会导致不必要的性能损耗，为了避免性能损耗，所以引入锁粗化的概念。</p><p>一个例子：比如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把锁放到循环的外面</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>为什么要引入偏向锁？</strong></p><p>很多情况下，锁不存在多线程竞争，总是由同一线程获得，为了让线程获得锁的代价更低，引进了偏向锁。</p><p><strong>概述：</strong></p><p>偏向锁会在对象头MarkWord中存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，以及 ThreadID（代表锁偏向的线程）,就不用反复获取锁释放锁，减轻了性能消耗。</p><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211024153708430.png" alt="image-20211024153708430"></p><p><strong>获取锁的过程</strong></p><ol><li>检测Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li><li>如果为可偏向状态，检测线程ID是否为当前线程ID，如果是就执行同步代码块。</li><li>如果线程ID不为当前线程ID，则通过CAS操作来竞争锁，竞争成功，就将Mark Word的线程ID替换为当前线程ID，执行同步块。</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点时，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li></ol><blockquote><p>通过CAS操作竞争锁是什么意思？</p></blockquote><p><strong>释放锁的过程</strong><br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，<strong>线程是不会主动去释放偏向锁</strong>，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211015104403000.png" alt="64位markword"></p><h3 id="轻量级锁（有点没弄懂和偏向锁的关系）"><a href="#轻量级锁（有点没弄懂和偏向锁的关系）" class="headerlink" title="轻量级锁（有点没弄懂和偏向锁的关系）"></a>轻量级锁（有点没弄懂和偏向锁的关系）</h3><p>轻量级锁是由偏向所升级来的，当一个线程获得偏向锁，另一个线程竞争这把偏向锁，偏向锁就会升级为轻量级锁；</p><p><strong>获取锁的过程</strong></p><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><p><strong>释放锁的过程</strong><br>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>见前面</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;synchronized &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
