<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>pb</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-16T14:15:05.078Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>pb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReentrantLock介绍</title>
    <link href="http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/ReentrantLock%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T08:50:25.000Z</published>
    <updated>2021-10-16T14:15:05.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下</p></blockquote><a id="more"></a><p>Reentranlock 中有一个内部抽象类 Sync 继承自 AbstractQueuedSynchronized （AQS抽象队列同步器），主要是它来实现锁的功能。</p><p> Sync 在 ReentrantLock 中有两种实现类：NonfairSync、FairSync，正好对应了ReentrantLock的非公平锁、公平锁两大类型。Reentranlock 默认实现为非公平锁，在高竞争的条件下有更好的性能。</p><h1 id="synchronized与ReentrantLock的区别（5点）"><a href="#synchronized与ReentrantLock的区别（5点）" class="headerlink" title="synchronized与ReentrantLock的区别（5点）"></a>synchronized与ReentrantLock的区别（5点）</h1><p>共同点：都是可重入锁、用来保证线程同步。</p><p>① <strong>底层实现上来说</strong></p><p>​    synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来实现</p><p>​    ReentrantLock 是JUC.lock包下的一个类，是<strong>API层面</strong>的锁。</p><p>② <strong>是否可手动释放：</strong></p><p>​    synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用；</p><p>​    ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。</p><p>③ <strong>是否可中断</strong></p><p>​    synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成；</p><p>​    ReentrantLock可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法（超时没有获得锁就中断）或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p><p>④ <strong>是否公平锁</strong></p><p>​    synchronized为非公平锁 </p><p>​    ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。</p><p>⑤ <strong>锁是否可绑定条件Condition</strong></p><p>​    synchronized不能绑定；     </p><p>​    ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的<strong>精确唤醒</strong>，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Reentrantlock是并发包中一个可重入的锁，位于java.util.concurrent.locks包下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java中几种锁的介绍</title>
    <link href="http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2021/10/16/java%E4%B8%AD%E5%87%A0%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-10-16T07:25:38.000Z</published>
    <updated>2021-10-16T08:42:40.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java中一些锁的介绍</p></blockquote><a id="more"></a><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当第二个线程想拿这个数据的时候，第二个线程会一直堵塞，直到第一个释放锁，他拿到锁后才可以访问。传统的数据库里面就用到了这种锁机制，例如：行锁，表锁，读锁，写锁，都是在操作前先上锁。<strong>java中的synchronized的实现也是一种悲观锁。</strong></p><p><strong>乐观锁</strong>：乐观锁概念为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有修改过数据，乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。在Java中java.util.concurrent.<strong>atomic包下面的Atomic操作类就是使用了乐观锁</strong>，<strong>而Atomic操作类的底层正是用到了“CAS机制”。</strong></p><p>采用悲观锁的一些问题（采用synchronized的一些问题）：</p><ul><li>在多线程竞争下，多次加锁释放锁会造成性能损耗</li><li>如果一个线程持有锁，其他的线程就都会阻塞，等待持有锁的线程释放锁。</li></ul><p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。</p><p>乐观锁就是：每次不加锁而是假设没有并发冲突去操作同一变量，如果有并发冲突导致失败，则重试直至成功。</p><p>主要就是两个步骤：<strong>冲突检测和数据更新</strong>。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，先来后到。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><p>简单来说就是：</p><p><strong>公平锁</strong> ：是指多个线程按照申请锁的顺序来获取锁，类回排队打饭先来后到。<br><strong>非公平锁</strong> ：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</p><p><strong>什么是饥饿？</strong></p><p>优先级高的线程能够插队并优先执行，这样如果<strong>优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行，这就是饥饿。</strong>当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源。</p><p>ReentrantLock中就有相关公平锁，非公平锁的实现。默认是非公平锁，如果为设置为true就是公平锁。更深入的需要探寻其中的源码实现原理</p><h2 id="可重入锁和非重入锁"><a href="#可重入锁和非重入锁" class="headerlink" title="可重入锁和非重入锁"></a>可重入锁和非重入锁</h2><p>可重入锁：当前线程获取该锁后再次获取不会被阻塞。</p><p>用一个简单的例子来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setA</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setB</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说A和B都是两个synchronized修饰的方法，在方法A中调用了方法B；有一个线程获取到了锁执行方法A，然后在执行方法B的时候就自动获取锁，去执行方法B；</p><p><strong>可重入锁可以避免线程死锁</strong>：</p><p>假如Synchronized不是可重入锁；那么该线程获取到执行A方法所需要的锁之后开始执行A方法；但是在执行过程中遇到了方法B；由于是不可重入锁；B方法也是被Synchronized关键字修饰；所以执行B方法也需要获取锁；但是此时A方法代码还未执行完成，继续占有锁；B方法就获取不到锁，被阻塞；A方法迟迟执行不完成，所以也就一直不释放锁；因此；就产生了死锁</p><p>synchronized和ReentrantLock都是可重入锁；当然ReentrantLock还可以设置成为公平锁，也就是不可重入锁；</p><p>不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;java中一些锁的介绍&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>CAS和Atomic相关</title>
    <link href="http://example.com/2021/10/16/CAS%E5%92%8CAtomic%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/16/CAS%E5%92%8CAtomic%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-16T01:05:18.000Z</published>
    <updated>2021-10-16T14:27:33.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>java.util.concurrent.atomic 和 java.util.concurrent.locks 是两个很重要的包</p></blockquote><a id="more"></a><h2 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2><p>这篇文章通俗易懂的解释了CAS操作  <a href="https://www.sohu.com/a/314272265_120104204">什么是CAS机制，通俗易懂大白话版</a></p><h3 id="什么是乐观锁与悲观锁？"><a href="#什么是乐观锁与悲观锁？" class="headerlink" title="什么是乐观锁与悲观锁？"></a><strong>什么是乐观锁与悲观锁？</strong></h3><p><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样当第二个线程想拿这个数据的时候，第二个线程会一直堵塞，直到第一个释放锁，他拿到锁后才可以访问。传统的数据库里面就用到了这种锁机制，例如：行锁，表锁，读锁，写锁，都是在操作前先上锁。<strong>java中的synchronized的实现也是一种悲观锁。</strong></p><p><strong>乐观锁</strong>：乐观锁概念为，每次拿数据的时候都认为别的线程不会修改这个数据，所以不会上锁，但是在更新的时候会判断一下在此期间别的线程有没有修改过数据，乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。在Java中java.util.concurrent.<strong>atomic包下面的Atomic操作类就是使用了乐观锁</strong>，<strong>而Atomic操作类的底层正是用到了“CAS机制”。</strong></p><p>采用悲观锁的一些问题（采用synchronized的一些问题）：</p><ul><li>在多线程竞争下，多次加锁释放锁会造成性能损耗</li><li>如果一个线程持有锁，其他的线程就都会阻塞，等待持有锁的线程释放锁。</li></ul><p>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。</p><p>乐观锁就是：每次不加锁而是假设没有并发冲突去操作同一变量，如果有并发冲突导致失败，则重试直至成功。</p><p>主要就是两个步骤：<strong>冲突检测和数据更新</strong>。其实现方式有一种比较典型的就是 Compare and Swap ( CAS )。</p><h3 id="CAS概述"><a href="#CAS概述" class="headerlink" title="CAS概述"></a>CAS概述</h3><p><strong>乐观锁是一种思想，CAS只是这种思想的一种实现方式。</strong></p><p>相比于synchronized这种堵塞算法，CAS是非堵塞算法的一种常见实现。所以JUC在性能上有了很大的提升。</p><p>CAS即Compare And Swap，翻译成中文即比较并替换。Java中可以通过CAS操作来保证原子性，原子性就是一系列操作，要么全部完成，要么失败，不能被中断。</p><p>CAS操作包括三个操作数：需要读写的内存地址(V)、预期原值(A)、新值(B)。</p><p><strong>算法流程</strong>：比较A和V的值，如果相等，将B值赋值给A，如果不相等说明有其他线程对该变量做了更新，自旋或者不做操作</p><p>当多个线程同时操作一个共享变量时，只有一个线程可以对变量进行成功更新，其他线程均会失败，但是失败并不会被挂起，进行再次尝试，也就是自旋。Java中的自旋锁就是利用CAS来实现的。</p><h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><ul><li><strong>ABA问题</strong></li></ul><p>比如说有两个线程，线程1和线程2。线程1获取了内存V中的值A，要讲它修改为B；这时候线程2抢在线程1之前，将内存V中的值A修改为了B，接着又将B修改为了A；这时线程1发现内存V中的值还是A，于是线程1仍然会更新成功，将A变为B；</p><p>这样看起来好像没问么问题？但是。。</p><p><strong>ABA问题解决方案：加上版本号</strong></p><p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p><p>给变量加上一个版本号，每次变量更新的时候就把版本号加1，这样即使内存V中的值从A-&gt;B-&gt;A，版本号也发生了变化，所以我们上一个例子中，即便线程1获得的值A和内存中的值相等，但是版本号不一样，所以线程1更新失败。基于CAS的乐观锁也是这个实现原理。</p><ul><li><strong>循环时间过长导致开销太大</strong></li></ul><p>CAS自旋不成功，就一直循环执行，，如果长时间不成功，会给CPU带来非常大的执行开销</p><ul><li><strong>只能保证一个共享变量的原子操作</strong></li></ul><p>但如果对多个共享变量进行操作时，CAS则无法保证操作的原子性，这时候就需要用锁了。</p><h3 id="CAS和synchronized的使用情景"><a href="#CAS和synchronized的使用情景" class="headerlink" title="CAS和synchronized的使用情景　　　"></a>CAS和synchronized的使用情景　　　</h3><p>1.对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</p><p>2.对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p><h3 id="分析atomic包下的原子操作类AtomicInteger（待解决）"><a href="#分析atomic包下的原子操作类AtomicInteger（待解决）" class="headerlink" title="分析atomic包下的原子操作类AtomicInteger（待解决）"></a>分析atomic包下的原子操作类AtomicInteger（待解决）</h3><p>我们看一下AtomicInteger类中常用的自增方法incrementAndGet，相当于i++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">            <span class="keyword">int</span> current = get();  </span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))  </span><br><span class="line">                <span class="keyword">return</span> current;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/JUC%E5%8C%85%E4%B8%8Batomic%E5%92%8Clocks%E7%9B%B8%E5%85%B3/webp.webp" alt="img"></p><p>实现CAS操作的应该是getAndAddInt（）方法，</p><p>核心实现是先获取当前值和目标值（也就是value+1），如果<code>compareAndSet(current, next)</code> 返回成功则该方法返回目标值。那么compareAndSet是做什么的呢？理解这个方法我们需要引入CAS操作。</p><p>AtomicInteger 中的CAS操作就是<code>compareAndSet()</code>，其作用是每次从<strong>内存中根据内存偏移量（<code>valueOffset</code>）取出数据</strong>，将取出的值跟expect 比较，如果数据一致就把内存中的值改为update。</p><p>这样使用CAS就保证了原子操作。其余几个方法的原理跟这个相同，在此不再过多的解释。</p><p>没看AtomicInteger 源码之前，我认为其内部是用<code>synchronized</code> 来实现的原子操作。查阅资料后发现<code>synchronized</code> 会影响性能，因为Java中的<code>synchronized</code> 锁是独占锁，虽然可以实现原子操作，但是这种实现方式的并发性能很差。</p><p><strong>1. java语言CAS底层如何实现？</strong></p><p><strong>利用unsafe提供的原子性操作方法。</strong></p><p>总结一下，AtomicInteger 中主要实现了整型的原子操作，防止并发情况下出现异常结果，其内部主要依靠JDK 中的unsafe 类操作内存中的数据来实现的。volatile 修饰符保证了value在内存中其他线程可以看到其值得改变。CAS操作保证了AtomicInteger 可以安全的修改value 的值。</p><h2 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h2><p>Atomic原子类位于java.util.concurrent.atomic包下，<strong>原子类就是具有原子操作特征的类</strong>。原子操作特征是指：多个操作要么都成功要么都失败，不会被其他线程干扰。</p><p>四种原子类：基本类型（3个）、数组类型（3个）、引用类型、原子更新字段类</p><p><img src="/images/JUC%E5%8C%85%E4%B8%8Batomic%E5%92%8Clocks%E7%9B%B8%E5%85%B3/image-20211016113025301.png" alt="image-20211016113025301"></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS的全称是AbstractQueuedsynchronizer，抽象队列同步器，它是Java并发用来构建锁和其他同步组件的基础框架。</p><p>变量+一个队列</p><p>ReentrantLock<br>CountDownLatch<br>ReentrantReadWriteLock<br>Semaphore                                   这四个是什么意思？</p><p>锁和同步器区别？</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent.atomic 和 java.util.concurrent.locks 是两个很重要的包&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>volatile深入理解</title>
    <link href="http://example.com/2021/10/15/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/15/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-15T11:47:13.000Z</published>
    <updated>2021-10-16T14:05:38.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>volatile</p></blockquote><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>介绍并发编程的三大特性：原子性、可见性、有序性</p><p>volatile不具有原子性，具有可见性和有序性</p><p>其底层实现原理也是围绕这两点来展开的</p><p>volatile主要的作用包括两点：</p><p>1.<strong>保证线程间变量的可见性。</strong>（可见性）</p><p>2.<strong>禁止CPU进行指令重排序。</strong>（有序性）</p><h2 id="volatile实现可见性原理"><a href="#volatile实现可见性原理" class="headerlink" title="volatile实现可见性原理"></a>volatile实现可见性原理</h2><p>首先介绍一下JMM模型</p><p>可见性问题是由Java内存模型中的工作内存和主内存之间的值不一致所导致</p><p>例如上面所说线程1访问自己工作内存A中的值时，但此时主内存的该值已经被线程2所修改，所以线程1所访问到的值是一个脏数据。</p><p>那如何解决这种问题呢？用volatile修饰共享变量</p><p>可以发现通过volatile修饰的变量，生成汇编指令时会比普通的变量多出一个Lock指令，这个Lock指令就是volatile关键字可以保证内存可见性的关键，它主要有两个作用：</p><ul><li>将当前处理器缓存的数据刷新到主内存。</li><li>刷新到主内存时会使得其他处理器缓存的该内存地址的数据无效。</li></ul><p>因此其他线程会直接从主内存中读取数据，</p><h2 id="volatile实现有序性原理（内存屏障没看懂）"><a href="#volatile实现有序性原理（内存屏障没看懂）" class="headerlink" title="volatile实现有序性原理（内存屏障没看懂）"></a>volatile实现有序性原理（内存屏障没看懂）</h2><blockquote><p>前面提到的指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但在多线程程序中可能导致程序的运行结果不正确，那volatile是如何解决这一问题的呢？</p></blockquote><p>为了实现volatile的内存语义，编译器在生成字节码时会通过插入内存屏障来禁止指令重排序。</p><p>内存屏障：内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。</p><p>java虚拟机把内存屏障分为4类：</p><img src="/images/volatile%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211015223529379.png" alt="内存屏障" style="zoom:80%;" /><p>Java内存模型对编译器指定的volatile重排序规则为：</p><ul><li><p>当第一个操作是volatile读时，无论第二个操作是什么都不能进行重排序。</p></li><li><p>当第二个操作是volatile写时，无论第一个操作是什么都不能进行重排序。</p></li><li><p>当第一个操作是volatile写，第二个操作为volatile读时，不能进行重排序。</p></li></ul><p>根据volatile重排序规则，Java内存模型采取的是保守的屏障插入策略，volatile写是在前面和后面分别插入内存屏障，volatile读是在后面插入两个内存屏障，具体如下：</p><h2 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别"></a>volatile与synchronized的区别</h2><ul><li><p>volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性。</p></li><li><p>volatile 关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。</p></li><li><p>volatile关键字只能用于变量，synchronized关键字用来修饰方法以及代码块。</p></li><li><p>volatile 关键字不能保证原子性，synchronized关键字能保证原子性</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;volatile&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java线程池相关</title>
    <link href="http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/10/15/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/</id>
    <published>2021-10-15T03:38:17.000Z</published>
    <updated>2021-10-16T14:44:39.209Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线程池相关</p></blockquote><a id="more"></a><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a><strong>什么是线程池？</strong></h2><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。</p><p>假如我们要处理多线程的任务，如果每个请求都创建一个线程去处理，然后执行完任务后要销毁线程，我们可以使用线程池减少创建和销毁线程的次数，提高服务器的性能</p><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a><strong>为什么要使用线程池？</strong></h2><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程太耗费性能，于是我们可以使用线程池技术把创建和销毁的线程的过程去掉，直接从线程池中取出线程</p><h2 id="线程池有什么作用？"><a href="#线程池有什么作用？" class="headerlink" title="线程池有什么作用？"></a><strong>线程池有什么作用？</strong></h2><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><h2 id="说说几种常见的线程池及使用场景"><a href="#说说几种常见的线程池及使用场景" class="headerlink" title="说说几种常见的线程池及使用场景"></a><strong>说说几种常见的线程池及使用场景</strong></h2><p><strong>java.util.concurrent.Executors类为我们提供了创建线程池的简便方法。</strong></p><p>使用Executors可以创建我们常用的四种线程池：</p><p>（1）newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。不设上限，提交的任务将立即执行。</p><p>（2）newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>（3）newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>（4）newSingleThreadExecutor 创建一个单线程化的线程池执行任务。</p><blockquote><p>这几种线程池的源码都调用了ThreadPoolExecutor的构造函数</p></blockquote><p><strong>Executors的坏处</strong></p><p>正常来说，我们<strong>不应该使用这种方式创建线程池</strong>，应该使用<strong>ThreadPoolExecutor</strong>来创建线程池。Executors创建的线程池也是调用的ThreadPoolExcutor的构造函数。通过源码可以看出：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015164333196.png" alt="newFixedThreadPool"></p><p>我们也看到了这里面的LinkedBlockingQueue并没有指定队列的大小，是一个无界队列，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致OOM。所以我们一般要使用ThreadPoolExecutor这种方式来创建线程池。</p><p><strong>创建线程池的正确姿势：</strong></p><p>避免使用Executors创建线程池，主要是避免使用其中的默认实现，那么我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池。在创建的同时，给BlockQueue指定容量就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>或者是使用开源类库：开源类库，如apache和guava等。</p><p><strong>五种线程池的使用场景</strong></p><p>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</p><p>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</p><p>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</p><p>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h2 id="线程池中的几种重要的参数（7个）"><a href="#线程池中的几种重要的参数（7个）" class="headerlink" title="线程池中的几种重要的参数（7个）"></a><strong>线程池中的几种重要的参数</strong>（7个）</h2><p><strong>ThreadPoolExecutors构造函数中7个重要的参数：</strong></p><ul><li><p>corePoolSize就是线程池中的核心线程数量，即使这些线程处理空闲状态，他们也不会被销毁</p></li><li><p>maximumPoolSize就是线程池中可以容纳的最大线程的数量</p></li><li><p>keepAliveTime，非核心线程可以保留的最长的空闲时间，就是线程池中除了核心线程之外的线程在空闲状态下最长能存活的时间，超过这个时间就会被销毁</p></li><li><p>util，表示最长存活时间的单位。</p></li><li><p>workQueue，就是等待队列，当核心线程数满了后其他请求就储存在任务队列中，等待被执行，按照FIFIO原则（先进先出）。</p></li><li><p>threadFactory，就是创建线程的线程工厂。</p></li><li><p>handler,是一种拒绝策略，当线程池中线程数量满了后，拒绝执行某些任务。（4种内置的拒绝策略）</p></li></ul><p><strong>线程池提交任务时的执行流程：</strong></p><p>当我们创建好线程池后，要向线程池提交任务时：</p><p>会首先判断线程池中的线程数是否大于设置的核心线程数，如果不大于，就创建一个核心线程来执行任务。</p><p>如果大于核心线程数，就会判断缓冲队列是否满了，如果没有满，则放入队列，等待线程空闲时执行任务。</p><p>如果队列已经满了，则判断是否达到了线程池设置的最大线程数，如果没有达到，就创建新线程来执行任务。</p><p>如果已经达到了最大线程数，则执行指定的拒绝策略。</p><p><strong>所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。</strong></p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015180107031.png" alt="线程池提交任务时的执行流程"></p><p>举个例子：corePoolSize为2，maximumPoolSize为6，workQueue大小为5；</p><p><strong>第一步</strong>，任务0、1提交时，创建核心线程并执行<br><strong>第二步</strong>，任务2、3、4、5、6提交时，将其放在工作队列（工作队列能容纳5个线程）<br><strong>第三步</strong>，任务7、8、9、10提交时，创建线程并执行，直到池子满了（工作队列也满了，多一个线程就创建一个新线程，但总线程数不能大于maximumPoolSize）<br><strong>第四步</strong>，任务11、12、13、14、15被拒绝策略拒绝（什么时候被拒绝策略拒绝呢？当请求线程数&gt;工作队列容量+ maximumPoolSize时）<br><strong>第五步</strong>，执行缓存队列中的任务2、3、4、5、6</p><h2 id="线程池常用的阻塞队列（没有很理解）"><a href="#线程池常用的阻塞队列（没有很理解）" class="headerlink" title="线程池常用的阻塞队列（没有很理解）"></a>线程池常用的阻塞队列（没有很理解）</h2><ol><li><p><strong>LinkedBlockingQueue</strong></p><p>LinkedBlockingQueue，它的容量是 Integer.MAX_VALUE，为 2^31 -1 ，是一个非常大的值，可以认为是无界队列。</p><p>这里需要注意，FixedThreadPool 和 SingleThreadExecutor 线程池的线程数是固定的，其中maximumPoolSize这个参数是没有用的，因为阻塞队列根本就放不满，所以线程池只会创建核心线程数量的线程</p></li><li><p><strong>SynchronousQueue</strong><br> 第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。<br> 我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</p></li><li><p><strong>DelayedWorkQueue</strong><br> 第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p></li></ol><p>下面是四种线程池对应的阻塞队列：</p><p><img src="/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3/image-20211015181738391.png" alt="image-20211015181738391"></p><h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a><strong>线程池的拒绝策略</strong></h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当线程池中最大线程数满了后，我们需要采取拒绝策略。</span><br><span class="line">在ThreadPoolExecutor中已经包含四种处理策略，默认为AbortPolicy策略，即丢弃任务并抛出异常。</span><br></pre></td></tr></table></figure><ul><li><p>AbortPolicy策略：丢弃任务并抛出RejectedExecutionException异常。</p></li><li><p>DiscardPolicy策略：丢弃任务，但是不抛出异常。</p></li><li><p>DiscardOlddestPolicy策略： 该策略将丢弃最老的一个请求，也就是工作队列中最前面的一个请求，并再次提交当前任务。</p></li><li><p>CallerRunsPolicy 策略：如果线程池未关闭，由调用线程（即提交任务的线程）执行此该请求</p></li></ul><p><strong>自定义拒绝策略</strong>：除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，只需实现RejectedExecutionHandler接口即可。</p><h2 id="线程池的执行任务和关闭"><a href="#线程池的执行任务和关闭" class="headerlink" title="线程池的执行任务和关闭"></a>线程池的执行任务和关闭</h2><p><strong>execute和submit用来执行线程池中的任务</strong></p><ul><li>execute（）方法用于不需要提交返回值的任务</li><li>submit（）方法用于需要提交返回值的任务。</li></ul><p><strong>线程池的关闭</strong></p><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><ul><li><p>shutdownNow（）方法的解释是：线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。</p></li><li><p>shutdown（）方法的解释是：线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。</p></li></ul><p><strong>初始化线程池时线程数的选择</strong></p><p>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</p><p>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</p><p>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;线程池相关&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized深入理解</title>
    <link href="http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/10/13/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-13T01:55:05.000Z</published>
    <updated>2021-10-16T14:53:34.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>synchronized </p></blockquote><a id="more"></a><h2 id="线程安全问题和线程同步"><a href="#线程安全问题和线程同步" class="headerlink" title="线程安全问题和线程同步"></a>线程安全问题和线程同步</h2><p>线程安全问题：多个线程共同操作共享数据</p><p>线程同步：当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完共享数据后，才能进行操作</p><p>面试题：线程有哪些同步的方法？</p><ul><li><p>synchronized修饰代码块或者方法</p></li><li><p>volatile修饰共享变量</p></li><li><p>juc包下的锁（比如Reentrantlock重入锁）</p></li><li><p>Atomic原子类（比如AutomicInteger）</p></li></ul><h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><ul><li> synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)</li><li>synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能） </li></ul><p><strong>具体用法：</strong></p><ul><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ul><p>具体如下：</p><ul><li>对于普通同步方法，锁是当前<strong>实例对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于静态同步方法，锁是当前<strong>类的Class对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 对于同步方法块，锁是<strong>synchonized括号里配置的对象。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对当前实例对象this加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodFour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对class对象加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>synchronized修饰方法和修饰代码块的区别？</strong></p><p>主要是锁不同：</p><ul><li><p>修饰方法时，对于静态方法，是把 class 作为锁；对于非静态方法，是把 this 对象当做锁；</p></li><li><p>修饰代码块时，是把任何对象作为锁，如果锁对象为空，会抛出 NullPointerException，但是修饰方法不会；</p></li><li><p>在锁的作用区域上，修饰方法时是整个方法体；而修饰代码块时只有对应的代码块。修饰代码块更加灵活让细粒度更小</p></li></ul><h2 id="java对象在JVM中的构成"><a href="#java对象在JVM中的构成" class="headerlink" title="java对象在JVM中的构成"></a>java对象在JVM中的构成</h2><p>在JVM中，java对象由三部分构成：对象头、实例数据和对齐填充。如下图所示：</p><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/SouthEast.png" alt="这里写图片描述"></p><p><strong>对象头：</strong></p><p>HotSpot虚拟机的对象头包括两部分信息：</p><ol><li>Mark Word<br>会记录对象和锁的有关信息，比如：存储对象的hashCode、分代年龄和锁标记位，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。</li><li>klass 指针<br>它是一个指向类的数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.</li><li>数组长度（只有数组对象有）<br>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.</li></ol><p><strong>实例数据：</strong>对象真正存储的有效信息，比如我们在java代码中定义对象一些属性值</p><p><strong>对齐填充：</strong>对齐填充并不是必然存在的，相当于是占位符的作用，JVM要求对象的大小必须是8字节的整数倍。而对象头这部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><h3 id="MarkWord中记录了对象中锁相关信息"><a href="#MarkWord中记录了对象中锁相关信息" class="headerlink" title="MarkWord中记录了对象中锁相关信息"></a>MarkWord中记录了对象中锁相关信息</h3><p>在jdk1.6之前，synchronized被称为<strong>重量锁</strong>，在jdk1.6中，为了减少获得锁和释放锁带来的性能开销，引入了<strong>偏向锁和轻量级锁</strong>。</p><p>前面介绍了java对象的构成，我们重点关注对象头中的MarkWord，它记录了锁相关的信息。</p><p>在程序运行期间，MarkWord中存储的数据会随着锁标志位的变化而变化，在64位虚拟机中，不同状态下的组成如下：</p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211014220803850.png" alt="image-20211014220803850" style="zoom:80%;" /><p>其中线程ID表示持有偏向锁线程的ID，Epoch表示偏向锁的时间戳，偏向锁和轻量级锁是在jdk1.6中引入的。</p><h3 id="重量级锁的底部实现原理：Monitor"><a href="#重量级锁的底部实现原理：Monitor" class="headerlink" title="重量级锁的底部实现原理：Monitor"></a>重量级锁的底部实现原理：Monitor</h3><p><strong>synchronized底层原理 = java对象头markword + 操作系统对象monitor：</strong></p><p>在jdk1.6之前，synchronized只能实现重量级锁，Java虚拟机是基于<strong>Monitor对象</strong>来实现重量级锁的，<strong>每个锁都关联一个Monitor对象</strong>，在Hotspot虚拟机中，Monitor是由ObjectMonitor实现的，其源码用C++语言编写的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分重要的属性</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>;  <span class="comment">//锁计数器</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//锁的重入次数</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">//指向拥有该Monitor的线程地址，即哪个线程拥有Monitor</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzY0NDY4,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><strong>获取Monitor和释放Monitor的流程如下：</strong></p><p>关键字：WaitSet、Owner、EntryList阻塞队列</p><p>我们把synchronized代码中的代码称为临界区代码。</p><ul><li>当多个线程访问同步代码块时，线程t1要执行临界区的代码时，首先会通过synchronized括号中的obj对象的markword指向一个monitor锁对象</li><li>当Thread-1线程持有monitor对象后，就会把monitor中的owner变量设置为当前线程Thread-1，同时count+1，recursions+1</li><li>当另一个线程Thread-2想要执行临界区的代码时，要判断monitor对象的属性Owner是否为null，如果为null，Thread-2线程就获得了锁，可以执行临界区的代码；如果不为null，Thread-2线程就会放入monitor的EntryList阻塞队列中，并处于阻塞状态Blocked。</li><li>当获取锁的线程调用wait（）方法时，则会将owner设置为null，同时count减1，recursions减1，当前线程加入到WaitSet中，等待被唤醒。</li><li>当前线程执行完同步代码块时，会释放monitor(锁)并将owner置为null，同时count-1，recursions-1，当recursions = 0 时，说明当前线程已经释放完了锁，这时会通知EntryList阻塞队列中的线程，唤醒里面阻塞的线程。</li></ul><h3 id="JVM指令分析同步代码块和同步方法"><a href="#JVM指令分析同步代码块和同步方法" class="headerlink" title="JVM指令分析同步代码块和同步方法"></a><strong>JVM指令分析同步代码块和同步方法</strong></h3><p><strong>JVM是如何实现同步代码块和同步方法的呢？</strong></p><p>Java虚拟机是通过获取和释放Monitor对象来实现代码块同步和方法同步的</p><p>同步代码块是通过monitorenter（获取锁）和monitorexit（释放锁）指令来实现的；</p><p>而同步方法是通过ACC_SYNCHRONIZED标识符来隐式的调用monitorenter（获取锁）和monitorexit（释放锁）来实现的。</p><p>synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块时，计数器的数量会1，知道计数器的数量为0，就释放这个锁。</p><p>synchronized不可中断性：</p><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会—直阻塞或等待，不可被中断。</p><h2 id="JDK6后对synchronized的优化（还有一篇文章找时间看看）-java中锁升级的过程"><a href="#JDK6后对synchronized的优化（还有一篇文章找时间看看）-java中锁升级的过程" class="headerlink" title="JDK6后对synchronized的优化（还有一篇文章找时间看看）/ java中锁升级的过程"></a>JDK6后对synchronized的优化（还有一篇文章找时间看看）/ java中锁升级的过程</h2><p>看看这篇文章对synchronized几种锁的介绍</p><p><a href="https://blog.csdn.net/qq_42764468/article/details/106603249">https://blog.csdn.net/qq_42764468/article/details/106603249</a></p><h3 id="为什么要优化？"><a href="#为什么要优化？" class="headerlink" title="为什么要优化？"></a><strong>为什么要优化？</strong></h3><p>因为Java虚拟机是通过获得和释放Monitor对象来实现代码块同步和方法同步的，而这个操作会带来性能消耗</p><p>因此，在JDK1.6中，为了减少获得锁和释放锁带来的性能消耗，对锁的实现进行了大量的优化，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术。锁的状态变成了四种，<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，锁的状态会随着竞争激烈逐渐升级，并且膨胀方向不可逆的（<strong>弄明白什么时候会升级？</strong>）</p><blockquote><p>获得和释放Monitor是依靠底层操作系统的Mutex Lock来实现的，操作系统实现线程之间的切换需要从用户态转换到内核态，这个切换成本比较高，对性能影响较大。</p></blockquote><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p><strong>为什么要引入自旋锁？</strong></p><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p><strong>何谓自旋锁？</strong></p><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。<br>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。<br>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；<br>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public void vectorTest()&#123;</span><br><span class="line">        Vector&lt;String&gt; vector &#x3D; new Vector&lt;String&gt;();</span><br><span class="line">        for(int i &#x3D; 0 ; i &lt; 10 ; i++)&#123;</span><br><span class="line">            vector.add(i + &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(vector);</span><br><span class="line">    &#125;</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。<br>在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(string[] args)</span> </span>&#123;</span><br><span class="line">stringBuffer sb = <span class="keyword">new</span> stringBuffer(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">sb. append (<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system. out. println(sb. tostring());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是 粗化？JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放到这串操作的外面，这样只需要加一次锁即可。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>背景：</strong></p><p>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p><p><strong>概述：</strong></p><p>偏向锁会在对象头MrkWord中存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查锁标志位（01）、是否为偏向锁（1代表是偏向锁）、以及 ThreadID（代表锁偏向的线程）,就不用反复获取锁释放锁。</p><p>适用于只<strong>有一个线程</strong>执行同步块时反复获得同一把锁，没有多线程竞争的情况。</p><p><strong>过程：</strong></p><p><strong>获取锁</strong></p><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><p><strong>释放锁</strong><br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，<strong>线程是不会主动去释放偏向锁</strong>，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><p><img src="/images/synchronized%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/image-20211015104403000.png" alt="64位markword"></p><h3 id="轻量级锁（有点没弄懂和偏向锁的关系）"><a href="#轻量级锁（有点没弄懂和偏向锁的关系）" class="headerlink" title="轻量级锁（有点没弄懂和偏向锁的关系）"></a>轻量级锁（有点没弄懂和偏向锁的关系）</h3><p><strong>获取锁</strong></p><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li><li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</li></ol><p><strong>释放锁</strong><br>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>见前面</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;synchronized &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>java并发基础知识</title>
    <link href="http://example.com/2021/10/12/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/10/12/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-10-12T01:20:10.000Z</published>
    <updated>2021-10-16T14:18:59.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前写过好几篇多线程相关的，不过总差点意思</p></blockquote><a id="more"></a><p><strong>进程与线程相关</strong></p><p>1.什么是进程（操作系统资源分配的基本单位）？什么是线程（处理器任务调度的基本单位）（从1.两个基本单位 2.轻量级进程、包含多个线程 3.JVM内存结构共享资源方面）</p><p>进程和线程的区别</p><p>JVM内存结构分为5个部分，每个进程之间这些部分是独立的，一个进程之间的线程共享三部分</p><p>即每个进程所包含的多个线程共享进程的堆和方法区，并且具备私有的虚拟机栈、本地方法栈、程序计数器，如图所示，假设某个进程包含三个线程。</p><p>面试题：为什么有了进程还要有线程呢？</p><p>从进程的缺点出发，进程在同一时刻只能做一件事，如果执行的过程中被阻塞，那么有些资源就得不到执行，</p><p>线程可以将进程的任务更细粒化，提高并发性。</p><p>什么是协程？</p><p>一个线程也可以包含多个协程，<strong>线程是操作系统调度，协程是用户调度</strong>，协程是一个函数</p><hr><p>2.并发（一个时间段多个进程时间片轮转）和并行（一个时刻多个）的区别</p><p>3.多线程的优缺点（为什么使用多线程、多线程会引发什么问题）</p><p>（优点提高cpu的利用率，缺点上下文切换影响多线程执行速度、死锁、）</p><p>线程上下文切换</p><h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><p>java中线程分为两种类型：<strong>用户线程</strong>和<strong>守护线程</strong>。通过Thread.setDaemon(false)设置为用户线程；通过Thread.setDaemon(true)设置为守护线程。如果不设置次属性，默认为用户线程。</p><p>用户线程：平时使用到的线程均为用户线程。<br>守护线程：用来服务用户线程的线程，例如垃圾回收线程。</p><p>用户线程和守护线程的区别：</p><p>1.主线程结束后用户线程还会继续运行，JVM存活；</p><p>2.如果没有用户线程，都是守护线程，那么JVM结束，进而守护线程也会退出</p><p><strong>总结：</strong></p><ul><li>java中的线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li><li>程序中的所有的用户线程结束之后，不管守护线程处于什么状态，java虚拟机都会自动退出</li><li>调用线程的实例方法setDaemon()来设置线程是否是守护线程（true为守护线程，false为用户线程）</li><li>setDaemon()方法必须在线程的start()方法之前调用，在后面调用会报异常，并且不起效</li><li>线程的daemon默认值和其父线程一样</li></ul><h2 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h2><p>六个状态：新建(new)、运行(runnable)、阻塞(block)、等待(waiting)、超时等待(time_waiting)、终止(terminated)。</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110744753.png" alt="image-20211012110744753"></p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110853349.png" alt="image-20211012110853349"></p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211012110906205.png" alt="image-20211012110906205"></p><h2 id="创建线程有哪几种方法？"><a href="#创建线程有哪几种方法？" class="headerlink" title="创建线程有哪几种方法？"></a>创建线程有哪几种方法？</h2><p>创建多线程常见的四种方法：</p><ul><li>继承Thread类创建线程</li><li>实现Runnable接口创建线程</li><li>使用callable和Future创建线程</li><li>使用线程池创建线程</li></ul><p><strong>继承Thread类创建线程</strong>，首先继承Thread类，重写run（）方法，在主函数中调用子类实实例的start（）方法。</p><p><strong>实现Runnable接口创建线程</strong>：1.实现Runnable接口，重写run（）方法；2.将这个类的实例对象作为参数创建Thread对象3.调用Thread对象的start（）方法。</p><p><strong>使用Callable和Future创建线程</strong>：1.实现Callable接口，重写call（）方法<br>2.将这个类的实例对象作为参数创建FutureTask对象。3.以FutureTask对象作为参数创建Thread对象。4.调用Thread对象的start（）方法。</p><p><strong>使用线程池创建线程</strong></p><h2 id="Runnable和callable的区别"><a href="#Runnable和callable的区别" class="headerlink" title="Runnable和callable的区别"></a>Runnable和callable的区别</h2><p>相同点：两者都需要调用Thread.start()启动线程；</p><p>不同点：是否有返回值、是否能抛出异常</p><p>1、两者最大的不同点是：实现Callable接口的任务线程有返回值；Runnable接口的任务线程不能返回结果；<br>2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的不可以</p><h2 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h2><p>1.线程中的具体任务的执行是通过run（）来实现的，而线程的启动是通过start（）方法执行的。<br>2.run（）方法可以重复调用，start（）方法只能调用一次</p><h2 id="为什么调用start-方法时会执行run-方法，而不直接执行run-方法？"><a href="#为什么调用start-方法时会执行run-方法，而不直接执行run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，而不直接执行run()方法？"></a>为什么调用start()方法时会执行run()方法，而不直接执行run()方法？</h2><p>总结：调用start（）方法方可启动一个线程，并使线程进入就绪状态，等分配到时间片会自动调用其中的run（）方法；如果我们直接执行run（）方法时，只会把它看成是main（）线程中一个普通方法去执行，并不会在其他的线程中执行，所以不是多线程。</p><h2 id="线程是怎么进行通信的？（待解决）"><a href="#线程是怎么进行通信的？（待解决）" class="headerlink" title="线程是怎么进行通信的？（待解决）"></a>线程是怎么进行通信的？（待解决）</h2><h2 id="线程安全问题和线程同步"><a href="#线程安全问题和线程同步" class="headerlink" title="线程安全问题和线程同步"></a>线程安全问题和线程同步</h2><p>线程安全问题：多个线程共同操作共享数据</p><p>线程同步：当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完共享数据后，才能进行操作</p><p>面试题：线程有哪些同步的方法？</p><ul><li><p>synchronized修饰代码块或者方法</p></li><li><p>volatile修饰共享变量</p></li><li><p>juc包下的锁（比如Reentrantlock重入锁）</p></li><li><p>Atomic原子类（比如AutomicInteger）</p></li></ul><h2 id="线程调度的一些方法"><a href="#线程调度的一些方法" class="headerlink" title="线程调度的一些方法"></a>线程调度的一些方法</h2><ul><li><p>wait():</p></li><li><p>sleep():</p></li><li><p>join():执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队列，直到join结束或中断线程B才开始进入阻塞队列。</p><p>将join理解为插队，比如说A.join() ，那么在当前运行的线程进入阻塞队列，A插入进去。</p><p><a href="https://blog.csdn.net/u013425438/article/details/80205693">https://blog.csdn.net/u013425438/article/details/80205693</a>  对join方法的理解</p></li><li><p>yield():</p></li><li><p>notify():</p></li></ul><h2 id="sleep-方法和wait-方法的区别"><a href="#sleep-方法和wait-方法的区别" class="headerlink" title="sleep()方法和wait()方法的区别"></a>sleep()方法和wait()方法的区别</h2><p>两者都可以使当前线程进入阻塞状态</p><p>两者最主要的区别在于：sleep()方法没有释放锁，而wait()方法释放了锁。</p><ul><li><p>sleep是Thread类的方法，而wait是Object类的方法；</p></li><li><p>sleep()可以在很多场景下使用，wait()只能在同步代码块和同步方法中使用</p></li><li><p>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。</p></li><li><p>sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</p></li></ul><h2 id="sleep-和wait-方法的区别"><a href="#sleep-和wait-方法的区别" class="headerlink" title="sleep()和wait()方法的区别"></a>sleep()和wait()方法的区别</h2><p>调用yield方法会让当前线程交出CPU权限</p><p>它跟sleep方法类似，同样不会释放锁。</p><ul><li>但是yield不能控制具体交出CPU的时间</li><li>yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</li><li>yield方法不会让线程进入阻塞状态，而是让线程重回就绪状态</li></ul><h2 id="交替轮流打印数字（待完成）"><a href="#交替轮流打印数字（待完成）" class="headerlink" title="交替轮流打印数字（待完成）"></a>交替轮流打印数字（待完成）</h2><p>下面看第二个问题，两个线程交替打印1-100的奇偶数，为了减少输入所占篇幅，这里将100改成了10。基本思路上面类似，线程odd先拿到锁―—打印数字――唤醒线程even——阻塞线程odd，以此循环。</p><h2 id="并发编程的三个特性："><a href="#并发编程的三个特性：" class="headerlink" title="并发编程的三个特性："></a>并发编程的三个特性：</h2><p><strong>原子性</strong>：一个或多个操作要么全部执行成功，要么全部执行失败，是不可分割的</p><blockquote><p>i++操作不满足原子性，对i++反汇编（javap xx.class文件）操作，发现i++是由3步组成：（1）读取i的值。（2）对i加1。（3）赋值给i</p></blockquote><p>int i = 2;</p><p>int j = i;</p><p>i++;</p><p>i = i + 1;</p><p>第一句是基本类型赋值操作，必定是原子性操作。</p><p>第二句先读取i的值，再赋值到j，两步操作，不能保证原子性。</p><p>第三和第四句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</p><p>JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。</p><p><strong>可见性</strong>：当一个线程修改共享变量的值时，其他线程立马能够直到被修改了</p><p>线程1从主内存中拿到true到自己的工作内存中，并不断循环，在此期间线程2从主内存中拿到true到自己的工作内存中，并修改为false更新到主内存；但这个操作对于线程1是不可见的，线程1自己的工作内存中还是true。</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20211013122255816.png" alt="image-20211013122255816"></p><p><strong>实现可见性的方法：</strong></p><p>synchronized或者Lock：保证同一个时刻只有一个线程获取锁执行代码，锁释放之前把最新的值刷新到主内存，实现可见性。</p><p>volatile:被volatile修饰的变量，一个线程修改后直接把值写入主内存，其他线程直接从主内存中读取。</p><p><strong>有序性</strong>：指的是程序按照代码的先后顺序执行</p><p> 为了性能优化，编译器和处理器可能会进行指令重排序，有时候会改变程序中语句的先后顺序，但是它会保证在单线程情况下，语句最终执行结果和代码按顺序执行的结果是一致的。</p><p>那么它是如何保证在单线程下，语句最终执行结果和代码按顺序执行的结果是一致的呢？</p><p>那么就要提到as-if-serial语义了</p><blockquote><p><strong>as-if-serial语义</strong>的意思是：不管怎么进行指令重排序，单线程内程序的执行结果不能被改变。编译器，处理器进行指令重排序都必须要遵守as-if-serial语义规则。</p><p>处理器在进行重排序时是会考虑指令之间的<strong>数据依赖性</strong>，如果一个指令2必须用到1的结果，那么处理器会保证指令1会在指令2之前执行。</p></blockquote><p>比如说我们看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span> ;</span><br><span class="line">i = <span class="number">1</span> ;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span> ;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p> 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生<strong>指令重排序（Instruction Reorder）。</strong></p><p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;</span><br><span class="line">a = a + <span class="number">3</span>;</span><br><span class="line">r = a * a;</span><br></pre></td></tr></table></figure><p> 　这段代码有4个语句，那么可能的一个执行顺序是：</p><p><img src="/images/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Center.jpeg" alt="img"></p><p>那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3</p><p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p><p>　</p><p>再看多线程的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volatile boolean inited = false;</span></span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>; <span class="comment">//语句2</span></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>详解：上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><p><strong>实现有序性的方法：</strong></p><ul><li><p>synchronized或者Lock</p></li><li><p>volatile(禁止指令重排序)</p></li></ul><p><strong>as-if-serial语义是什么？</strong></p><p>无论编译器和处理器如何进行重排序，单线程程序的执行结果不会改变</p><p>指令重排序在单线程是没有问题的，不会影响执行结果，而且还提高了性能。但是在多线程的环境下就不能保证一定不会影响执行结果了。因此引入了happens-before规则</p><p><strong>happens-before规则是什么？</strong></p><p><a href="https://blog.csdn.net/zwx900102/article/details/106320017/">https://blog.csdn.net/zwx900102/article/details/106320017/</a></p><p>1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。      注意：这一点仅仅是JVM对程序员的保证，我们写代码时要这样做</p><p>2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序的后的执行结果与按happens-before关系执行的结果一致，Java虚拟机也会允许重排序的发生。</p><p>相同点：</p><p>happens-before关系保证了同步的多线程程序的执行结果不被改变，</p><p>as-if-serial保证了单线程内程序的执行结果不被改变。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;以前写过好几篇多线程相关的，不过总差点意思&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>员工管理系统的疑难点</title>
    <link href="http://example.com/2021/10/08/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/"/>
    <id>http://example.com/2021/10/08/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/</id>
    <published>2021-10-08T07:21:35.000Z</published>
    <updated>2021-10-09T02:53:30.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SpringBoot+Layui项目实战【神盾局特工管理系统】，只实现了初级的增删改查功能</p></blockquote><a id="more"></a><p>关于templates文件夹的说明</p><h3 id="templates目录"><a href="#templates目录" class="headerlink" title="templates目录"></a><strong>templates目录</strong></h3><p>template目录是用来保存动态模版文件的目录, 比如Freemarker, JSP, Thymeleaf等需要服务器动态渲染数据的文件.<br>由于页面渲染需要服务器中的数据, 所以该文件必须经过Controller控制器进行Model数据绑定后, 由服务器进行跳转. 所以直接访问是无意义的, 也访问不到.<br>模板文件夹，该文件下的页面不能通过地址栏地址直接访问，需要经过Controller类来访问，需要在application.properties中配置对应的模板引擎</p><p>原文链接：<a href="https://blog.csdn.net/qq_44866153/article/details/117184752">https://blog.csdn.net/qq_44866153/article/details/117184752</a></p><h3 id="在前端中引入themeleaf的语法："><a href="#在前端中引入themeleaf的语法：" class="headerlink" title="在前端中引入themeleaf的语法："></a><strong>在前端中引入themeleaf的语法：</strong></h3><p>注意静态资源的引入路径是从static目录的下一级开始算的</p><p><img src="/images/%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%96%91%E9%9A%BE%E7%82%B9/image-20211008215606377.png" alt="image-20211008215606377"></p><h3 id="密码在数据库中加密存储"><a href="#密码在数据库中加密存储" class="headerlink" title="密码在数据库中加密存储"></a>密码在数据库中加密存储</h3><p>随机盐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BCryptPasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br></pre></td></tr></table></figure><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>原理就是生成一个随机的字符串展示到页面上，并写入session中。</p><p>引入一个简单的验证码库easy-captcha。</p><p>三个功能：部署验证码，判断输入的验证码是否正确，点击验证码框能够更换验证码图片（前端实现）。</p><h3 id="增加登录拦截器（interceptor）"><a href="#增加登录拦截器（interceptor）" class="headerlink" title="增加登录拦截器（interceptor）"></a>增加登录拦截器（interceptor）</h3><p>防止没有登陆的用户也有权限直接访问后台</p><p>本案例比较简单，只需要判断session里面用户信息是否存在</p><p>需要一个拦截器和一个拦截器配置类</p><p><strong>1.编写拦截器实现类，实现接口  HandlerInterceptor，</strong></p><p><strong>重写里面需要的三个比较常用的方法，实现自己的业务逻辑代码</strong></p><p><strong>(就是自己拦截器拦截时做什么处理)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;  逻辑代码，返回<span class="keyword">false</span>进行拦截，返回<span class="keyword">true</span>放行&#125;</span><br></pre></td></tr></table></figure><p><strong>2.编写拦截器配置文件类并继承 WebMvcConfigurer类，并重写其中的方法 addInterceptors并且在主类上加上注解 @Configuration</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    InterceptorRegistration registration</span><br><span class="line">               = registry.addInterceptor(handlerInterceptor);</span><br><span class="line">    <span class="comment">// 拦截请求</span></span><br><span class="line">    registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    <span class="comment">// 放行请求</span></span><br><span class="line">    registration.excludePathPatterns(一般是静态资源和登陆请求);</span><br></pre></td></tr></table></figure><p>一个login是跳转到登录页面，一个login是登陆请求</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SpringBoot+Layui项目实战【神盾局特工管理系统】，只实现了初级的增删改查功能&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>学习SpringBoot疑惑记录</title>
    <link href="http://example.com/2021/10/03/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/10/03/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/</id>
    <published>2021-10-03T00:30:20.000Z</published>
    <updated>2021-10-10T09:30:04.332Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕叽咕叽</p></blockquote><a id="more"></a><p>mapper   ORM框架    </p><p>IOC容器控制反转      AOP面向切片编程</p><p>ORM</p><p><strong>spring有哪些模块？</strong></p><p>截止到目前Spring 框架已集成了 20 多个模块 。 这些模块主要被分如下图所示的核心容器 、 数据访问 / 集成 、Web、AOP （面向切面编程） 、 工具 、 消息和测试模块 。</p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211010164940116.png" style="zoom: 67%;" /><p><strong>spring框架用了哪些设计模式？</strong></p><blockquote><p>了解一下设计模式</p></blockquote><p><strong>对IOC和AOP的理解：</strong></p><p><strong>IOC：</strong></p><p>IOC是inverse of control <strong>控制反转</strong>的缩写，是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理，目的是降低类与类之间的耦合度。loc容器是Spring用来实现loC的载体，loc容器实际上就是个Map（key，value），Map中存放的是各种对象。</p><p>我们用lOC容器完成对象的注入。loC容器的本质是一个”生产Bean的工厂”，当我们的bean注册到容器中后，在程序的运行过程中，我们可以直接向loC容器索取我们想要的bean实例，而不是使用传统的new 这种方式。</p><p>控制反转是目的，依赖注入是实现控制反转的手段。</p><p>控制反转是为了降低类与类之间的耦合度。</p><p><strong>AOP：</strong></p><p>AOP（Aspect-Oriented Programming：<strong>面向切面编程</strong>）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，即插即用。<br>Spring AOP就是基于<strong>动态代理</strong>的，</p><blockquote><p>什么是动态代理？</p><p>要搞清楚静态代理和动态代理的区别</p></blockquote><p><strong>DI：</strong></p><p>DI是<strong>依赖注入</strong>的意思。</p><ul><li>构造函数注入</li><li> setter 注入 </li><li>接口注入 </li></ul><p>在 Spring Framework 中，我们通常使用构造函数和 setter 注入。</p><p><strong>DAO层、Service层、Controller层的区别：</strong></p><p>DAO层：<br>DAO层叫数据访问层，全称为data access object，属于一种比较底层，比较基础的操作，具体到对于某个表的增删改查，也就是说<strong>某个DAO一定是和数据库的某一张表一一对应的</strong>，其中封装了增删改查基本操作，建议<strong>DAO只做原子操作，增删改查。</strong></p><p>Service层：<br>Service层叫服务层，被称为服务，粗略的理解就是<strong>对一个或多个DAO进行的再次封装</strong>，封装成一个服务，所以这里也就不会是一个原子操作了，<strong>需要事物控制。</strong></p><p>Controller层：<br>Controller负责<strong>请求转发，接受页面过来的参数，传给Service处理，接到返回值，再传给页面。</strong></p><p>总结：<br>个人理解DAO面向表，Service面向业务。后端开发时先数据库设计出所有表，然后对每一张表设计出DAO层，然后根据具体的业务逻辑进一步封装DAO层成一个Service层，对外提供成一个服务。</p><p>反射+工厂模式</p><p>springbean作用域默认是单例的，即每次从容器中获得的都是同一个对象</p><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211003154931318.png"></p><p>就是一般开发下，有哪些包结构组成，应该是关于MVC方面的架构</p><p><strong>Spring帮助我们管理Bean分为两个部分，一个是注册Bean，一个装配Bean。</strong></p><p>@Autowired：自动装配bean</p><blockquote><p> @Autowired注解就相当于从Spring容器中通过类型，实例化了当前对象，可以直接调用它的方法。</p><p>通过@Autowired注解，如果在容器中有对应的bean，就可以通过@Autowired自动装载，也就是赋值。装载之后自动的按照类型在spring容器中查找相同类型，然后为该字段其注入那个类型的bean实例。</p><p>其实就是一种依赖注入的方式，此方式必须确保加注解的类在spring中有对应的bean（怎样加进去不管），并且字段的类型需要在spring容器中有相同类型的bean，才能创建bean实例，为其注入。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于执行了实例化 private UserService userService = new UserServiceImpl();</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure><p><strong>将⼀个类声明为Spring的 bean 的注解有哪些?（注册bean）</strong></p><p>@Component：</p><p>@Controller：</p><p>@Repository：</p><p>@Service：</p><p>简而言之，两个作用：</p><ul><li>说明这个类是一个spring IOC容器管理的类，之后可以通过@Autowired 实例化该类</li><li>当然也有语义化的作用，即代表该类是充当Controller的作用</li></ul><blockquote><p>Spring的一个核心功能是IOC，就是将Bean初始化加载到容器中， Bean加载到容器中可以使用 Spring注解方式或者 Spring XML配置方式。(通过注解将java中的一些类，加载到容器中) </p><p>在annotaion配置注解中用@Component来表示一个通用注释用于说明一个类是一个spring容器管理的类。即就是该类已经拉入到spring的管理中了。而@Controller,@Service, @Repository是@Component的细化，这三个注解比@Component带有更多的语义，它们分别对应了控制层、服务层、持久层的类。</p><ul><li><code>@Repository</code>：持久层，用于标注数据访问组件，即DAO组件。</li><li><code>@Service</code>：业务层，用于标注业务逻辑层主键。</li><li><code>@Controller</code>：控制层，用于标注控制层组件。</li><li><code>@Component</code>：当你不确定是属于哪一层的时候使用。</li></ul><p>之所以区分开几种类型，一是spring想在以后的版本中为它们添加特殊技能，二是这种分层的做法使web架构更清晰，易读性与维护性更好。</p></blockquote><p><strong>@component和@bean的区别和联系？</strong></p><p>这两个注解都是用来注册bean到spring容器中。</p><ul><li>@Component 注解作用于类，而 @Bean 注解作用于方法上</li><li>@Component 通常是通过类路径扫描来自动装配到Spring容器中。<br>@Bean注解通常与@Configuration配合，在配置类中的方法中返回bean对象</li><li>如果想要将第三方库中的组件装配到你的应用中，使用@component是不能实现自动装配的，可以使用@bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;SJL01&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那为什么有了@Component,还需要@Bean呢？</strong><br>如果你想要将第三方库中的组件装配到你的应用中，在这种情况下，@Component不能实现自动装配的，因此就不能使用自动化装配的方案了，但是我们可以使用@Bean,当然也可以使用XML配置。</p><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211005225450261.png" alt="image-20211005225450261"></p><p>@Transactional：</p><blockquote><p>与springboot事务管理有关系，暂时看不懂</p></blockquote><p>@ResponseBody：</p><blockquote><p>使用在控制层（controller）的方法上。</p><p>@RestController = @ResponseBody + @Controller</p><p>@ResponseBody的作用其实是将java对象转为json格式的数据。</p><p>json格式便于数据交互</p></blockquote><p>@Qualifier</p><blockquote><p>当一个接口有多个实现的时候，为了指名具体调用哪个类的实现;通常与@Autowired搭配使用</p></blockquote><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211009093317850.png" alt="image-20211009093317850"></p><p>下面三个的区别：用错了程序会报错</p><p>@GetMapping：控制跳转网页映射</p><p>@RequestMapping：</p><p>@PostMapping:</p><blockquote><p> Spring4.3中引进了@GetMapping、@PostMapping 来帮助简化常用的HTTP方法的映射 并更好地表达被注解方法的语义</p><p>@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。</p><p>@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.POST)的缩写。</p></blockquote><blockquote><p>什么时候用post 什么时候用 get？</p><p>1.当方法中的参数为@RequestParam、@PathVaiable、无参的情况下使用@GetMapping</p><p>2.当方法中的参数为@RequestBody、多参、对象参数的情况下使用@PostMapping</p><p>没看懂，但是暂且这样先用着吧</p></blockquote><p>@RequestParam</p><blockquote><ul><li>@RequestParam默认要求必须传参，可以通过设置<code>required = false</code>来关闭</li><li>如果为@RequestParam设置参数名，以他为准，不设置的话默认为其后的类型参数名</li><li></li></ul></blockquote><p><strong>不加的时候</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/request&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">test01</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">     String returnValue = <span class="string">&quot;返回的字符串为：&quot;</span>+name;</span><br><span class="line">     <span class="keyword">return</span> returnValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>请求端可以不带参数，比如：localhost:8080/request</p><p><strong>加上@RequestParam的时候</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/request&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test01</span><span class="params">(<span class="meta">@RequestParam(value = &quot;haha&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">    String returnValue = <span class="string">&quot;返回的字符串为：&quot;</span>+name;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求端必须带参数(当然我们可以设置false来关闭)，并且以设置的value值为准，如: localhost:8080/request?haha=www</p><p>@SpringBootApplication :放在springboot的启动程序上，标明这是一个启动类</p><p><strong>对spring bean生命周期的理解：</strong></p><p>实例化对象bean-》设置对象属性-》处理Aware接口-》BeanPostProcessor前置初始化方法-》调用bean自身的init方法-》调用BeanPostProcess的后置初始化方法-》使用bean-》销毁bean</p><p><strong>对SpringMVC的理解：</strong></p><p>弄清application.yml中mybatis两个属性的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mybatis配置</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;com&#x2F;baizhi&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: com.baizhi.ems_thymeleaf.entity</span><br></pre></td></tr></table></figure><p>mybatis传递多个参数需要绑定？</p><p><img src="/images/%E5%AD%A6%E4%B9%A0SpringBoot%E7%96%91%E6%83%91%E8%AE%B0%E5%BD%95/image-20211005213034158.png" alt="image-20211005213034158"></p><p>这里面的Model model 是什么意思？</p><p>开发功能的顺序：  entity包创建实体类  -》dao包创建持久层接口 -》mapper包中写sql语句 -》service包中写业务实现（一个service接口和service接口实现类） - 》controller包中写页面跳转</p><hr><p>mybatis：<br>mapper-locations：classpath:mybatis/mapper/<em>.xml               <strong>//对应每个实体类的mapper.xml文件的的位置</strong><br>type-aliases-package：cn.qqcn.</em>.entity               <strong>//存放实体类的包名</strong><br>configuration：<br>map-underscore-to-camel-case：true#驼峰转换    </p><p>数据库里面的字段用下划线，实体类用驼峰，那么之后怎么对应起来</p><p>HttpServletRequest  </p><p>HttpServletResponse    </p><blockquote><p>客户端浏览器发出的请求被封装成为一个HttpServletRequest对象。所有的信息包括请求的地址，请求的参数，提交的数据，上传的文件客户端的ip甚至客户端操作系统都包含在其内。</p><p>HttpServletResponse对象代表服务器的响应。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕叽咕叽&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>日常实习如何准备mark</title>
    <link href="http://example.com/2021/10/02/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87mark/"/>
    <id>http://example.com/2021/10/02/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87mark/</id>
    <published>2021-10-02T07:44:20.000Z</published>
    <updated>2021-10-02T08:55:17.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到的帖子先留下来</p></blockquote><a id="more"></a><p>没有项目可以做个简单的springboot项目练手；多刷题,不刷题阿里笔试0ac很正常<img src="/images/%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87mark/1.gif" alt="ema1">；多看书多实践;多做比赛，我个人面试的时候被问到项目的时候比较少，但是每轮面试都能聊十几分钟做的比赛，确实有些比赛比通常crud的项目有东西。</p><p>下面上两个大佬的经验分享</p><p>先说学习方法(How)：所有的学习不外乎就是学习+实践这两个过程，从实践中学习，在实践中验证学到的东西。所谓的学习就是比较+思考，比较就是看别人怎么做的，看别人比自己强在哪里，思考包括不限于怎么利用别人的优点去改边自己的缺点，更深一层是去思考别人为什么比自己强，在深一层是思考自身：目前在做的事对你的终极目标是不是有意义，自己有没有在逃避一些事情而不敢直面自己的目标。你通过比较加思考学到了一些事情之后，下一步就是去实践，在实践中去熟练对的东西，去验证排除错的东西。<br>再聊学习动机(Why)：要有清晰而长远的目标，坚定的走下去，年轻时不要追求广，要追求深。<br>最后说学习内容（What）：对于Java研发来说，成长最快的方式有三种：项目，比赛，源码。<br>聊完上面这些东西，在具体事务上的建议就很清楚了：<br>0、确定方向；<br>1、学习：感兴趣领域内的书、公开课、比赛经验、有名的框架的源码；<br>2、归纳思考：整理知识体系，写博客，实习过程中的项目总结，看看周围最牛的人在做什么；<br>3、实践：实习+比赛（天池、华为云、TiDB）<br>在循环的学习-&gt;归纳-&gt;实践中提升自己。</p><hr><p>title: 阿里中间件大佬2020/04/12号面试经验分享<br>-–</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>阿里中间件团队博客</p><h4 id="扎实的计算机基础"><a href="#扎实的计算机基础" class="headerlink" title="扎实的计算机基础"></a>扎实的计算机基础</h4><p>- 计算机组成原理<br>- 计算机网络<br>- 操作系统<br>- 基本数据结构与算法<br>- 数据库<br>- JAVA基础<br>  熟悉基本语法与常用库<br>  学习源码、io、util、current、collection<br>  了解常用框架，spring、netty、dubbo等</p><h4 id="提高编程能力、编程比赛"><a href="#提高编程能力、编程比赛" class="headerlink" title="提高编程能力、编程比赛"></a>提高编程能力、编程比赛</h4><p>- 阿里巴巴天池比赛<br>- 华为软件精英挑战赛<br>- 中兴捧月挑战赛</p><h4 id="积极参加项目实战"><a href="#积极参加项目实战" class="headerlink" title="积极参加项目实战"></a>积极参加项目实战</h4><p>对平时做的项目多思考，对使用的技术深入了了解，多方比较</p><h4 id="笔试准备"><a href="#笔试准备" class="headerlink" title="笔试准备"></a>笔试准备</h4><p>- LeetCode<br>- 《编程珠玑》<br>- 《算法》</p><h4 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h4><p>- 记笔记<br>- 厚积薄发<br>单背面经有些不够<br>- 对不同的公司专门准备</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看到的帖子先留下来&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>秋招帖子markmark</title>
    <link href="http://example.com/2021/09/24/%E5%8C%97%E9%82%AE%E4%BA%BA%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90mark/"/>
    <id>http://example.com/2021/09/24/%E5%8C%97%E9%82%AE%E4%BA%BA%E8%AE%BA%E5%9D%9B%E5%B8%96%E5%AD%90mark/</id>
    <published>2021-09-24T04:25:30.000Z</published>
    <updated>2021-09-27T11:32:04.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到的帖子先留下来</p></blockquote><a id="more"></a><h1 id="秋招Tips"><a href="#秋招Tips" class="headerlink" title="秋招Tips"></a>秋招Tips</h1><h3 id="0-卷首语"><a href="#0-卷首语" class="headerlink" title="0. 卷首语"></a>0. 卷首语</h3><p>秋招算是个人成长的一大转折，跌跌撞撞，终于在近期正式结束，由于受惠于诸多前辈的经验，打算写一下没啥人看的经验。攒攒人品，求个大包。</p><p>本人应届硕士，15级北邮本，计院；大四某无人驾驶公司算法实习 + 暑期阿里云弹性计算实习(偏底层）</p><p>收获的意向书：阿里云tan性计算，腾讯guang子，百度推广搜某架构，字节dou音电商，美团到家，快手shang业化，拼多多，虾皮，京东，网易互娱；其他公司offer够了就没面了，如微软，hulu…</p><p><strong>码字不易，请别乱传，请别外传</strong>。</p><h3 id="1-三维"><a href="#1-三维" class="headerlink" title="1. 三维"></a>1. 三维</h3><p>和保研差不多，秋招最重要的也是你的三维，好学校科班出身，基础知识牢固，丰富的大厂实习经验，SSSSP赢家就是你</p><ol><li>学历/专业 211+， 计科/软工/网工/通信…</li><li>基本知识：语言基础(C++, Go, Java)，算法，TCP/IP, Os，Redis，消息队列, 分布式(CAP，BASE，Xcc， Paxos，Raft…)</li><li>实习/项目：大厂相关实习，知名开源项目…<ol><li>个人觉得实习更重要，学历没法补，基本知识可以突击</li><li>找一个放实习的老板；个人最大的吃亏在于只有2段比较偏的实习，一个算法，一个太底层</li><li>相关实习，某些实习面试官可能不太care or 体现不出能力</li></ol></li></ol><h3 id="2-复习-amp-相关题目"><a href="#2-复习-amp-相关题目" class="headerlink" title="2. 复习&amp;相关题目"></a>2. 复习&amp;相关题目</h3><p>本人由于算法转开发，大多复习的是后台/服务器开发相关的知识；</p><p>大部分公司会在八股的基础上深入一下，但不会深入太多，很多我觉得难的都不会问….</p><p>建议不要只刷面经，系统的看一下/复习一下会更好</p><p>以下复习按照我理解的优先级进行排序；</p><ol><li><p>TCP / IP：复习使用的书籍《TCP/IP详解》，各种blog</p><ol><li>TCP，IP，UDP基本头部</li><li>TCP为啥三次握手/四次挥手；对应的状态迁移</li><li>TCP的各种状态位，什么时候有用</li><li>TCP的3种定时器，TCP的长肥管道问题</li><li>半连接，全连接</li><li>Time wait; 为啥Time wait；大量短连接怎么处理</li><li>TCP vs UDP</li><li>HTTP协议基本，以及1.0/1.1/2.0/3.0对比</li><li>HTTPS，和Http对比；握手；数字证书；对称加密非对称加密</li><li>DNS，递归/迭代查询；什么时候UDP，什么时候TCP</li><li>ARP，arp广播，arp代理</li><li>ICMP (比较偏)，ping，traceroute</li><li>socket编程客户端/服务端的几个函数，以及对应参数</li><li>IO多路复用select，poll，epoll区别/优劣，epoll的两种模式<ol><li>select为啥有个1024的限制，32*i32</li><li>epoll线程安全</li><li>reactor vs proactor</li></ol></li></ol></li><li><p>OS: 复习使用的书籍《现代操作系统》</p><ol><li>虚拟内存(必问)：MMU/TLB，多级页表，内存分配（slab，伙伴)</li><li>进程&amp;线程基本概念，PCB包含什么，进程内存模型，TCB</li><li>进程间通信<ol><li>基本概念，原理</li><li>通信效率，是否设计系统调用</li></ol></li><li>死锁，条件，检测/恢复/预防</li><li>同步，原子操作，CAS&amp;FAA，互斥锁，条件变量，RCU</li><li>底层IO模型，阻塞，非阻塞，信号，多路复用，异步</li><li>多线程vs多进程；同一进程线程切换，不同进程线程切换；</li><li>协程vs线程</li><li>inode，软连接、硬链接，文件描述符</li><li>零拷贝</li></ol></li><li><p>数据库 复习使用的课程《mysql实战45讲》+ blog</p><ol><li>mysql架构，server层 + 引擎层；<ol><li>连接器，查询缓存，分析器，优化器，执行器</li><li>两种存储引擎的对比</li></ol></li><li>redo log vs binlog vs undo log，这块可以问得可深了…<ol><li>redolog为啥crash safe, binlog为啥不是</li><li>如何恢复数据</li><li>何时刷新log/数据</li></ol></li><li>索引<ol><li>B+树 vs B树</li><li>唯一索引vs普通索引</li><li>聚簇 vs 非聚簇</li><li>最左前缀匹配，给你个sql让你分析</li><li>回表/覆盖索引</li><li>索引设计</li><li>explain</li></ol></li><li>事务，隔离级别（默认），脏读/不可重复读/幻读</li><li>MVCC，什么时候生成read view；如何判断哪些事务可见</li><li>锁（加锁才能实际解决幻读）<ol><li>两阶段锁</li><li>record lock，gap lock， next key lock</li></ol></li><li>数据库优化，读写分离，主从，分库分表等等</li><li>范式</li><li>手写嵌套查询<ol><li>如何设计索引</li><li>执行顺序</li></ol></li><li>给你个sql，让你分析如何加索引，使用了什么索引</li></ol></li><li><p>语言基础 (C++, Go)</p></li></ol><p>   <a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p><p>   + C++ primer plus</p><ol><li>几种时期多态，虚函数表(最基本, 多重继承)</li><li>智能指针 &amp; 手写最简单的智能指针</li><li>C++的内存分布/ 内存对齐</li><li>static / const</li><li>C++11，右值，转移语义，lambda等等</li><li>…</li><li>Go语言 GMP模型</li><li>线程池，内存池 (比较偏)</li></ol><ol start="5"><li><p>Redis</p><ol><li>基本数据结构底层，大数据量和小数据量情况下不同的数据类型；<ol><li>sds</li><li>跳表</li><li>ziplist，有啥好处</li><li>hash，渐进式hash，rehash</li><li>intset，提升</li></ol></li><li>为啥快？基于内存，多路复用，单线程事件分配器</li><li>大key问题；慢日志</li><li>缓存穿透，击穿，雪崩；如何处理</li><li>redis分布式锁，单机版&amp;分布式版</li><li>redis持久化，AOF vs RDB</li><li>redis主从流程</li></ol></li><li><p>消息队列：没复习，但经常会问</p></li><li><p>数据结构 《STL源码剖析》+ blog</p><ol><li>vector底层<ol><li>扩容</li><li>迭代器失效</li></ol></li><li>hashmap底层</li><li>树，**二叉树，avl，红黑树，B+树，B树，LSM树<ol><li>avl vs 红黑树</li><li>B+树 vs B树</li></ol></li></ol></li><li><p>设计模式 《大话设计模式》</p><ol><li>手写单例 (必问)</li><li>简单工厂，工厂方法…</li></ol></li><li><p>linux 常用指令</p><ol><li>grep</li><li>sed</li><li>find</li><li>iostat/netstat</li><li>top</li></ol></li><li><p>分布式</p><ol><li>CAP， BASE</li><li>分布式事务，两阶段，三阶段</li><li>Raft基本流程，选主，日志复制，脑裂之后流程</li><li>一致性hash</li></ol></li></ol><h3 id="3-算法"><a href="#3-算法" class="headerlink" title="3. 算法"></a>3. 算法</h3><p>除了字节和外企，其他公司的面试题都很简单….也不用特别担心；建议面试前看看公司最喜欢考的题</p><ul><li>链表题<ul><li>翻转，每k个翻转，字节最爱…</li><li>环的入口</li><li>删除重复节点</li><li>链表快排/归并排序</li></ul></li><li>动规题，动规题理解了背住常见的几个模板就行；一般最多2维dp<ul><li>最长公共子串</li><li>最长上升子序列</li><li>换零钱，变种考了很多次</li><li>01背包</li><li>回文子串，及其变种比如区间[i, j]符合某某条件</li><li>矩阵连乘，加括号</li><li>编辑距离</li></ul></li><li>二叉树前中后，递归/非递归遍历；一般比较简单<ul><li>非递归遍历</li><li>前序中序重建</li><li>最大路径和</li><li>公共祖先</li></ul></li><li>排序，快排变种<ul><li>第K大/小</li><li>两个数组第k大</li></ul></li><li>单调栈，接雨水</li><li>位运算，子网掩码，只出现一次的数…</li><li>广度搜索 + 记忆化数组，求最短路径</li><li>dfs，暴力解法，骗分</li><li>排序算法，n2, nlogn, n</li><li>排列<ul><li>全排列，无重复</li><li>下一个排列</li><li>洗牌算法</li></ul></li></ul><h3 id="4-项目"><a href="#4-项目" class="headerlink" title="4. 项目"></a>4. 项目</h3><p>尽量提前实习，去有含金量的大厂，比如wxg，阿里云，抖音等等；</p><p>尽量实习方向和就业方向相同；</p><p>没项目经验的可以看看下面这个</p><ul><li>C++ web server <a href="https://github.com/linyacool/WebServer">https://github.com/linyacool/WebServer</a></li></ul><p>项目常常问</p><ul><li><strong>请使用star法则介绍你的项目</strong></li><li>项目实施的一些详细数据</li><li>为什么这么设计，你在其中承担的角色</li><li>如何保证/增加crash-safe的能力</li><li>考虑以后的优化</li><li>你的收获</li></ul><h3 id="4-面试"><a href="#4-面试" class="headerlink" title="4. 面试"></a>4. 面试</h3><p>不要紧张，不要紧张，不要紧张，此处不留爷自有留爷处；</p><p>大部分公司面试官都是很nice的，不要被某些面试官的黑脸搞崩心态，比如某节面试官。</p><ol><li><p>找一个安静，整洁的环境；好的环境会让双方都体验更好，开始我在宿舍面就体验不咋样，后来去学校的一些小房间面，状态感觉就不一样</p></li><li><p>开始面试前，让自己放松下，不要太紧张，不要再去拼命复习，没用的反而会让自己紧张</p></li><li><p>面试过程尽量保持自己的语调，确保面试官能听清楚，不会太快太急</p></li><li><p><strong>一定要结构化的回答问题</strong>，面试官听你的回答提炼答案也很累</p><ol><li>为啥有xx；相同点是: 第一点，第二点，第三点；不同点是：第一点，第二点，第三点；最后总结一下</li></ol></li><li><p>遇到不会的题，尽量回答一些有关系的点，如果实在不会，直接说不会，不要绕来绕去</p></li><li><p>遇到会的题，在答完基础的情况下，可以加深一下，比如</p><ol><li><p>面试官问你虚拟内存是啥；</p><p>虚拟内存的是啥…; 段式，页式；单级页表，多级页表；MMU，TLB加速翻译过程；内存换入换出等等</p></li><li><p>MYSQL的锁</p><p>表锁+行锁；行锁基于索引，record/gap/next-key；意向锁</p></li></ol></li><li><p>除了部分公司某些面试官，比如某节，其他公司的面试官会引导你去回答，也不会缠着你不会的；</p></li><li><p>不要在面试官面前显示的很卑微，此处不留爷自有留爷处</p></li><li><p>面试完了就不要患得患失了，准备下一场比啥都重要</p></li></ol><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ol><li>尽量早投，尤其是提前批别错过，秋招的一大感悟就是投晚了，真hc紧缺，很多公司都会有个池子养鱼，简历投了几个星期才面试。</li><li>适当练下手，培养面试状态，别一开始就面你最想去的公司</li><li>别只等转正offer，今年很多公司招了不少实习生，转正率不高，等offer会变得很焦虑</li><li>提早复习，边实习边复习，真的会没时间复习&amp;焦虑&amp;复习效果不好；</li><li>尽早拿一个offer垫底，没offer+没试提前批真的焦虑；有offer之后面试也硬气起来了</li><li>找个小伙伴 or 对象；不要一个人焦虑</li></ol><p>祝学弟学妹们，春招/秋招顺利！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;看到的帖子先留下来&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/2021/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-09-20T09:05:43.000Z</published>
    <updated>2021-09-22T03:28:29.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统简要提纲</p></blockquote><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>操作系统知识模块主要分为：操作系统概述、进程管理、内存管理、文件管理、输入/输出(I/O)管理。</p><p>操作系统（Operating System，OS）是计算机系统中最重要的系统软件，控制和管理整个计算机系统的硬件和软件资源。它位于硬件和其他系统软件之间。</p><p>操作系统的功能：</p><p>进程管理、内存管理、文件管理、输入/输出(I/O)管理、用户接口管理</p><p>操作系统的基本特征：<strong>并发、共享、虚拟和异步</strong>。</p><ul><li><p>并发是指两个或多个事件在<strong>同一时间间隔内</strong>发生。</p></li><li><p>共享是系统资源供多个并发执行的进程共同使用。</p></li><li><p>虚拟是指<strong>把一个物理上的实体变为若干个逻辑上的对应物</strong>。操作系统的虚拟技术可归纳为：时分复用技术，如处理器的分时共享；空分复用技术，如<strong>虚拟存储器。</strong></p></li><li><p>异步是指在多道程序环境下，允许多个程序并发执行，但由于自由有限，进程的执行不是一贯到底，而是走走停停，<strong>以不可知的速度向前推进，这就是进程的异步性</strong></p></li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程是系统进行资源分配和调度的一个独立单位。</p><p>用进程控制块（PCB）来动态地描述进程，PCB是进程存在的唯一标志。</p><p><strong>进程状态：</strong></p><p>五状态模型</p><ul><li>新建状态：进程正在被创建，尚未转到就绪状态</li><li>就绪状态：进程已获得除处理机之外的一切所需资源</li><li>运行状态：进程正在处理机上运行</li><li>阻塞状态：进程正在等待某一事件而暂停运行</li><li>终止状态：进程正从系统中消失，分为正常结束和异常退出</li></ul><p><strong>线程</strong>：</p><p>引入线程，是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p><p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元。</p><p>线程共享进程拥有的全部资源。</p><p>线程不拥有系统资源，但是它可以访问进程所拥有的系统资源。</p><p>线程没有自己独立的地址空间，他共享他所属的进程的空间。</p><p>线程自己并不拥有资源，而是与进程中的其他线程共享资源。也叫轻量级进程</p><p><strong>调度层次：</strong></p><ul><li>作业调度（高级调度）：选择处于后备状态的作业分配资源，发送频率低</li><li>内存调度（中级调度）：选择暂时不能允许的进程调出内存，发送频率中等</li><li>进程调度（低级调度）：选择就绪队列中合适的进程分配处理机，发生频率高</li></ul><p>**进程调度方式 **</p><ol><li>非剥夺调度方式 ：有更为重要或紧迫的进程需要使用处理机，仍让当前进程继续执行</li><li>剥夺调度方式 ：有更为重要或紧迫的进程需要使用处理机，立即分配</li></ol><p><strong>调度算法</strong></p><p>1.<strong>先来先服务调度算法（FCFS）</strong>，顾名思义，先到先得</p><p>2.<strong>短作业优先（SJF）调度算法</strong></p><p>从后备队列中选择一个或若干个估计运行时间最短的作业，将他们调入内存运行。</p><p>3.<strong>优先级调度算法</strong></p><p>根据能否抢占进程，可将调度算法分为：</p><ol><li>非剥夺式优先级调度算法</li><li>剥夺式优先级调度算法</li></ol><p>根据进程创建后其优先级是否可以改变，分为：</p><ol><li>静态优先级。优先级在创建进程时确定，且在进程的整个运行期间保持不变。</li><li>动态优先级。可动态调整优先级。</li></ol><p>4.<strong>高响应比优先调度算法</strong>：是对FCFS和SJF算法的综合平衡</p><p>5.<strong>时间片轮转调度算法</strong>：为每一个进程分配一个时间片，用完后进程循环轮流运行</p><p><strong>进程同步</strong></p><p>临界资源</p><p>我们把<strong>一次仅允许一个进程使用的资源</strong>称为临界资源。</p><p><strong>死锁</strong></p><h2 id="死锁的相关知识"><a href="#死锁的相关知识" class="headerlink" title="死锁的相关知识"></a>死锁的相关知识</h2><h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>是指多个线程在运行过程中因争夺资源而造成的一种僵局，它们中的一个或者多个都在等待某个资源被释放。</p><p>我们举一个例子：比如说，线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，都在等待对方释放自己所需要的资源，那么这时候两个线程就会互相等待而进入死锁状态。</p><img src="/images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210727212453831.png" alt="死锁的例子" style="zoom:67%;" /><h3 id="死锁产生的原因？"><a href="#死锁产生的原因？" class="headerlink" title="死锁产生的原因？"></a>死锁产生的原因？</h3><p>我们知道系统中的资源可以分为两类，一类是可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺。另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放。</p><p>第一个原因，因为多个进程之间<strong>竞争不可剥夺资源</strong>，比如说有一个进程抢占了打印机，其他进程只能等这个进程使用完成后才能使用。（举个例子假定进程PI已占用了打印机R1，进程P2已占用了磁带机R2，若P2继续要求打印机R1，P2将阻塞；P1若又要求磁带机，P1也将阻塞。于是，在P1和P2之间就形成了僵局）</p><p>第二个原因，竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p><p>第三个原因，进程间推进顺序非法</p><p>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。</p><h3 id="死锁的必要条件？（4个，缺一不可）"><a href="#死锁的必要条件？（4个，缺一不可）" class="headerlink" title="死锁的必要条件？（4个，缺一不可）"></a>死锁的必要条件？（4个，缺一不可）</h3><p>1.<strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即一个资源每次只能被一个进程使用。</p><p>2.<strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>3.<strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p><p>4.<strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。（即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。）</p><h3 id="如何解决死锁问题？"><a href="#如何解决死锁问题？" class="headerlink" title="如何解决死锁问题？"></a>如何解决死锁问题？</h3><p>包括预防死锁、避免死锁、检测死锁、解除死锁四种方式</p><p><strong>预防死锁</strong></p><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p><p>1.<strong>破坏互斥条件</strong>（无法实现）：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的，如果互斥性被破坏的话，以打印机为例，多个进程共享使用打印机，则打印出来的结果就不正确了（临界资源需要互斥访问</p><p>2.<strong>破坏请求与保持条件</strong>：一次性申请所有的资源，该进程就可以顺利执行完毕（优点简单易于实现，缺点严重地降低了资源的利用率，有的资源在进程的后期才会使用，而其他进程要用这个资源的话就必须等待）</p><p>3.<strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p>4.<strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。<br>破坏循环等待条件。（不足：1.需要知道资源的请求顺序、2.要请求某个序号比较大的资源时，需要先请求序号比较小的资源，占用了序号比较小的资源，使其利用率变低）</p><p><strong>避免死锁</strong></p><p>避免死锁可以采用判断<strong>系统是否会处于安全状态</strong>的方法</p><p>在进行系统资源分配之前，先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给<strong>进程； 否则，让进程</strong>等待。这是一种保证系统不进入死锁状态的动态策略</p><blockquote><p>系统的安全状态</p><p>对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p></blockquote><p><strong>银行家算法</strong>（一个避免死锁的著名算法）</p><p>我们可以把操作系统看作是银行家，系统资源看做资金，客户看做进程。</p><p>算法要求：</p><p>1、申请的贷款额度不能超过银行现有的资金总额</p><p>2、分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额</p><p>3、如果银行暂时不能满足客户申请的资金额度时，可推迟放款并在有限时间内给予贷款</p><p>4、客户要在规定的时间内还款</p><p><strong>检测死锁</strong></p><p>这种方法并不需要事先采取任何限制性措施，即允许产生死锁，若检测到死锁则采取相应的方法解除死锁</p><p><strong>解除死锁</strong></p><p>如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，此时就需要对系统采取相应的措施。常用的解除死锁的方法：<br>1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。<br>2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。<br>    a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。<br>     b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。一般根据如下几个方面来决定终止哪个进程：<br>    进程的优先级<br>    进程已运行时间以及运行完成还需要的时间<br>    进程已占用系统资源<br>    进程运行完成还需要的资源<br>    终止进程数目<br>    进程是交互还是批处理</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><code>地址空间</code>：</p><ul><li>逻辑地址空间：是指一个源程序的相对地址的空间；</li><li>物理地址空间：内存中物理地址</li></ul><p><code>地址重定位</code>：将逻辑地址转换为物理地址。</p><p>页面更新算法就是用来确定淘汰哪些页面的算法，</p><p>内存抖动：刚销毁不久的页面不久后又要使用，又要将其调入内存中，反反复复，导致大部分时间开销都花费在反复调度页面上。</p><p>最优更新算法：淘汰以后永远不会使用，或未来很长一段时间内不会使用的页面，无法实现</p><p>先进先出更新算法（FIFO）：淘汰最先进入内存的页面</p><p>最近最久未使用更新算法（LRU）：淘汰最近最久没有使用的页面</p><p>页式内存管理、内存抖动、页面更新算法</p><p>段式内存管理</p><p>虚拟内存</p><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h2 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;操作系统简要提纲&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——概述</title>
    <link href="http://example.com/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</id>
    <published>2021-09-19T12:06:43.000Z</published>
    <updated>2021-09-21T01:58:10.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之概述</p></blockquote><a id="more"></a><p><a href="https://blog.csdn.net/cdlwhm1217096231/article/details/90760282">https://blog.csdn.net/cdlwhm1217096231/article/details/90760282</a></p><p>这篇总结写的非常详细和清楚</p><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p>边缘部分：所有连接在互联网上的主机（主机指的是所有与网络直接相连的计算机）组成</p><p>核心部分：<strong>大量的网络</strong>与连接这些网络所使用的<strong>路由器</strong>构成，为边缘部分提供服务。</p><h3 id="计算机之间的通信"><a href="#计算机之间的通信" class="headerlink" title="计算机之间的通信"></a><strong>计算机之间的通信</strong></h3><p>指的是主机A上的一个进程与主机B上的另一个进程之间进行通信。</p><p>计算机通信的方式主要有两种：</p><ul><li><strong>客户-服务器方式：即C /S方式</strong>。客户端发送服务的请求，服务器是服务的提供方。</li><li><strong>P2P：点对点连接方式</strong>。两台通信的主机之间不区分哪个是客户，哪个是服务端，进行对等连接</li></ul><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p><p><strong>举个例子</strong>：</p><p>从A找到一条通往E的路径并建立会话的过程中，我们称之为<strong>电路交换</strong>的第一阶段—-<strong>建立连接</strong>。</p><p>之后A和E在通话的过程中会始终霸占着这条路径，数据传输的过程称为电路交换的第二阶段—-<strong>数据传输</strong>。</p><p>电路交换的第三阶段，也就是最后一个阶段—-<strong>释放连接</strong>。A和B只要有一方挂了电话，那便了开始释放连接。</p><p><strong>优点：</strong></p><p>1、传输速度快、高效。</p><p>2、实时。</p><p><strong>缺点：</strong></p><p>1、资源利用率低。（有可能占用着路线但没有进行通信）</p><p>2、新建连接需要占据一定的时间，甚至比通话的时间还长。</p><h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2. 分组交换"></a>2. 分组交换</h3><p>所谓分组，就是将一个数据包分成一个个更小的数据包。每个数据包由文件头和数据组成。分组交换采取<strong>存储转发</strong>传输的机制，<strong>单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</strong></p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210831155035763.png" alt="数据包" style="zoom:67%;" /><p>举个例子：我们生活中邮局的信件传输</p><p><strong>缺点：</strong></p><p>1、不具有实时性。</p><p>2、存在延时。 （A通过中介B到达E，并不是实时传输的）</p><p>3、会造成通信阻塞。 （太多数据包丢给路由器B后会造成堵塞）</p><p>4、存在无用的重复数据。（每个小数据包中的文件头有许多重复的数据）</p><p>5、会出现丢包的情况。 （路由器B的容量是有限的，如果有太多的数据包丢给它，它可能会容纳不下造成丢包）</p><p><strong>致命的优点：</strong></p><p>1、设计简单 。</p><p>2、资源利用率很高。</p><h3 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h3><p>当然，还有一种<strong>报文交换</strong>的方式，就是将整个报文进行存储转发的，不过这种方式使用的比较少</p><h3 id="4-三种交换方式示意图"><a href="#4-三种交换方式示意图" class="headerlink" title="4. 三种交换方式示意图"></a>4. 三种交换方式示意图</h3><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210831155953905.png" alt="三种交换方式示意图" style="zoom:67%;" /><p>详细见下面的链接</p><p><a href="https://blog.csdn.net/m0_37907797/article/details/104228141">电路交换与分组交换有什么区别？</a></p><h3 id="路由器介绍："><a href="#路由器介绍：" class="headerlink" title="路由器介绍："></a><strong>路由器</strong>介绍：</h3><p>核心部分起到特殊作用的是<strong>路由器</strong>，它是一个<strong>专用的计算机</strong>，主要作用是<strong>分组交换</strong>和<strong>存储转发</strong>的功能。</p><p>路由器的<strong>工作流程</strong>：</p><p>接收分组数据 -》检查首部 -》根据目的地址查找转发表 -》将分组转发给下一个路由器 -》一步一步转发到目的地</p><p>路由器接收到一个分组后，暂存数据到路由器自己的缓存中即自身的存储器中，然后检查其首部，查找转发表。按照首部中的目的地址，找到合适的接口转发除去，把分组交给下一个路由器。这样一步一步以存储转发的方式，把分组交给最终的目的主机。路由器只是暂存一个分组，不是整个报文。分组在哪段链路上传送时才会占用此段链路上的通信资源，在各分组传输之间的空闲时间，此链路也是可以被其他主机发送的分组使用。</p><h3 id="计算机网络中的常见硬件设备介绍："><a href="#计算机网络中的常见硬件设备介绍：" class="headerlink" title="计算机网络中的常见硬件设备介绍："></a>计算机网络中的常见硬件设备介绍：</h3><p><strong>物理层</strong>：实现网络互连的主要设备有**中继器和HUB(集线器)**。中继器的主要功能是对接收到的信号进行再生整形放大以扩大网络的传输距离；集线器在此基础上将所有的节点集中在以它为中心的节点中，可组成星型拓扑结构。</p><p><strong>数据链路层</strong>：实现网络互联的主要设备有<strong>交换机和网桥</strong>。交换机是一种基于MAC识别，能完成封装转发数据包功能的网络设备。它可以“学习”MAC地址，并把其存放在内部地址表中，当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口。 交换机将局域网分为多个冲突域，每个冲突域都是有独立的宽带，因此大大提高了局域网的带宽。网桥是数据链路层互联的设备，在网络互联中可起到数据接收、地址过滤与数据转发的作用，可用来实现多个不同网络系统之间的数据交换。</p><p><strong>网络层</strong>：实现网络互连的主要设备有<strong>三层交换机和路由器</strong>。路由器用于连接多个逻辑上分开的网络，具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网。</p><p><strong>传输层（包括传输层）以上</strong>：<strong>实现网络互连的设备有网关</strong>。网关在网络层以上实现网络互连，用于两个高层协议不同的网络互连。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210921095346172.png" alt="每层的网络设备"></p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/image-20210919161518894.png" alt="计算机网络体系结构"></p><h3 id="三个体系的简要介绍："><a href="#三个体系的简要介绍：" class="headerlink" title="三个体系的简要介绍："></a><strong>三个体系的简要介绍：</strong></h3><p>OSI由于体系比较复杂，而且设<strong>计先于实现</strong>，有许多设计过于理想，<strong>不太方便计算机软件实现</strong>，因而完全实现OSI参考模型的系统不多，应用的范围有限。</p><p>TCP/IP协议最早在计算机系统中实现，在Linux、Windows平台中都<strong>有稳定的实现</strong>，并且提供了简单方便的编程接口（API），可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP/IP协议已成为目前互联网事实上的国际标准和工业标准。</p><p>五层协议结构是综合了OSI和TCP/IP的优点的一种协议，包括（从下到上）：<strong>物理层、数据链路层、网络层、运输层、应用层。</strong>（最底下两层可以称为网络接口层）</p><p>五层协议的体系结构只是为<strong>介绍网络原理而设计</strong>的，实际应用还是TCP/IP四层体系结构。</p><p>在互联网使用的各种协中最重要和最著名的就是 <strong>TCP/IP</strong> 两个协议。现在人们经常提到的TCP/IP 并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整<strong>个TCP/IP协议族。</strong></p><p>4.<strong>数据在各层之间的传递过程</strong></p><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有<strong>下面三层协议（物理层、数据链路层、网络层），</strong>因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h3 id="每层的大概作用"><a href="#每层的大概作用" class="headerlink" title="每层的大概作用"></a><strong>每层的大概作用</strong></h3><ul><li><strong>应用层</strong>：<strong>应用层直接为用户的应用进程程序提供服务</strong>。这里的进程就是指正在运行的程序。如支持万维网应用的http协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等。</li><li><strong>运输层</strong>：<strong>运输层的任务就是负责向两个主机进程之间的通信提供服务</strong>。由于一个主机可以同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是运输层把收到的信息分别交付给上面应用层中的相应进程。<br>运输层主要使用下面两个协议：<br><strong>传输控制协议TCP</strong>（Transmission Control Protocol）：面向连接的，数据传输的基本单位是报文段，能够提供可靠的交付<br><strong>用户数据报协议UDP</strong>（User Datagram Protocol）：无连接的，数据传输的基本单位是用户数据报，不能保证提供可靠的交付，只能提供尽最大努力交付。</li><li><strong>网络层</strong>： <strong>负责为分组交换网上的不同主机提供通信服务</strong>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作<strong>IP数据报。</strong></li><li><strong>数据链路层</strong>：两个主机之间的数据传输，总是在一段一段的链路上传送的。在两个相邻结点之间传送数据时，<strong>数据链路层将网络层交下来的IP数据报组装成帧</strong>，在两个相邻结点间的链路上<strong>透明地传送帧中的数据</strong>，每一帧包括数据和必要的控制信息。</li><li><strong>物理层</strong>：<strong>负责最底层的物理介质连接</strong>。在物理层上传送的数据单位是<strong>比特</strong>。<strong>物理层的任务就是透明地传送比特流。</strong></li></ul><h3 id="每层的常用协议："><a href="#每层的常用协议：" class="headerlink" title="每层的常用协议：　"></a><strong>每层的常用协议：</strong>　</h3><p>物理层：</p><p>数据链路层：ppp协议、CSMA/CD 协议</p><p>网络层：IP、ARP、ICMP、IGMP、OSPF、RIP、BGP</p><p>传输层：TCP（传输控制协议）、UDP（用户数据报协议）</p><p>应用层：FTP（文件传输）、SMTP（电子邮件相关）、HTTP（超文本传输协议）、DNS（域名系统）、Telnet（远程登录）、WWW、NFS</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><ul><li><p>传输数据的基本单位：<strong>比特流0和1</strong></p></li><li><p>通道：</p><ul><li>单向通道（<strong>单工通道</strong>）：单向传输</li><li>双向交替通信（<strong>半双工通信</strong>）：双向交替传输</li><li>双向同时通信（<strong>全双工通信</strong>）：双向同时传输</li></ul></li></ul><ul><li>通道复用技术：<ul><li><strong>频分复用</strong>（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li><strong>时分复用</strong>（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li><strong>波分复用</strong>（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li><strong>码分复用</strong>（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之概述&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="http://example.com/2021/09/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/09/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</id>
    <published>2021-09-17T03:45:51.000Z</published>
    <updated>2021-09-28T02:30:52.075Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回溯本质就是一颗递归树</p></blockquote><a id="more"></a><p>回溯问题的解题模板：</p><p>在回溯函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;   <span class="comment">//此处要new一个新的路径加入，因为比如说res.add(path);由于是地址传递，在回溯的最后path为空，所以res中最后结果是几个空的path</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    剪枝; <span class="comment">//画递归树看是按层剪枝还是同一个树枝剪枝。</span></span><br><span class="line">    处理节点; <span class="comment">//一般是把节点加入路径中</span></span><br><span class="line">    backtracking(选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果; <span class="comment">//一般是去掉path中最后一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>假如是排除重复的情况，注意什么时候主函数中nums要排序，什么时候要设置一个start（一般是组合问题）</li></ul><hr><ul><li>排列问题</li><li>组合问题（查找叶子结点 ）</li><li>子集问题（查找每一个子节点）</li><li>分割问题（类似组合问题）</li></ul><p>组合问题都需要设置一个 startIndex， 保证每次搜索不能重复，排列则不需要</p><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p><p>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</p><p>有同学问了，什么时候for可以从0开始呢？</p><p>求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。</p><p>但是要清楚子集问题和组合问题、分割问题的的区别，<strong>子集是收集树形结构中树的所有节点的结果</strong>。</p><p><strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，<strong>一个维度是同一树枝上使用过，一个维度是同一树层上使用过。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p><strong>两种去重方式比较</strong>：</p><p>如果要对树层中前一位去重，就用<code>used[i - 1] == false</code>，如果要对树枝前一位去重用<code>used[i - 1] == true</code>。</p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210917161342246.png" alt="树层上去重"></p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/image-20210917161411436.png" alt="树枝上去重"></p><p><strong>树层上对前一位去重非常彻底，效率很高</strong>，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><p>这两句话说的真好，我们都是在两个维度上面进行去重的，一个是同一层上，一个是一个树枝上。</p></blockquote><p>参考资料：代码随想录</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;回溯本质就是一颗递归树&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>9.11</title>
    <link href="http://example.com/2021/09/11/9-11/"/>
    <id>http://example.com/2021/09/11/9-11/</id>
    <published>2021-09-11T02:34:25.000Z</published>
    <updated>2021-10-12T01:43:17.159Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>咕咕一下</p></blockquote><a id="more"></a><p>最近事情蛮多。</p><p>前段时间忙着保研材料，感谢竞赛加分，算了下排名已经很稳很稳了。</p><p>其实你会发现，人的主观能动性所带来的的能量是非常巨大的。只要你想做什么事情，全面分析，一步一步开始做，做好长期的规划，最终的结果都是很好的。</p><p>我总是记得家里人说过的一句话，什么阶段就该做什么阶段的事情。身边的很多事例都证明了这句话的正确性。</p><p>一个阶段的结束又是另一个新阶段的开始。</p><p>可能是很久没写感想了，让我再写出什么刻骨铭心的感想也写不出来了，这段时间让思想变得简单点，再去做自己想做的事情。</p><hr><p>虽然中途差点找不到老师，好在事在人为。</p><hr><p>9.27更</p><p>最近国家一系列手段、各种政策方针下来，随着经济的高速发展，给人一种大的要来了的感觉。</p><p>疫情加速了这种割据的状态。</p><p>我对国家的发展持乐观态势，但对底层普通百姓的生活持悲观态度。</p><p>历史的发展都是相似的，从历史中得到的最大教训就是人们不会吸取历史教训。</p><p>大部分会被时代洪流裹挟着往前走。</p><hr><p>10.8更</p><p>要保持一颗积极<strong>乐观</strong>向上的心，人生的常态就是求而不得。</p><p>还有就是</p><p>如果你对未来期许太多，往往会思前想后，觉得这个没用那个没用，这个没意义那个没意思，浮于表面。</p><p>如果太过看到眼前的东西，眼界又会被遮挡住，丢掉很多有用的信息。</p><p>正确的应该是眼前有个长期的目标，但不要每天总想着要怎么才能去到达最后一步，而是把这些目标划分成一个个小小的模块，每次做一点，把每个小部分做完，在每个小部分中探索一些支线剧情，在根据目标和当前的实际情况做调整，不至于太高或太低。</p><p>好像把上面的总结一下，是未来的美好期许和眼前自身实力的差距以及想一步到位的心理要素之间的矛盾所导致的。</p><p>人太急是做不好事情的，太悠闲也只会啥也干不好。</p><p>我好像很容易陷入这两种极端中，希望能找到一个中间调和点</p><p>没有人会和你作对，即便有你也改变不了什么，大部分情况下是我们自己在做无用的情绪消耗</p><p>让时间来沉淀自己的情绪</p><p>嚯</p><hr><p>10.12更</p><p>为什么很多人会发现即使自己在教室里坐了很久：但还是时间不够用呢？</p><p>学习第一要义：进入教室后，直奔主题开始学习，不要想着先看看新闻，先刷几分钟pyq，这样会导致两种完全不一样的学习状态。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;咕咕一下&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="想法" scheme="http://example.com/categories/%E6%83%B3%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>两个大数求和</title>
    <link href="http://example.com/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <id>http://example.com/2021/09/04/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/</id>
    <published>2021-09-04T13:47:54.000Z</published>
    <updated>2021-09-19T02:32:06.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果给出两个很大很大的整数，这两个数大到long类型也装不下，比如100位整数，如何求它们的和呢？</p></blockquote><a id="more"></a><p>采用字符串存储，逆序相加，最后的结果再逆序即可</p><p><img src="/images/%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B0%E6%B1%82%E5%92%8C/image-20210904215330885.png"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1 + n2 + carry;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            res.append(tmp % <span class="number">10</span>);</span><br><span class="line">            i--; j--;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//此处要注意最后一个进位可能为1，但还没有加上去</span></span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) res.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是自己写的，有点麻烦，还是看上面的比较好</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bigNumberSum</span><span class="params">(String bigNumberA, String bigNumberB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.把两个大整数用数组逆序存储，数组长度等于较大整数位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLength = Math.max(bigNumberA.length(), bigNumberB.length());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigNumberA.length(); i++)&#123;</span><br><span class="line">        arrayA[i] = bigNumberA.charAt(bigNumberA.length() - <span class="number">1</span> - i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigNumberB.length(); i++)&#123;</span><br><span class="line">        arrayB[i] = bigNumberB.charAt(bigNumberB.length() - <span class="number">1</span>- i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.构建result数组，数组长度等于较大整数位数+1，为了保证进位数能被存放下</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[maxLength+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历数组，按位相加，每一个位置上的值=对应位数值相加再加上进位</span></span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLength; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arrayA[i] + arrayB[i] + carry;</span><br><span class="line">        <span class="keyword">if</span>(tmp &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[i] = tmp % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.如果最后一位进位为1,</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">        result[result.length - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        len = maxLength + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        len = maxLength ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.把result数组再次逆序并转成String（之前要判断首位是0还是1）</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        sb.append(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(bigNumberSum(<span class="string">&quot;426709752318&quot;</span>, <span class="string">&quot;95481253129&quot;</span>));</span><br><span class="line">    <span class="comment">//运行结果：522191005447</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果给出两个很大很大的整数，这两个数大到long类型也装不下，比如100位整数，如何求它们的和呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql相关</title>
    <link href="http://example.com/2021/09/03/mysql%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/09/03/mysql%E7%9B%B8%E5%85%B3/</id>
    <published>2021-09-03T09:04:17.000Z</published>
    <updated>2021-09-03T13:14:27.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mysql一些面试题</p></blockquote><a id="more"></a><h2 id="mysql里面的数据类型"><a href="#mysql里面的数据类型" class="headerlink" title="mysql里面的数据类型"></a>mysql里面的数据类型</h2><p>主要有三种：<strong>数值</strong>、<strong>时间</strong>和**字符串(字符)**类型。</p><img src="/images/mysql/image-20210903171114888.png" alt="数据类型"  /><p><a href="https://zhuanlan.zhihu.com/p/50891083">https://zhuanlan.zhihu.com/p/50891083</a></p><h2 id="mysql-里面时间是怎么存储的"><a href="#mysql-里面时间是怎么存储的" class="headerlink" title="mysql 里面时间是怎么存储的"></a>mysql 里面时间是怎么存储的</h2><p>存储时间的类型：year、date、time、datetime、timestamp</p><p><strong>DATE</strong> - 以YYYY-MM-DD格式的日期，在1000-01-01和9999-12-31之间。 例如，1973年12月30日将被存储为1973-12-30。</p><p><strong>DATETIME</strong> - 日期和时间组合以YYYY-MM-DD HH:MM:SS格式，在1000-01-01 00:00:00 到9999-12-31 23:59:59之间。例如，1973年12月30日下午3:30，会被存储为1973-12-30 15:30:00。</p><p><strong>TIMESTAMP</strong> - 1970年1月1日午夜之间的时间戳，到2037的某个时候。这看起来像前面的DATETIME格式，无需只是数字之间的连字符; 1973年12月30日下午3点30分将被存储为19731230153000(YYYYMMDDHHMMSS)。</p><p><strong>TIME</strong> - 存储时间在HH:MM:SS格式。</p><p><strong>YEAR(M)</strong> - 以2位或4位数字格式来存储年份。如果长度指定为2(例如YEAR(2))，年份就可以为1970至2069(70〜69)。如果长度指定为4，年份范围是1901-2155，默认长度为4。</p><p><img src="/images/mysql/v2-63be71052bbe166d1d1bfdf63a0dc83a_1440w.jpg"></p><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>索引是一种数据结构,可以帮助我们<strong>快速的进行数据的查找.</strong></p><p>拿字典作比方，字典目录的作用是快速定位某一个汉字，而索引的作用是快速定位所需数据</p><p>提出问题：为什么不用二叉搜索树？</p><p>创建索引需要两个条件，这就是：我要给谁–以什么实现方式–创建什么类型的索引</p><ol><li>给谁：就是给那个字段，这里可以是一个字段，也可以是多个字段；</li><li>实现方式：就是索引的数据结构，可以是BTREE、HASH；</li><li>类型：就是索引的类型，innoDB中一共支持四种索引类型，分别是普通索引、唯一索引、主键索引、全文索引。</li></ol><p>创建索引的字段：可以是一个字段，也可以是多个字段，在多个字段上使用时需要满足最左匹配原则。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><ul><li>单值索引</li><li>主键索引</li><li>唯一索引</li><li>复合索引</li></ul><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>索引的数据结构和具体存储引擎的实现有关, 在MySQL中使用较多的索引有<strong>Hash索引,B+树索引</strong>等,而我 们经常使用的<strong>InnoDB存储引擎</strong>的默认索引实现为:B+树索引.</p><h2 id="聚簇索引非聚簇索引"><a href="#聚簇索引非聚簇索引" class="headerlink" title="聚簇索引非聚簇索引"></a>聚簇索引非聚簇索引</h2><p>一些关键词：</p><p>InnoDB、MyISAM</p><p>索引、B+树、聚簇索引、</p><p>事务、并发事务、事务回滚、隔离级别</p><p>mysql锁、锁算法、锁优化、</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;mysql一些面试题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>http相关内容</title>
    <link href="http://example.com/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>http://example.com/2021/09/01/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</id>
    <published>2021-09-01T11:52:13.000Z</published>
    <updated>2021-09-20T07:51:01.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>http</p></blockquote><a id="more"></a><h2 id="在浏览器中输入url到显示页面的过程中发生了什么？"><a href="#在浏览器中输入url到显示页面的过程中发生了什么？" class="headerlink" title="在浏览器中输入url到显示页面的过程中发生了什么？"></a>在浏览器中输入url到显示页面的过程中发生了什么？</h2><p>1、通过DNS解析<strong>将域名解析为对应的IP地址</strong> ，寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。  （DNS解析过程）</p><p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;（三次握手具体过程） </p><p>3、由浏览器发送一个HTTP请求 ，经过路由器的转发，到达了服务器 </p><p>4、服务器处理该HTTP请求，返回一个HTML文件 </p><p>5、浏览器解析该HTML文件，并且显示在浏览器端</p><blockquote><p>DNS解析过程：</p><p>DNS查找过程：浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存（hosts文件）中是否有这个域名对应的DNS解析结果。若还没有，此时会发送一个数据包给DNS服务器，DNS服务器找到后将解析所得IP地址返回给用户。</p></blockquote><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>超文本传输协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），属于应用层，端口号80</p><p>HTTP协议<strong>定义Web客户端如何向Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。</strong></p><p>HTTP协议采用了<strong>请求/响应模型</strong>。<strong>客户端向服务器发送一个请求报文</strong>，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。<strong>服务器以一个状态行作为响应</strong>，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>请求报文包含三部分：</p><ul><li>请求行：包含请求方法、URI、HTTP版本信息</li><li>请求首部字段</li><li>请求内容实体</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901204224623.png" alt="请求报文结构"></p><p>响应报文包含三部分：</p><ul><li>状态行：包含HTTP版本、状态码、状态码的原因短语</li><li>响应首部字段</li><li>响应内容实体</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901204401019.png" alt="响应报文结构"></p><h2 id="常用的-HTTP-请求方法"><a href="#常用的-HTTP-请求方法" class="headerlink" title="常用的 HTTP 请求方法"></a>常用的 HTTP 请求方法</h2><ul><li>GET：<strong>GET方法用来请求URL指定的资源。</strong>指定的资源经服务器端解析后返回响应内容 </li><li>POST：<strong>用于传输信息给服务器，主要功能与GET方法类似</strong>，但一般推荐使用POST方式。 </li><li>PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。 </li><li>HEAD：获得报文首部，与GET方法类似，只是不返回报文主体</li><li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 </li><li>OPTIONS：请求一些选项信息，允许客户端查看服务器的性能</li></ul><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901200949347.png" alt="option方法作用"></p><h2 id="Get与Post的区别"><a href="#Get与Post的区别" class="headerlink" title="Get与Post的区别"></a>Get与Post的区别</h2><p>1、 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源</p><p>2、GET是<strong>幂等的，即读取同一个资源，总是得到相同的数据</strong>，而POST不是幂等 的，因为每次请求对资源的改变并不是相同的</p><p>3、就安全性而言，<strong>POST的安全性要比GET的安全性高</strong>，因为GET请求提交的数据将<strong>明文</strong>出现在URL上， 而且POST请求参数则被包装到<strong>请求体</strong>中，相对更安全。</p><p>4、从请求的大小看，<strong>GET请求的长度受限于浏览器或服务器对URL长度的限制</strong>，允许发送的数据量比较小，而POST请求则是没有大小限制的。</p><h2 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h2><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901201650517.png" alt="状态码"></p><p>一些常见状态码的含义：</p><table><thead><tr><th>状态码</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>初始的请求已经接受，请客户端继续发送剩余部分</td></tr><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>301</td><td>永久移动</td><td>请求的页面已永久跳转到新的url</td></tr><tr><td>401</td><td>未授权</td><td>请求要求用户进行身份演验证</td></tr><tr><td>403</td><td>禁止</td><td>服务器拒绝请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的页面</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理出现错误</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr></tbody></table><h2 id="什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议"><a href="#什么是-HTTP-协议无状态协议？怎么解决Http协议无状态协议" class="headerlink" title="什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?"></a>什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?</h2><p><strong>概念</strong>：是指每一次的请求都是独立的，客户端第一次向服务器发送请求完成之后，再一次向服务器发送请求，服务器并不知道该客户端是刚才那个。</p><p><strong>解决方法</strong>：</p><p>使用Cookie和Session技术（引出这两个知识点）</p><h2 id="Cookie和Session技术"><a href="#Cookie和Session技术" class="headerlink" title="Cookie和Session技术"></a>Cookie和Session技术</h2><h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><p>1、端口：HTTP的URL由”http://起始且默认使用端口80，而HTTPS的URL由”https:/起始且默认使用端口443.</p><p>2、安全性和资源消耗：</p><p>HTTP协议运行在TCP之上，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份。</p><p>HTTPS是运行在<strong>SSL</strong>之上的HTTP协议，SSL运行在TCP之上。所有传输的内容都经过加密，<strong>加密采用对称加密</strong>，但对<strong>称加密的密钥用服务器方的证书进行了非对称加密</strong>。所以说，<strong>HTTP安全性没有HTTPS高，但是HTTPS比HTTP耗费更多服务器资源。</strong></p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><blockquote><p>对称加密：密钥只有一个，加密解密为同一个密钥，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p>非对称加密：公钥所有人都可以获得，通信发送方获得接收方的公钥之后，就可以使用公钥进行加密，接收方收到通信内容后使用私钥解密。相对对称加密速度较慢。</p><p>SSL：安全套接层（Secure Sockets Layer ）</p><p><img src="/images/http%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/image-20210901215413693.png"></p></blockquote><h2 id="HTTP长连接-短连接"><a href="#HTTP长连接-短连接" class="headerlink" title="HTTP长连接,短连接"></a>HTTP长连接,短连接</h2><p>HTTP的长连接和短连接<strong>本质上是TCP长连接和短连接</strong>。</p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p><p>Keep-Alive不会永久保持连接，它有一个<strong>保持时间</strong>，可以在header当中进行设置的。实现长连接需要客户端和服务端都支持长连接。</p><h3 id="什么时候用长连接，短连接？"><a href="#什么时候用长连接，短连接？" class="headerlink" title="什么时候用长连接，短连接？"></a><strong>什么时候用长连接，短连接？</strong></h3><ol><li>长连接多用于<strong>操作频繁，点对点的通讯，而且连接数不能太多情况</strong>，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</li><li>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。<strong>所以并发量大，但每个用户无需频繁操作情况下需用短连好。</strong></li></ol><h3 id="长连接与短连接区别"><a href="#长连接与短连接区别" class="headerlink" title="长连接与短连接区别:"></a>长连接与短连接区别:</h3><p>**长连接:**连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）； </p><p>**短连接:**连接→数据传输→关闭连接；</p><h2 id="Http1-0-和-Http1-1-有什么区别？"><a href="#Http1-0-和-Http1-1-有什么区别？" class="headerlink" title="Http1.0 和 Http1.1 有什么区别？"></a>Http1.0 和 Http1.1 有什么区别？</h2><p>HTTP1.0出现早，主要用于一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ul><li>长连接 : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li>错误状态响应码 :<strong>在HTTP1.1中新增了24个错误状态响应码</strong>，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="http" scheme="http://example.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络——应用层</title>
    <link href="http://example.com/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://example.com/2021/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2021-09-01T09:07:44.000Z</published>
    <updated>2021-09-20T08:09:27.026Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络之应用层</p></blockquote><a id="more"></a><h2 id="域名系统（DNS）-Domain-Name-System"><a href="#域名系统（DNS）-Domain-Name-System" class="headerlink" title="域名系统（DNS）  Domain Name System"></a>域名系统（DNS）  Domain Name System</h2><p>DNS 可以使用 <strong>UDP 或者 TCP</strong> 进行传输，使用的<strong>端口号都为 53。</strong>大多数情况下 DNS 使用 <strong>UDP 进行传输</strong>，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 <strong>TCP 进行传输：</strong></p><ul><li>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com</li><li>如果返回的响应<strong>超过 512 字节</strong>（UDP 最大只支持 512 字节的数据）。</li><li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li></ul><p><strong>域名有什么用？</strong></p><p>我们可以通过IP地址去访问网站，但ip地址并不好记，域名是具有一定含义的字符组合。域名系统可以将域名与IP地址相互映射。便于人们访问网页。</p><p><strong>DNS劫持：</strong></p><p>指某些手段取得域名的解析控制权，将此地址指向一个错误的IP地址的行为，相当于访问到的并不是原来的网页。</p><h2 id="文件传送协议（FTP）File-Transfer-Protocol"><a href="#文件传送协议（FTP）File-Transfer-Protocol" class="headerlink" title="文件传送协议（FTP）File Transfer Protocol"></a>文件传送协议（FTP）File Transfer Protocol</h2><p>FTP使用两个并行的<strong>TCP</strong>连接来传输文件，一个是控制连接，一个是数据连接。</p><ul><li><strong>控制连接</strong>：服务器打开<strong>端口号 21</strong> 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li><li><strong>数据连接</strong>：用来传送一个文件数据。</li></ul><p>根据数据连接是否是服务器端主动建立，FTP 有<strong>主动</strong>和<strong>被动</strong>两种模式：</p><ul><li><p><strong>主动模式</strong>：服务器端主动建立数据连接，其中服务器端的<strong>端口号为 20</strong>，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</p></li><li><p><strong>被动模式</strong>：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p></li></ul><p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。</p><p>被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p><p>还有一个TFTP（Trivial File Transfer Protocol,简单文件传输协议）看做是FTP的简化版本，使用UDP传输，简单，速度快，但是安全性不好（使用UDP传输）</p><h2 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了<strong>即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。</strong></p><p>DHCP 配置的内容不仅是 IP 地址，还包括<strong>子网掩码</strong>、<strong>网关 IP 地址。</strong></p><h2 id="远程登录协议（TELNET）"><a href="#远程登录协议（TELNET）" class="headerlink" title="远程登录协议（TELNET）"></a>远程登录协议（TELNET）</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p><p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：<strong>用户代理</strong>、<strong>邮件服务器</strong>以及<strong>邮件协议</strong>。</p><p>邮件协议包含发送协议和读取协议，<strong>发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</strong></p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/image-20210901172320605.png"></p><h3 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1. SMTP"></a>1. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p><h3 id="2-POP3"><a href="#2-POP3" class="headerlink" title="2. POP3"></a>2. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。</p><h3 id="3-IMAP"><a href="#3-IMAP" class="headerlink" title="3. IMAP"></a>3. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络之应用层&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历模板</title>
    <link href="http://example.com/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2021/09/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</id>
    <published>2021-09-01T02:04:34.000Z</published>
    <updated>2021-09-02T10:31:43.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树遍历模板</p></blockquote><a id="more"></a><p>使用迭代法：</p><p>前序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val);   <span class="comment">//中序相当于把这一句移到了下面代码块中间</span></span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList();    <span class="comment">//在前序遍历的基础上换成了LinkedList</span></span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.addFirst(root.val);   </span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;   <span class="comment">//在前序遍历的基础上把左右子树的顺序换了一下</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;二叉树遍历模板&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="面试学习系列" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
</feed>
